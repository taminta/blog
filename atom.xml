<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Japan Azure IaaS Core Support Blog</title>
  
  <subtitle>日本マイクロソフトの Azure IaaS テクニカル サポート チームより、情報をお届けします！</subtitle>
  <link href="https://jpaztech.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://jpaztech.github.io/blog/"/>
  <updated>2024-02-16T07:05:26.190Z</updated>
  <id>https://jpaztech.github.io/blog/</id>
  
  <author>
    <name>Japan Azure IaaS Core Support Team</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Azure Peering Service と ExpressRoute の違いについて</title>
    <link href="https://jpaztech.github.io/blog/network/azure-peering-service-vs-expressroute/"/>
    <id>https://jpaztech.github.io/blog/network/azure-peering-service-vs-expressroute/</id>
    <published>2024-01-29T01:00:00.000Z</published>
    <updated>2024-02-16T07:05:26.190Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure サポートの宇田です。<br>今回は Azure Peering Service と ExpressRoute の違いについてご紹介いたします。</p><h2 id="Azure-Peering-Service-とはどのようなサービスか"><a href="#Azure-Peering-Service-とはどのようなサービスか" class="headerlink" title="Azure Peering Service とはどのようなサービスか"></a>Azure Peering Service とはどのようなサービスか</h2><p>Microsoft Azure Peering Service (MAPS) は、インターネット サービス プロバイダー (ISP) や Internet Exchange (IX) 経由で Microsoft のグローバル ネットワーク (AS8075) へのルーティングを最適化し信頼性とパフォーマンスを強化するサービスです。サービス名に “Azure” の名前を冠してはいますが、その接続先は Azure だけではなく、パブリック インターネット経由でアクセス可能な Microsoft 365 や Dynamics 365 等を含んだ Microsoft のグローバル ネットワーク全体になります。</p><p>また、以下のドキュメントにも記載がありますが、Azure Peering Service は閉域接続 (プライベート接続) サービスではありません。あくまでも ISP や IX 経由で直接 Microsoft のネットワークに接続するサービスですので、他の AS を経由しない分だけホップ数や遅延が小さく抑えられ、通信経路上の影響を受けにくいというのみであり、位置づけとしてはパブリック ネットワーク (≒インターネット) 経由での接続となります。</p><ul><li><a href="https://learn.microsoft.com/ja-jp/azure/peering-service/about">Azure Peering Service の概要</a></li></ul><h2 id="ExpressRoute-の-Microsoft-Peering-と何が違うのか"><a href="#ExpressRoute-の-Microsoft-Peering-と何が違うのか" class="headerlink" title="ExpressRoute の Microsoft Peering と何が違うのか"></a>ExpressRoute の Microsoft Peering と何が違うのか</h2><p>Azure Peering Service と似たサービスとして、ExpressRoute 回線 (ExpressRoute Circuit) の Microsoft Peering が存在します。両者の違いについてお問い合わせいただく事も多いため、具体的な差異を以下の表でご説明します。</p><table><thead><tr><th></th><th>Azure Peering Service</th><th>ExpressRoute (Microsoft Peering)</th></tr></thead><tbody><tr><td>接続先</td><td>Microsoft のグローバル ネットワーク</td><td>主に Azure のみ</td></tr><tr><td>Microsoft 側の ASN</td><td>8075</td><td>12076</td></tr><tr><td>接続形態</td><td>パブリック接続 (≒インターネット)</td><td>プライベート接続 (≒閉域網)</td></tr><tr><td>Azure VNet への接続</td><td>不可</td><td>Private Peering を構成すれば可能</td></tr><tr><td>Microsoft 365 との接続 <a href="#Microsoft-365-%E3%81%A8%E3%81%AE%E6%8E%A5%E7%B6%9A%E3%81%AB%E9%96%A2%E3%81%97%E3%81%A6">(*)</a></td><td>可能</td><td>一部の承認されたお客様のみ可能</td></tr><tr><td>Azure 上のリソース <a href="#Microsoft-%E3%81%AE%E9%96%A2%E4%B8%8E%E3%81%99%E3%82%8B%E7%AF%84%E5%9B%B2%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">(**)</a></td><td>テレメトリ機能を利用する場合のみ作成</td><td>ExpressRoute 回線リソースを作成</td></tr><tr><td>接続料金 <a href="#Microsoft-%E3%81%AE%E9%96%A2%E4%B8%8E%E3%81%99%E3%82%8B%E7%AF%84%E5%9B%B2%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">(**)</a></td><td>原則、接続プロバイダー様のみにお支払い</td><td>Azure と接続プロバイダー様の双方にお支払い</td></tr><tr><td>SLA <a href="#Microsoft-%E3%81%AE%E9%96%A2%E4%B8%8E%E3%81%99%E3%82%8B%E7%AF%84%E5%9B%B2%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">(**)</a></td><td>接続プロバイダー様にご確認ください</td><td>MSEE 側の問題であれば Microsoft 側の SLA 有り</td></tr><tr><td>サポート窓口 <a href="#Microsoft-%E3%81%AE%E9%96%A2%E4%B8%8E%E3%81%99%E3%82%8B%E7%AF%84%E5%9B%B2%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">(**)</a></td><td>原則、接続プロバイダー様</td><td>Azure (MSEE) 側は Microsoft、PE 側は接続プロバイダー様</td></tr></tbody></table><h3 id="Microsoft-365-との接続に関して"><a href="#Microsoft-365-との接続に関して" class="headerlink" title="(*) Microsoft 365 との接続に関して"></a>(*) Microsoft 365 との接続に関して</h3><p><a href="https://learn.microsoft.com/ja-jp/microsoft-365/enterprise/azure-expressroute">Azure ExpressRoute for Microsoft 365</a> に以下の記載がある通り、ExpressRoute での Microsoft 365 への接続は承認制となっています。法規制により閉域接続が必須となっているような一部のお客様に限ってのみ承認され、そうした特殊な要件がない場合にはご利用いただけません。Microsoft 365 との安定した接続を確保したい一般のお客様は、Azure Peering Service での接続をご検討ください。(ただし、前述の通り Azure Peering Service は閉域接続のためのサービスではございませんのでご留意ください。)</p><blockquote><p>Microsoft 365 の ExpressRoute は、ほとんどの状況でサービスに最適な接続モデルを提供しないため 、お勧めしません 。 そのため、この接続モデルを使用するには Microsoft の承認が必要です。 お客様のすべての要求を確認し、必要なまれなシナリオでのみ、Microsoft 365 の ExpressRoute を承認します。 詳細については 、<a href="https://aka.ms/erguide">ExpressRoute for Microsoft 365 ガイド</a> を参照してください。また、生産性、ネットワーク、セキュリティ チームに関するドキュメントの包括的なレビューに従って、Microsoft アカウント チームと協力して、必要に応じて例外を送信してください。 Microsoft 365 のルート フィルターを作成しようとしている未承認のサブスクリプションには、 <a href="https://support.microsoft.com/kb/3181709">エラー メッセージが表示</a>されます。</p></blockquote><p>また、Microsoft 365 は Internet 経由で快適にご利用いただけるよう弊社外の 3rd party の CDN サービス等も利用しているため、ExpressRoute と Azure Peering Service のいずれを利用される場合であっても、弊社外のエンドポイントとの通信に Internet 接続が必要となりますので、十分ご留意ください。</p><h3 id="Microsoft-の関与する範囲について"><a href="#Microsoft-の関与する範囲について" class="headerlink" title="(**) Microsoft の関与する範囲について"></a>(**) Microsoft の関与する範囲について</h3><p>ExpressRoute をご利用の場合には、Azure 上で ExpressRoute 回線のリソースを作成したり、各種設定をご実施いただきます。他方で Azure Peering Service に関しては、(テレメトリの機能を利用しない限りは) Azure 上のリソースは作成したり、設定を行っていただく必要はなく、ExpressRoute 回線のように Microsoft に対して接続料金をお支払いいただくことはありません。言い換えますと、仮に通信障害などが発生したとしても、Microsoft としては料金を頂戴していないため、SLA による返金はございません。(接続プロバイダー様による SLA の提供有無をご確認ください。)</p><p>また、Azure 側に個々のお客様のリソースが存在せず、各接続プロバイダー様とお客様間の契約情報なども弊社では把握できないことから、障害時に Microsoft 側へお問い合わせいただいたとしても環境固有の調査などを行うことができません。したがって、トラブル時のお問い合わせ先 (サポート窓口) は原則として Microsoft ではなく、接続プロバイダー様となります。(接続プロバイダー様によって Microsoft 側に問題があると判断された場合には、接続プロバイダー様と弊社の NOC 間で調査を行うこととなります。)</p><p>以上、ご参考になれば幸いです。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは。Azure サポートの宇田です。&lt;br&gt;今回は Azure Peering Service と ExpressRoute の違いについてご紹介いたします。&lt;/p&gt;
&lt;h2 id=&quot;Azure-Peering-Service-とはどのようなサービスか&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="Network" scheme="https://jpaztech.github.io/blog/tags/Network/"/>
    
    <category term="ExpressRoute" scheme="https://jpaztech.github.io/blog/tags/ExpressRoute/"/>
    
    <category term="Azure Peering Service" scheme="https://jpaztech.github.io/blog/tags/Azure-Peering-Service/"/>
    
  </entry>
  
  <entry>
    <title>Azure Network 製品について TLS 1.2 以降に移行するアナウンスの補足 (Tracking ID:7_8G-D8Z)</title>
    <link href="https://jpaztech.github.io/blog/network/tls1.2_migration/"/>
    <id>https://jpaztech.github.io/blog/network/tls1.2_migration/</id>
    <published>2024-01-29T00:10:00.000Z</published>
    <updated>2024-02-16T07:05:26.210Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームです。<br>「2024 年 10 月 31 日までに、各種 Azure サービスとの通信に TLS 1.2 を使用していることを確認してください。」（Ensure your resources that interact with Azure services are using TLS 1.2 by 31 October 2024）の通知について補足させて頂きます。</p><p>メールに記載されておりますとおり、セキュリティとコンプライアンスの観点からレガシー TLS 1.0/1.1 は既知の脆弱性が存在しており、Azure 上のマネージド サービス全般におきまして、2024 年 10 月 31 日以降は TLS 1.2 以上の接続が必須となるよう変更されるものです。</p><h2 id="TLS-バージョンとは"><a href="#TLS-バージョンとは" class="headerlink" title="TLS バージョンとは"></a>TLS バージョンとは</h2><p>TLS（Transport Layer Security）は、インターネット上でデータを安全に送受信するための暗号化する仕組みとして、主に TLS 1.0, TLS 1.1、TLS 1.2 及び TLS 1.3 バージョンが存在していますが、<a href="https://datatracker.ietf.org/doc/html/rfc8996">RFC 8996</a> により、セキュリティ脆弱性の原因で、TLS 1.0 及び TLS 1.1 の使用は既に廃止されています。Azure サービスでは、互換性の理由で TLS 1.0 及び TLS 1.1 が引き続き動作できますが、早めに TLS 1.2 以降のバージョンへ移行するのは強く推奨しております。</p><h2 id="TLS-接続時のバージョン選定動作について"><a href="#TLS-接続時のバージョン選定動作について" class="headerlink" title="TLS 接続時のバージョン選定動作について"></a>TLS 接続時のバージョン選定動作について</h2><p>TLS のバージョンはお客様の IaaS 上の仮想マシン OS の設定、ならびにクライアント OS に依存します。こちらの設定確認をし、TLS 1.2 以上を使用できる状態としていただくことで、自動的に TLS の最上位バージョンでの接続を試みることとなります。</p><h3 id="Windows-OS-の場合"><a href="#Windows-OS-の場合" class="headerlink" title="Windows OS の場合"></a>Windows OS の場合</h3><p><a href="https://learn.microsoft.com/ja-jp/security/engineering/solving-tls1-problem#supported-versions-of-tls-in-windows">こちらの公開ドキュメント</a>の記載通り、Windows 8/Windows Server 2012 以降では、既に TLS 1.2 をサポートしているため、基本的にご対応頂く必要はありません。<br>また、特定の TLS バージョンを有効化/無効化されたい場合は、<a href="https://jpwinsup.github.io/blog/2021/12/22/PublicKeyInfrastructure/SSLTLSConnection/tls-registry-settings/">こちらの記事</a>の通りご対応ください。</p><p>Windows 2008/ Windows 7 などのレガシー OS でも更新プログラムを適用することで技術的には TLS 1.2 を使えるようになります。ただし、サポートの提供が終了している OS の場合には、TLS 1.2 を利用できるようになる更新プログラムの適用にかかわらず、技術的なご支援を Microsoft サポートからお届けすることはできません。自己責任の範疇でご利用ください。</p><p>参考として、Android など他のクライアント対応状況は<a href="https://learn.microsoft.com/ja-jp/security/engineering/solving-tls1-problem#appendix-a-handshake-simulation">こちら</a>の公開ドキュメントに開示されています。 </p><h3 id="Chrome-Edge-などのブラウザの場合"><a href="#Chrome-Edge-などのブラウザの場合" class="headerlink" title="Chrome/Edge などのブラウザの場合"></a>Chrome/Edge などのブラウザの場合</h3><p>最新バージョンの各ブラウザでは、基本的に TLS 1.2 以降のバージョンが有効化されているため、ご対応頂く必要はありませんが、<br>特定の TLS バージョンを有効化/無効化されたい場合は、各ブラウザ観点でご確認頂く必要がございます。<br>Edgeの場合は<a href="https://learn.microsoft.com/en-us/answers/questions/487582/is-there-a-way-to-emable-tls-1-0-and-or-1-2-on-edg">こちらの記事</a>の通り対応できます。</p><h3 id="それ以外の場合"><a href="#それ以外の場合" class="headerlink" title="それ以外の場合"></a>それ以外の場合</h3><p>上記以外に、Java などプログラミング言語でお客様が開発したアプリケーションで Azure サービスへ接続する場合は、Windows OS の TLS レジストリ設定を参照せず、独自の設定通り接続する場合がありますので、お客様側にアプリケーション観点で TLS の通信バージョンご確認及びご対応頂く必要があります。</p><h3 id="TLS-チェッカー-ツール"><a href="#TLS-チェッカー-ツール" class="headerlink" title="TLS チェッカー ツール"></a>TLS チェッカー ツール</h3><p><a href="https://clienttest.ssllabs.com:8443/ssltest/viewMyClient.html">こちら</a>のような外部の TLS チェッカー ツールをご活用いただき、想定されるクライアントからアクセスをして TLS バージョンを確認いただくということも有効です。</p><h2 id="Azure-Network製品の対応状況及び推奨アクションについて"><a href="#Azure-Network製品の対応状況及び推奨アクションについて" class="headerlink" title="Azure Network製品の対応状況及び推奨アクションについて"></a>Azure Network製品の対応状況及び推奨アクションについて</h2><p>以下にて Azure Network 製品の対応状況、及びお客様に推奨なアクションをご紹介致します。<br>もしご確認されたい製品が入っていなく、個別にご確認されたい場合は、各製品に対してサポート リクエストを起票してください。</p><div class="alert is-warning"><p class="alert-title">警告</p><p>以下各製品の部分に案内する対処目処はあくまで目途であり、実際には日程が多少前後する可能性があります。予めご了承ください。</p></div><span id="more"></span><h2 id="Application-Gateway"><a href="#Application-Gateway" class="headerlink" title="Application Gateway"></a>Application Gateway</h2><h3 id="クライアントから-Application-Gateway-への接続について"><a href="#クライアントから-Application-Gateway-への接続について" class="headerlink" title="クライアントから Application Gateway への接続について"></a>クライアントから Application Gateway への接続について</h3><p>Application Gateway では、SSL ポリシーを選択することで、クライアントが Application Gateway へ接続する際の最小 TLS バージョン（1.0 から 1.3 まで）を設定できます。 </p><p>現時点では、Application Gateway は2024 年 10 月 31 日以降にも引き続き TLS1.0 から TLS1.3 をサポートしており、TLS1.2 以下のバージョンをサポートしなくなる予定はございません。 </p><p>ただし、<a href="https://learn.microsoft.com/ja-jp/azure/application-gateway/application-gateway-configure-ssl-policy-powershell">こちらの公開ドキュメント</a>の記載通り、セキュリティ強化のためには TLS1.2 のご利用を推奨いたします。 </p><blockquote><p>注意<br>Application Gateway でのセキュリティを強化するために、TLS プロトコルの最小バージョンとして TLS 1.2 を使用することをお勧めします。</p></blockquote><h4 id="最小TLS-バージョンの設定方法"><a href="#最小TLS-バージョンの設定方法" class="headerlink" title="最小TLS バージョンの設定方法"></a>最小TLS バージョンの設定方法</h4><p>下図の通り、Azure ポータル → 対象 Application Gateway → 「リスナー」のタブにて、 「選択した SSL ポリシー」の「変更」ボタンをクリックし、「 SSL ポリシーの変更」より設定できます。<br><img src="./appgw_tls_setting.png"></p><p>また、Application Gateway SKU v2 の場合は、<a href="https://learn.microsoft.com/ja-jp/azure/application-gateway/application-gateway-configure-listener-specific-ssl-policy">こちらの手順通り</a>、リスナー毎に異なる TLS バージョンを設定することも可能です。 </p><h3 id="Application-Gateway-からバックエンド-サーバーへの接続について"><a href="#Application-Gateway-からバックエンド-サーバーへの接続について" class="headerlink" title="Application Gateway からバックエンド サーバーへの接続について"></a>Application Gateway からバックエンド サーバーへの接続について</h3><p><a href="https://learn.microsoft.com/ja-jp/azure/application-gateway/application-gateway-ssl-policy-overview#limitations">こちらの公開ドキュメント</a>の記載通り、Application Gateway がバックエンド サーバーへ通信する際に TLS 1.0, 1.1, 1.2 をサポートしております。 </p><blockquote><p>バックエンド サーバーへの接続は、常に最小でプロトコル TLS v1.0、最大で TLS v1.2 までです。 そのため、バックエンド サーバーとのセキュリティで保護された接続を確立するには、TLS バージョン 1.0、1.1、1.2 のみがサポートされます。</p></blockquote><p>具体的な TLS バージョンの選定は接続先のバックエンド サーバーに依存するため、もし最小 TLS バージョンを 1.2 に指定したい場合は、Application Gateway ではなく、バックエンド サーバー側の TLS 設定に対応して頂く必要があります。 </p><h2 id="Azure-Firewall"><a href="#Azure-Firewall" class="headerlink" title="Azure Firewall"></a>Azure Firewall</h2><p>Azure Firewall では、TLS バージョンが関わる部分は TLS インスペクションのみとなります。アプリケーション ルール、ネットワーク ルール、及び DNAT ルールで通信を許可する場合は本通知の対象外となります。</p><p>TLS インスペクション機能を使用する場合は、<a href="https://learn.microsoft.com/ja-jp/azure/firewall/premium-features#tls-inspection">こちらの公開ドキュメント</a>の記載通り、現状及び 2024 年 10 月 31 日以降にも TLS1.0 及び TLS1.1 は互換性のために引き続き動作する予定ですが、早めに TLS 1.2 に移行することを強く推奨します。</p><blockquote><p>ヒント<br>TLS 1.0 と 1.1 は非推奨になっていて、サポートされません。 TLS 1.0 と 1.1 のバージョンの TLS/SSL (Secure Sockets Layer) は脆弱であることが確認されています。現在、これらは下位互換性を維持するために使用可能ですが、推奨されていません。 できるだけ早く TLS 1.2 に移行してください。</p></blockquote><p>また、現状の TLS インスペクション機能では TLS1.3 をサポートしておりませんが、2024 年 3 月頃にサポートする予定です。</p><h2 id="Front-Door"><a href="#Front-Door" class="headerlink" title="Front Door"></a>Front Door</h2><p><a href="https://learn.microsoft.com/ja-jp/azure/frontdoor/end-to-end-tls?pivots=front-door-standard-premium#supported-tls-versions">こちらの公開ドキュメント</a>の記載通り、 Front Door ではカスタム ドメインを利用する場合は、最小 TLS バージョンを 1.0 または 1.2 を選択できます。 </p><blockquote><p>Azure Front Door では、TLS プロトコルの 3 つのバージョン (TLS バージョン 1.0、1.1、1.2) がサポートされています。 2019 年 9 月以降に作成されたすべての Azure Front Door プロファイルでは、既定の最小バージョンとして TLS 1.2 が使用されますが、下位互換性を確保するために TLS1.0 と TLS1.1 も引き続きサポートされています。</p></blockquote><p>Front Door では 2024 年 10 月 31 日以降も引き続き TLS1.0 から TLS1.2 まで利用できますが、セキュリティ強化のためには TLS1.2 のご利用を推奨いたします。<br>また、TLS1.3 のサポートに関しましては、2024 年 2 月 12 日より Front Door の全 SKU 及びAzure CDN Standard from Microsoft (classic) に順次サポートする予定です。</p><h2 id="Private-Link-Service-または-Private-Endpoint"><a href="#Private-Link-Service-または-Private-Endpoint" class="headerlink" title="Private Link Service または Private Endpoint"></a>Private Link Service または Private Endpoint</h2><p>Private Link Service と Private Endpoint のサービスでは、TLS プロトコルは終端しません。<br>Private Link Service と Private Endpoint を利用した通信の場合には、クライアントとサーバーの通信上の両端で TLS ネゴシエーションが実施されます。クライアントおよびサーバーとなるサービスの観点でご確認頂く必要があります。 </p><h2 id="Bastion"><a href="#Bastion" class="headerlink" title="Bastion"></a>Bastion</h2><p>Bastion はお客様側で証明書の管理運用を意識する必要のないサービスとして、<a href="https://learn.microsoft.com/ja-jp/azure/bastion/bastion-overview#key">以下の公開ドキュメント</a>の記載通り、 TLS 1.2 のみをサポートしておりますので、お客様側の対処が不要です。 </p><blockquote><p>Bastion では、TLS 1.2 以降がサポートされています。 以前の TLS バージョンはサポートされません。</p></blockquote><h2 id="Traffic-Manager"><a href="#Traffic-Manager" class="headerlink" title="Traffic Manager"></a>Traffic Manager</h2><p><a href="https://learn.microsoft.com/ja-jp/azure/traffic-manager/traffic-manager-how-it-works#how-clients-connect-using-traffic-manager">こちらの公開ドキュメント</a>の説明通り、TrafficManager は DNS レベルで動作する負荷分散サービスとして、クライアントからの通信は TrafficManager を経由しませんので、本通知の対象外となります。 </p><h2 id="Load-Balancer"><a href="#Load-Balancer" class="headerlink" title="Load Balancer"></a>Load Balancer</h2><p><a href="https://learn.microsoft.com/ja-jp/azure/load-balancer/load-balancer-faqs#azure-load-balancer---tls-ssl---------------">こちらの公開ドキュメント</a>記載通り、Azure Load Balancer では、TLS 接続を終端せずにバックエンド サーバーへ転送する動作となりますので、本通知の対象外となります。 </p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームです。&lt;br&gt;「2024 年 10 月 31 日までに、各種 Azure サービスとの通信に TLS 1.2 を使用していることを確認してください。」（Ensure your resources that interact with Azure services are using TLS 1.2 by 31 October 2024）の通知について補足させて頂きます。&lt;/p&gt;
&lt;p&gt;メールに記載されておりますとおり、セキュリティとコンプライアンスの観点からレガシー TLS 1.0/1.1 は既知の脆弱性が存在しており、Azure 上のマネージド サービス全般におきまして、2024 年 10 月 31 日以降は TLS 1.2 以上の接続が必須となるよう変更されるものです。&lt;/p&gt;
&lt;h2 id=&quot;TLS-バージョンとは&quot;&gt;&lt;a href=&quot;#TLS-バージョンとは&quot; class=&quot;headerlink&quot; title=&quot;TLS バージョンとは&quot;&gt;&lt;/a&gt;TLS バージョンとは&lt;/h2&gt;&lt;p&gt;TLS（Transport Layer Security）は、インターネット上でデータを安全に送受信するための暗号化する仕組みとして、主に TLS 1.0, TLS 1.1、TLS 1.2 及び TLS 1.3 バージョンが存在していますが、&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc8996&quot;&gt;RFC 8996&lt;/a&gt; により、セキュリティ脆弱性の原因で、TLS 1.0 及び TLS 1.1 の使用は既に廃止されています。Azure サービスでは、互換性の理由で TLS 1.0 及び TLS 1.1 が引き続き動作できますが、早めに TLS 1.2 以降のバージョンへ移行するのは強く推奨しております。&lt;/p&gt;
&lt;h2 id=&quot;TLS-接続時のバージョン選定動作について&quot;&gt;&lt;a href=&quot;#TLS-接続時のバージョン選定動作について&quot; class=&quot;headerlink&quot; title=&quot;TLS 接続時のバージョン選定動作について&quot;&gt;&lt;/a&gt;TLS 接続時のバージョン選定動作について&lt;/h2&gt;&lt;p&gt;TLS のバージョンはお客様の IaaS 上の仮想マシン OS の設定、ならびにクライアント OS に依存します。こちらの設定確認をし、TLS 1.2 以上を使用できる状態としていただくことで、自動的に TLS の最上位バージョンでの接続を試みることとなります。&lt;/p&gt;
&lt;h3 id=&quot;Windows-OS-の場合&quot;&gt;&lt;a href=&quot;#Windows-OS-の場合&quot; class=&quot;headerlink&quot; title=&quot;Windows OS の場合&quot;&gt;&lt;/a&gt;Windows OS の場合&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://learn.microsoft.com/ja-jp/security/engineering/solving-tls1-problem#supported-versions-of-tls-in-windows&quot;&gt;こちらの公開ドキュメント&lt;/a&gt;の記載通り、Windows 8/Windows Server 2012 以降では、既に TLS 1.2 をサポートしているため、基本的にご対応頂く必要はありません。&lt;br&gt;また、特定の TLS バージョンを有効化/無効化されたい場合は、&lt;a href=&quot;https://jpwinsup.github.io/blog/2021/12/22/PublicKeyInfrastructure/SSLTLSConnection/tls-registry-settings/&quot;&gt;こちらの記事&lt;/a&gt;の通りご対応ください。&lt;/p&gt;
&lt;p&gt;Windows 2008/ Windows 7 などのレガシー OS でも更新プログラムを適用することで技術的には TLS 1.2 を使えるようになります。ただし、サポートの提供が終了している OS の場合には、TLS 1.2 を利用できるようになる更新プログラムの適用にかかわらず、技術的なご支援を Microsoft サポートからお届けすることはできません。自己責任の範疇でご利用ください。&lt;/p&gt;
&lt;p&gt;参考として、Android など他のクライアント対応状況は&lt;a href=&quot;https://learn.microsoft.com/ja-jp/security/engineering/solving-tls1-problem#appendix-a-handshake-simulation&quot;&gt;こちら&lt;/a&gt;の公開ドキュメントに開示されています。 &lt;/p&gt;
&lt;h3 id=&quot;Chrome-Edge-などのブラウザの場合&quot;&gt;&lt;a href=&quot;#Chrome-Edge-などのブラウザの場合&quot; class=&quot;headerlink&quot; title=&quot;Chrome/Edge などのブラウザの場合&quot;&gt;&lt;/a&gt;Chrome/Edge などのブラウザの場合&lt;/h3&gt;&lt;p&gt;最新バージョンの各ブラウザでは、基本的に TLS 1.2 以降のバージョンが有効化されているため、ご対応頂く必要はありませんが、&lt;br&gt;特定の TLS バージョンを有効化/無効化されたい場合は、各ブラウザ観点でご確認頂く必要がございます。&lt;br&gt;Edgeの場合は&lt;a href=&quot;https://learn.microsoft.com/en-us/answers/questions/487582/is-there-a-way-to-emable-tls-1-0-and-or-1-2-on-edg&quot;&gt;こちらの記事&lt;/a&gt;の通り対応できます。&lt;/p&gt;
&lt;h3 id=&quot;それ以外の場合&quot;&gt;&lt;a href=&quot;#それ以外の場合&quot; class=&quot;headerlink&quot; title=&quot;それ以外の場合&quot;&gt;&lt;/a&gt;それ以外の場合&lt;/h3&gt;&lt;p&gt;上記以外に、Java などプログラミング言語でお客様が開発したアプリケーションで Azure サービスへ接続する場合は、Windows OS の TLS レジストリ設定を参照せず、独自の設定通り接続する場合がありますので、お客様側にアプリケーション観点で TLS の通信バージョンご確認及びご対応頂く必要があります。&lt;/p&gt;
&lt;h3 id=&quot;TLS-チェッカー-ツール&quot;&gt;&lt;a href=&quot;#TLS-チェッカー-ツール&quot; class=&quot;headerlink&quot; title=&quot;TLS チェッカー ツール&quot;&gt;&lt;/a&gt;TLS チェッカー ツール&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://clienttest.ssllabs.com:8443/ssltest/viewMyClient.html&quot;&gt;こちら&lt;/a&gt;のような外部の TLS チェッカー ツールをご活用いただき、想定されるクライアントからアクセスをして TLS バージョンを確認いただくということも有効です。&lt;/p&gt;
&lt;h2 id=&quot;Azure-Network製品の対応状況及び推奨アクションについて&quot;&gt;&lt;a href=&quot;#Azure-Network製品の対応状況及び推奨アクションについて&quot; class=&quot;headerlink&quot; title=&quot;Azure Network製品の対応状況及び推奨アクションについて&quot;&gt;&lt;/a&gt;Azure Network製品の対応状況及び推奨アクションについて&lt;/h2&gt;&lt;p&gt;以下にて Azure Network 製品の対応状況、及びお客様に推奨なアクションをご紹介致します。&lt;br&gt;もしご確認されたい製品が入っていなく、個別にご確認されたい場合は、各製品に対してサポート リクエストを起票してください。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!WARNING]&lt;br&gt;以下各製品の部分に案内する対処目処はあくまで目途であり、実際には日程が多少前後する可能性があります。予めご了承ください。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Network" scheme="https://jpaztech.github.io/blog/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>設定変更不可の項目を VM 再作成により再設定する手順</title>
    <link href="https://jpaztech.github.io/blog/vm/recreate-vm-to-change-settings/"/>
    <id>https://jpaztech.github.io/blog/vm/recreate-vm-to-change-settings/</id>
    <published>2024-01-25T08:00:00.000Z</published>
    <updated>2024-02-16T07:05:26.498Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの藤澤です。 </p><p>Azure VM のいくつかの設定項目は、VM 作成後は変更いただくことが叶いませんが、OS / データディスクを保持したまま、VM を再作成いただくことで再作成時に変更することが可能でございます。<br>本記事では、通常変更不可である設定項目を、VM を再作成で変更する手順についてご案内します。 </p><span id="more"></span><hr><h2 id="■再作成が必要となるシナリオ一覧紹介"><a href="#■再作成が必要となるシナリオ一覧紹介" class="headerlink" title="■再作成が必要となるシナリオ一覧紹介"></a>■再作成が必要となるシナリオ一覧紹介</h2><p>以下の項目を変更したい場合、VM の再作成が必要となっております。 </p><ul><li>可用性ゾーンの変更 / 追加 / 削除 </li><li>可用性セットの変更 / 追加 / 削除 </li><li>Spot VM 設定の有効 / 無効 の変更 </li><li>一時ディスク有りの VM サイズから一時ディスク無しの VM へサイズ変更（また、その逆） </li><li>VM リソース名称の変更 </li><li>VM の接続先 VNet の変更</li></ul><hr><h2 id="ポータルで-VM-再作成を行う手順"><a href="#ポータルで-VM-再作成を行う手順" class="headerlink" title="ポータルで VM 再作成を行う手順"></a>ポータルで VM 再作成を行う手順</h2><p>それでは、実際に VM 再作成で各項目を変更するための手順について説明させていただきます。 </p><h3 id="1-必要事項を控える"><a href="#1-必要事項を控える" class="headerlink" title="1. 必要事項を控える"></a>1. 必要事項を控える</h3><p> まずは、VM 再作成時に再度同じ設定をするために Azure ポータルの対象 VM の画面を開き、赤枠の項目を控えます。<br> 多くの項目がございますが、代表的なものについて説明させていただきますので、以下の通り設定値を控えておきましょう。 </p><h4 id="a-概要メニュー"><a href="#a-概要メニュー" class="headerlink" title="a. 概要メニュー"></a>a. 概要メニュー</h4><ul><li>リソースグループ名 </li><li>場所 </li><li>サイズ </li><li>パブリック IP アドレス </li><li>仮想ネットワーク / サブネット </li><li>可用性とスケーリング </li></ul><p> <img src="/blog/vm/recreate-vm-to-change-settings/1.png"></p><h4 id="b-ネットワークメニュー"><a href="#b-ネットワークメニュー" class="headerlink" title="b. ネットワークメニュー"></a>b. ネットワークメニュー</h4><p> 元の NIC を用いるかどうかによって、以下の 2 パターンに分けられます。VM 再作成時は Azure Portal にて既存 NIC を指定できませんが、VM 再作成後に後から NIC を付け替えることが可能です。該当する方を控えてください。 </p><p> <strong>b-1. 元の NIC を用いて新しい仮想マシンを作成する場合</strong></p><ul><li>ネットワーク設定メニュー<ul><li>NIC名 (元のNICが複数ある場合はすべて控える)<br><img src="/blog/vm/recreate-vm-to-change-settings/2.png"></li></ul></li></ul><p> <strong>b-2. 新しい仮想マシンを作成する際に、元の NIC を使用しない場合</strong></p><ul><li><p>ネットワーク設定メニュー</p><ul><li>NIC に設定されている NSG 名<br><img src="/blog/vm/recreate-vm-to-change-settings/3.png"></li></ul></li><li><p>負荷分散メニュー</p><ul><li>負荷分散の設定<br><img src="/blog/vm/recreate-vm-to-change-settings/4.png"></li></ul></li><li><p>ディスクメニュー</p><ul><li>各ディスク名 </li><li>各ディスクのホストキャッシュ設定<br><img src="/blog/vm/recreate-vm-to-change-settings/6.png"></li></ul></li></ul><p>これで、再作成のための情報を控えることができました。</p><hr><h3 id="2-スナップショットからゾーン設定を変更したディスク作成（可用性ゾーンの設定変更のシナリオの場合のみ実施）"><a href="#2-スナップショットからゾーン設定を変更したディスク作成（可用性ゾーンの設定変更のシナリオの場合のみ実施）" class="headerlink" title="2.スナップショットからゾーン設定を変更したディスク作成（可用性ゾーンの設定変更のシナリオの場合のみ実施）"></a>2.スナップショットからゾーン設定を変更したディスク作成（可用性ゾーンの設定変更のシナリオの場合のみ実施）</h3><div class="alert is-info"><p class="alert-title">Note</p><p>この手順は<strong>以下のシナリオに該当する場合のみ</strong>実施をお願いいたします。</p><p>該当しない場合は、後述の「3. 元の仮想マシンを削除する」の手順に進んでください。</p></div><p> <strong>【該当シナリオ】</strong></p><ul><li>もともと可用性ゾーンを使っており、今回可用性ゾーンに関する設定変更を行う<ul><li>例：ゾーン番号の変更・可用性ゾーンから可用性セットへの切り替え・可用性ゾーンをやめる</li></ul></li><li>可用性ゾーンを使っていなかったが、今回可用性ゾーンを使用するように変更する</li></ul><p> 上記シナリオの場合は、そのゾーン設定に対応するディスクを作成する必要があります。<br> 理由としては、以下の例のように特定のゾーン対応に存在しないディスクから、そのゾーン以外の VM を作成しようとすると、以下のような警告メッセージが表示され、VM 再作成ができないからとなります。 </p><p> <img src="/blog/vm/recreate-vm-to-change-settings/7.png"></p><h3 id="2-1-元の仮想マシンの-OS-ディスクのスナップショットを取る"><a href="#2-1-元の仮想マシンの-OS-ディスクのスナップショットを取る" class="headerlink" title="2-1. 元の仮想マシンの OS ディスクのスナップショットを取る"></a>2-1. 元の仮想マシンの OS ディスクのスナップショットを取る</h3><p>  a. Azure ポータルより [Virtual Machines] - [&lt;当該 VM 名&gt;] を開きます。 </p><p>  b. 左メニュー “設定” より [ディスク] を選択し、開いた画面 “OS ディスク” より [&lt;当該 OS ディスク名&gt;] をクリックします。</p><p>  <img src="/blog/vm/recreate-vm-to-change-settings/5.png"></p><p>  c. 画面の [+ スナップショットの作成] をクリックします。</p><p>  <img src="/blog/vm/recreate-vm-to-change-settings/8.png"></p><p>  d. 必要項目を適宜入力し、[確認および作成] - [作成] をクリックします。<br>  [ストレージの種類] は、スナップショットを高パフォーマンスのディスクに保存する必要がある場合を除き、 [Standard HDD(ローカル冗長ストレージ)] を選択します。 </p><p>  <img src="/blog/vm/recreate-vm-to-change-settings/9.png"></p><p>  e. データディスクがある場合、データディスクについても同様にスナップショットを作成します。 </p><p>  <img src="/blog/vm/recreate-vm-to-change-settings/10.png"></p><h3 id="2-2-スナップショットからディスクを作成する際に可用性ゾーン-可用性セットを変更する"><a href="#2-2-スナップショットからディスクを作成する際に可用性ゾーン-可用性セットを変更する" class="headerlink" title="2-2. スナップショットからディスクを作成する際に可用性ゾーン/可用性セットを変更する"></a>2-2. スナップショットからディスクを作成する際に可用性ゾーン/可用性セットを変更する</h3><p>  a. Azure ポータル 上部の検索バーに “スナップショット” と入力し、サービス [スナップショット] を選択します。<br>  上記手順で作成した OS ディスクおよび、データ ディスクのスナップショットが作成されていることを確認します。 </p><p>  <img src="/blog/vm/recreate-vm-to-change-settings/11.png"></p><p>  b. 対象ディスクのスナップショットを選択し、[+ ディスクの作成] をクリックします </p><p>  <img src="/blog/vm/recreate-vm-to-change-settings/12.png"></p><p>  c. 必要項目を適宜入力し、[確認および作成] - [作成] をクリックします。<br>  特定の可用性ゾーンに所属させたい場合は、以下のように可用性ゾーン番号をご指定ください。<br>  それ以外の場合は [インフラストラクチャ冗長は必要ありません] を選択します。 </p><p>  <img src="/blog/vm/recreate-vm-to-change-settings/13.png"></p><p>これにより、特定のゾーンに所属するディスク（もしくは、ゾーン設定の無いディスク）を用意することが出来ました。<br>この作成したディスク名は VM 再作成時に使用しますので、控えておいてください。 </p><hr><h3 id="3-元の仮想マシンを削除する"><a href="#3-元の仮想マシンを削除する" class="headerlink" title="3. 元の仮想マシンを削除する"></a>3. 元の仮想マシンを削除する</h3><p> 元の仮想マシンを削除します。 </p><p> なお、この際にディスク等のリソースは残しますので、データが消失するものでは無い点はご安心ください。<br> 一時ディスクの内容は破棄されます点はご承知おきくださいませ。</p><p> a. 対象の仮想マシンの概要上部にある「削除」をクリック<br> <img src="/blog/vm/recreate-vm-to-change-settings/14.png"></p><p> b. 以下赤枠内にチェックを入れないように気を付けて削除してください<br> <img src="/blog/vm/recreate-vm-to-change-settings/15.png"></p><p>これでディスクを残したまま、仮想マシンのリソースを削除できました。 </p><hr><h3 id="4-元の仮想マシンの-OS-ディスクから新規仮想マシンを作成する際に変更したい項目を変更する"><a href="#4-元の仮想マシンの-OS-ディスクから新規仮想マシンを作成する際に変更したい項目を変更する" class="headerlink" title="4. 元の仮想マシンの OS ディスクから新規仮想マシンを作成する際に変更したい項目を変更する"></a>4. 元の仮想マシンの OS ディスクから新規仮想マシンを作成する際に変更したい項目を変更する</h3><p>残されたディスクから VM を再作成します。<br>VM 再作成時にお好みの設定に変更が可能となっております。 </p><p> a. Azure ポータルより削除した VM で使用していた OS ディスク (控えていた OS ディスク名を参照) の画面を開きます。<br> なお、ゾーンに関する設定変更を行う場合は <strong>「2.スナップショットからゾーン設定を変更したディスク作成（可用性ゾーンの設定変更のシナリオの場合のみ実施）」</strong> の手順で作成したディスクをかわりに選択します。</p><p> b. [VM の作成] をクリックします。 </p><p> <img src="/blog/vm/recreate-vm-to-change-settings/16.png"></p><p> c. 手順 <strong>「1. 必要事項を控える」</strong> にて控えていた内容をもとに VM の設定項目を入力していきます。<br> この際、変更を行いたい項目をご変更くださいませ。 </p><ul><li><p>リソース名を変更したい場合 </p><p><img src="/blog/vm/recreate-vm-to-change-settings/17.png"></p></li><li><p>データディスクを追加したい場合 </p><p>元の仮想マシンのデータディスクを追加したい場合は、[既存のディスクの接続] より追加します。 </p><p><img src="/blog/vm/recreate-vm-to-change-settings/18.png"></p><p><img src="/blog/vm/recreate-vm-to-change-settings/19.png"></p></li><li><p>新しい仮想マシンで可用性セットを使用したい場合</p><p> [可用性オプション] にて [可用性セット] を選択し、[可用性セット] の項目にてご希望の障害ドメイン、更新ドメイン数を入力ください。 </p><p> <img src="/blog/vm/recreate-vm-to-change-settings/20.png"></p></li><li><p>新しい仮想マシンで可用性ゾーンを使用したい場合 </p><p> [可用性オプション]の項目で[可用性ゾーン] を選択し、[可用性ゾーン] の項目では、スナップショットからディスクを作成する際に指定したゾーン番号を選択します。  </p><p> <img src="/blog/vm/recreate-vm-to-change-settings/21.png"></p></li><li><p>Azure Spot 割引を変更したい場合 </p><p> <img src="/blog/vm/recreate-vm-to-change-settings/22.png"></p></li><li><p> 接続先 VNET を変更したい場合 </p></li></ul><p>   <img src="/blog/vm/recreate-vm-to-change-settings/23.png"></p><div class="alert is-info"><p class="alert-title">Note</p><p>ネットワークについて、既存の NIC 接続は VM 作成後に行いますので、既存 NIC を使用する場合、この段階での “NIC ネットワーク セキュリティ グループ” の設定は不要です。</p><p>新規の NIC を使用する場合は、リージョンの変更が無い場合、元と同じ NSG を選択することも可能です。  </p></div><p> d.全ての設定が完了後、 [確認および作成] から[作成] をクリックします。  </p><p> <img src="/blog/vm/recreate-vm-to-change-settings/24.png"></p><hr><h3 id="オプション：-NIC-の付け替え"><a href="#オプション：-NIC-の付け替え" class="headerlink" title="オプション： NIC の付け替え"></a>オプション： NIC の付け替え</h3><p>  Azure ポータルより VM 作成をする際には既存 NIC を指定できませんが、 VM 再作成後に後から NIC を付け替えることが可能です。</p><p>  a. 仮想マシンを作成後、既存の NIC を接続するため、VM を停止 (割り当て解除) します。</p><p>  b. VM 停止 (割り当て解除) 後、VM のページから [ネットワーク] - ネットワーク設定 - [ネットワーク インターフェイスのアタッチ] を選択し、削除した VM で使用していた NIC を接続します。 </p><p>  <img src="/blog/vm/recreate-vm-to-change-settings/26.png"></p><p>  <img src="/blog/vm/recreate-vm-to-change-settings/27.png"></p><p>  c. 既存の NIC の接続完了後も、VM 作成時に作成された NIC がまだプライマリとなっている状態なので、[ネットワーク インターフェイスのデタッチ] を選択し、その NIC をデタッチします。 </p><p>  <img src="/blog/vm/recreate-vm-to-change-settings/28.png"></p><p>  <img src="/blog/vm/recreate-vm-to-change-settings/29.png"></p><p>  NIC のデタッチを実施後、セカンダリとして接続した既存 NIC は自動的にプライマリとなります。<br>  なお、デタッチした NIC については削除されても問題ありません。 </p><p>  d. VM を起動します。 </p><hr><p>手順は以上となります。本記事が皆様のお役に立ちましたら幸いです。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの藤澤です。 &lt;/p&gt;
&lt;p&gt;Azure VM のいくつかの設定項目は、VM 作成後は変更いただくことが叶いませんが、OS / データディスクを保持したまま、VM を再作成いただくことで再作成時に変更することが可能でございます。&lt;br&gt;本記事では、通常変更不可である設定項目を、VM を再作成で変更する手順についてご案内します。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
  </entry>
  
  <entry>
    <title>お問い合わせにてパスワード等の機密情報を記載しないようにお願いいたします</title>
    <link href="https://jpaztech.github.io/blog/information/do-not-provide-sensitive-data/"/>
    <id>https://jpaztech.github.io/blog/information/do-not-provide-sensitive-data/</id>
    <published>2024-01-25T03:00:00.000Z</published>
    <updated>2024-02-16T07:05:26.182Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームです。<br>Azure テクニカル サポート チームではお客様から頂いた情報は厳重に管理をしております。<br>しかしながら、お客様のセキュリティを守るためにも、お問い合わせにてパスワード等の機密情報を記載しないように注意喚起のご案内をさせていただきたく存じます。</p><hr><h2 id="お問い合わせにて機密情報を記載しないようにお願いいたします"><a href="#お問い合わせにて機密情報を記載しないようにお願いいたします" class="headerlink" title="お問い合わせにて機密情報を記載しないようにお願いいたします"></a>お問い合わせにて機密情報を記載しないようにお願いいたします</h2><p>幣 Azure テクニカル サポート チームにお問い合わせをいただく際に、パスワード等の機密情報を記載されてしまっているというケースが発生しております。<br>恐れ入りますが、機密情報はお客様自身で適切に管理いただき、お問い合わせにてお客様の機密情報を記載をしないようにお願い申し上げます。  </p><p>これはお問い合わせ起票時以外にも、以下のようなお問い合わせ最中のやり取りも含めてのお願いとなります点、ご理解頂けますと幸いでございます。  </p><ul><li>お問い合わせ起票時の本文内への記載</li><li>お問い合わせ起票時にアップロードいただいたファイル内での記載</li><li>弊社とのメールやり取りでの本文内への記載</li><li>弊社とのメールやり取りでの添付ファイルでの記載</li><li>お問い合わせ後にアップロードいただいたファイル内での記載</li><li>電話での口頭でのやり取り</li></ul><p>加えて、テキストベースのファイル以外にもスクリーンショットなどの画像についても機密情報が含まれないようにご注意くださいませ。</p><hr><h2 id="記載してはいけない機密情報の例"><a href="#記載してはいけない機密情報の例" class="headerlink" title="記載してはいけない機密情報の例"></a>記載してはいけない機密情報の例</h2><p>以下の例のような機密情報は、お問い合わせに記載をしないようにお願い申し上げます。  </p><ul><li>OS ユーザー / Azure ユーザー等のパスワード</li><li>Azure ストレージアカウントのアクセスキー</li><li>有効な Azure ストレージアカウントの SAS キー</li><li>秘密鍵</li><li>クレジットカード番号</li></ul><p>もしこれらの情報が含まれる場合は、当該箇所をマスクしていただくようにお願い申し上げます。<br>以下はパスワードや Azure ストレージアカウントのアクセスキーおよび SAS キーについてマスクする一例となります。</p><h3 id="パスワードが入ったコマンドについてお問い合わせする場合"><a href="#パスワードが入ったコマンドについてお問い合わせする場合" class="headerlink" title="パスワードが入ったコマンドについてお問い合わせする場合"></a>パスワードが入ったコマンドについてお問い合わせする場合</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- password P@ssw0rd!</span><br><span class="line">　   ↓</span><br><span class="line">-- password &lt;●●●機密情報のためパスワードはマスクします●●●&gt;</span><br></pre></td></tr></table></figure><h3 id="Azure-ポータルから取得した-Azure-Files-への接続スクリプトについてお問い合わせする場合の例（アクセスキーをマスク）"><a href="#Azure-ポータルから取得した-Azure-Files-への接続スクリプトについてお問い合わせする場合の例（アクセスキーをマスク）" class="headerlink" title="Azure ポータルから取得した Azure Files への接続スクリプトについてお問い合わせする場合の例（アクセスキーをマスク）"></a>Azure ポータルから取得した Azure Files への接続スクリプトについてお問い合わせする場合の例（アクセスキーをマスク）</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$connectTestResult</span> = <span class="built_in">Test-NetConnection</span> <span class="literal">-ComputerName</span> <span class="built_in">test-storage</span><span class="literal">-account</span>.file.core.windows.net <span class="literal">-Port</span> <span class="number">445</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$connectTestResult</span>.TcpTestSucceeded) &#123;</span><br><span class="line">    <span class="comment"># 再起動時にドライブが維持されるように、パスワードを保存する</span></span><br><span class="line">    cmd.exe /C <span class="string">&quot;cmdkey /add:`&quot;test-storage-account.file.core.windows.net`&quot; /user:`&quot;localhost\test-storage-account`&quot; /pass:`&quot;&lt;●●●ストレージアカウントのアクセスキーなのでマスクします●●●&gt;`&quot;&quot;</span></span><br><span class="line">    <span class="comment"># ドライブをマウントする</span></span><br><span class="line">    <span class="built_in">New-PSDrive</span> <span class="literal">-Name</span> Z <span class="literal">-PSProvider</span> FileSystem <span class="literal">-Root</span> <span class="string">&quot;\\test-storage-account.file.core.windows.net\test&quot;</span> <span class="literal">-Persist</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">Write-Error</span> <span class="literal">-Message</span> <span class="string">&quot;Unable to reach the Azure storage account via port 445. Check to make sure your organization or ISP is not blocking port 445, or use Azure P2S VPN, Azure S2S VPN, or Express Route to tunnel SMB traffic over a different port.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SAS-キーを用いたストレージアカウントの-Blob-コンテナへのアクセスについてお問い合わせする際の例（SAS-キーをマスク）"><a href="#SAS-キーを用いたストレージアカウントの-Blob-コンテナへのアクセスについてお問い合わせする際の例（SAS-キーをマスク）" class="headerlink" title="SAS キーを用いたストレージアカウントの Blob コンテナへのアクセスについてお問い合わせする際の例（SAS キーをマスク）"></a>SAS キーを用いたストレージアカウントの Blob コンテナへのアクセスについてお問い合わせする際の例（SAS キーをマスク）</h3><p><code>https://test-storage-account.blob.core.windows.net/container?sv=2022-11-02&amp;ss=bfqt&amp;srt=sco&amp;sp=rwdlacupiytfx&amp;se=2023-12-29T12:05:45Z&amp;st=2023-12-29T04:05:45Z&amp;spr=https&amp;sig=&lt;●●●ストレージアカウントの SAS キーなのでマスクします●●●&gt;</code></p><div class="alert is-success"><p class="alert-title">ヒント</p><p>Azure ストレージアカウントのアクセスキーについてご懸念がございます場合は、以下の公開ドキュメントの通りローテーションを行うことが可能です。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/storage/common/storage-account-keys-manage#manually-rotate-access-keys">https://learn.microsoft.com/ja-jp/azure/storage/common/storage-account-keys-manage#manually-rotate-access-keys</a></p></div><hr><h2 id="機密情報をお問い合わせで記載してしまった場合"><a href="#機密情報をお問い合わせで記載してしまった場合" class="headerlink" title="機密情報をお問い合わせで記載してしまった場合"></a>機密情報をお問い合わせで記載してしまった場合</h2><p>もし、お客様側より上記のような機密情報を記載されてしまった際は、弊社よりお客様へご連絡の上、弊社およびお客様側で当該情報の削除の対応や、場合によっては新規のお問い合わせ発行をお願いさせていただくといったお手間をおかけする可能性があります。<br>そのため、サポート着手までお時間をいただく可能性がございます。<br>迅速なサポートのご提供およびお客様のセキュリティのためにも、機密情報の記載をしないようにご協力をお願い申し上げます。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームです。&lt;br&gt;Azure テクニカル サポート チームではお客様から頂いた情報は厳重に管理をしております。&lt;br&gt;しかしながら、お客様のセキュリティを守るためにも、お問い合わせにてパスワード等の機密情報を記載しないように注</summary>
      
    
    
    
    
    <category term="Information" scheme="https://jpaztech.github.io/blog/tags/Information/"/>
    
  </entry>
  
  <entry>
    <title>Azure Firewall の SKU をダウングレードする方法</title>
    <link href="https://jpaztech.github.io/blog/network/fw_sku_downgrade/"/>
    <id>https://jpaztech.github.io/blog/network/fw_sku_downgrade/</id>
    <published>2024-01-24T05:30:00.000Z</published>
    <updated>2024-02-16T07:05:26.202Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの薄井です。<br>今回は Azure Firewall の SKU を Premium から Standard にダウングレードする方法ついて紹介します。</p><span id="more"></span><p>Azure Firewall のイージー アップグレード/ダウングレード 機能の導入により、Standard と Premiume の SKU アップグレード/ダウングレードが容易に行えるようになりました。<br>しかしながら、Premium から Standard へのダウングレードに当たっては、Firewall Policy の ポリシー レベルを Premium から Standard へ変更することができません。<br>そのため、Azure Firewall の SKU を変更する前に Firewall Policy を Standard で再作成する必要があります。<br>Azure Firewall の SKU を Premium から Standard にダウングレードする手順は以下の通りとなります。</p><h2 id="Azure-Firewall-の-SKU-変更手順"><a href="#Azure-Firewall-の-SKU-変更手順" class="headerlink" title="Azure Firewall の SKU 変更手順"></a>Azure Firewall の SKU 変更手順</h2><ol><li>Firewall Policy を Standard で作成します。</li><li>対象の Azure Firewall の [概要] をクリックし、Firewall policy の [change] をクリックします。</li><li>1 で作成した Firewall policy をチェックし、下部の [保存] をクリックします。</li><li>対象の Azure Firewall の [概要] をクリックし、上記の [SKU の変更] をクリックします。</li><li>ファイアウォール SKU の Standard をクリックします。</li><li>“ファイアウォール ポリシーを選択してください” の箇所が、3 で保存した Firewall policy であることを確認します。</li><li>下部の [Downgrade] をクリックします。</li></ol><p>なお、Azure Firewall の SKU を Premium から Standard にダウングレードできるのは、Firewall Policy を使用している場合のみとなります。<br>ファイアウォール規則 (クラシック) を使用して Azure Firewall を管理することができないため、この点ご留意いただけますと幸いです。</p><p>また、ダウングレードした際のダウンタイムにつきましては、明確なダウンタイムはご案内することが困難ですが、15 ～ 20 分程度の時間がかかることを確認しております。<br>そのため、ダウングレードする際は、影響がない時間帯で実施いただければと存じます。</p><h2 id="参考情報"><a href="#参考情報" class="headerlink" title="参考情報"></a>参考情報</h2><p>Azure Firewall の SKU 変更ついては以下にも記載がありますのでご一読ください。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/firewall/easy-upgrade">Azure Firewall イージー アップグレード/ダウングレード</a></p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの薄井です。&lt;br&gt;今回は Azure Firewall の SKU を Premium から Standard にダウングレードする方法ついて紹介します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Network" scheme="https://jpaztech.github.io/blog/tags/Network/"/>
    
    <category term="Azure Firewall" scheme="https://jpaztech.github.io/blog/tags/Azure-Firewall/"/>
    
  </entry>
  
  <entry>
    <title>ExpressRoute 回線に対するマイクロソフト側エッジルーターにおけるレート制限に関する補足</title>
    <link href="https://jpaztech.github.io/blog/network/expressroute_MV1F-T9G/"/>
    <id>https://jpaztech.github.io/blog/network/expressroute_MV1F-T9G/</id>
    <published>2024-01-16T15:00:00.000Z</published>
    <updated>2024-02-16T07:05:26.198Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームです。 2024 年 1 月 17 日に ExpressRoute の使用に関するアナウンス Tracking ID MV1F-T9G (タイトル : We have important information for your ExpressRoute service ) が ExpressRoute をご利用中のお客様に送付されました。<br>アナウンスされた内容は英語でのご案内であるため、この記事にて補足させていただきます。  </p><span id="more"></span><hr><h2 id="ExpressRoute-回線に対するお客様による回線帯域幅の設定と、マイクロソフトによる流量制御の実施"><a href="#ExpressRoute-回線に対するお客様による回線帯域幅の設定と、マイクロソフトによる流量制御の実施" class="headerlink" title="ExpressRoute 回線に対するお客様による回線帯域幅の設定と、マイクロソフトによる流量制御の実施"></a>ExpressRoute 回線に対するお客様による回線帯域幅の設定と、マイクロソフトによる流量制御の実施</h2><p>この度の通知以前から、お客様が ExpressRoute 回線リソースをご作成される際には 50 Mbps から 10 Gbps の間で回線帯域幅をご選択いただいております。この回線帯域幅は作成後にお客様にて増速することが可能です。この回線帯域幅はマイクロソフト側エッジルーターの割り当て済み帯域幅の計算に利用されております。<br><br>2024 年 1 月 17 日 の Tracking ID MV1F-T9G (タイトル : We have important information for your ExpressRoute service ) の通知は、すべてのお客様がご契約済みの回線帯域幅をより公平にご利用いただくために、ExpressRoute 回線のマイクロソフト側エッジルーターにおいて流量制御を今後実施する旨をご案内しております。<br><br><br></p><h2 id="マイクロソフトによる流量制御の有効化時期と、お客様において必要な作業"><a href="#マイクロソフトによる流量制御の有効化時期と、お客様において必要な作業" class="headerlink" title="マイクロソフトによる流量制御の有効化時期と、お客様において必要な作業"></a>マイクロソフトによる流量制御の有効化時期と、お客様において必要な作業</h2><p>2024 年 2 月 15 日から 6 月 30 日の間にかけて、Azure における標準的な変更管理プロセス(※)に則って、順次マイクロソフト側エッジルーターにおけるレート制限は有効化されます。</p><p>(※) <a href="https://azure.microsoft.com/en-us/blog/advancing-safe-deployment-practices/">Advancing safe deployment practices | Microsoft Azure Blog</a>  </p><p>マイクロソフト側エッジルーターにおけるレート制限に際して、ほとんどのお客様において構成変更作業は発生いたしません。<br>この流量制御の影響を受けるのは、お客様にてご選択済みの ExpressRoute 回線帯域幅を超える帯域幅をご利用になっているお客様のみであるためです。  </p><p>ご利用中の回線において実際に利用している帯域幅が、お客様にてご選択済みの ExpressRoute 回線帯域幅を下回っていることを確認するには、ExpressRoute 回線のメトリックをご利用ください。  </p><p>（参考ドキュメント）<br><a href="https://learn.microsoft.com/ja-jp/azure/expressroute/expressroute-monitoring-metrics-alerts#bits-in-and-out---metrics-per-peering">Azure ExpressRoute： 監視、メトリック、およびアラート | Microsoft Learn</a><br>ビットのインとアウト - ピアリングごとのメトリック  </p><p>ご利用中の回線において実際に利用している帯域幅が、お客様にてご選択済みの ExpressRoute 回線帯域幅を上回っている場合、ご選択いただいた回線帯域幅の増速をご検討ください。<br>ExpressRoute 回線帯域幅の増速にあたっては、お客様と ExpressRoute プロバイダー様の間でご契約いただいている回線帯域幅についても過不足がないかをご確認ください。<br><br></p><h2 id="エッジルーターのレート制限に関わる-FAQ"><a href="#エッジルーターのレート制限に関わる-FAQ" class="headerlink" title="エッジルーターのレート制限に関わる FAQ"></a>エッジルーターのレート制限に関わる FAQ</h2><ul><li>Q: 流量制御機能が動作した場合、私の ExpressRoute 回線にどのような影響がありますか？<br></li><li>A: まず、ExpressRoute 回線の帯域幅を 50 Mbps とご選択いただいた場合、プライマリ回線とセカンダリ回線の両系統がそれぞれ 50 Mbps ご利用可能です。これは片系統のメンテナンスや障害が発生した場合でも、ご選択いただいた 50 Mbps が利用可能であり続けることを目的に構成されています。 <br><br>この度有効となる流量制御は、各回線ごとに 50 Mbps を上回った場合に、パケットが破棄されるように動作します。<br>なお、レート制限の有効後も、両系統をアクティブ/アクティブ構成で均等にご使用されている場合に限れば、理論上は同回線で 2 倍の最大 100 Mbps まで一時的に「バースト」して利用いただけます。<br>ただし、アクティブ/アクティブ構成の場合もメンテナンスや障害等で一時的に片系統が利用できない場合も考えられ、その場合の最大値は 50 Mbps となりますのでご注意いただければと存じます。<br><br></li><li>Q: なぜ流量制御を実施するのですか？<br></li><li>A: ごく一部のお客様において、ご選択いただいた回線帯域幅を上回る帯域の利用が恒常化しているためです。すべてのお客様が公平に帯域幅をご利用いただき続けるために、マイクロソフト側エッジルーターにおける流量制御を有効化することになりました。<br><br></li><li>Q: どのようにして ExpressRoute 回線帯域幅を増速することができますか？<br></li><li>A: Azure Portal より ExpressRoute 回線リソースの「構成」をご選択いただき、増速後の「帯域幅」をプルダウンからご選択のうえ、設定を「保存」してください。  <br></li></ul><p>（参考ドキュメント）<br><a href="https://learn.microsoft.com/ja-jp/azure/expressroute/expressroute-howto-circuit-portal-resource-manager#modify">クイックスタート： ExpressRoute を使った回線の作成と変更 - Azure portal | Microsoft Learn</a><br>ExpressRoute 回線の変更  </p><ul><li>Q: 増速時にはどのくらいの時間が必要ですか？増速時に通信断は発生しますか？<br></li><li>A: 増速に伴う設定変更は数秒で完了します。この間にお客様の通信の切断は想定されていませんが、設定変更に伴う不測の事態の影響を回避するためにも、慎重を期してお客様のシステムのメンテナンス時間帯に増速することを推奨いたします。<br><br></li><li>Q: ExpressRoute 回線帯域幅を増速したあと、元の帯域幅に戻したくなった場合には同様の操作で戻せますか？<br></li><li>A: いいえ、帯域幅の減速には ExpressRoute 回線リソースの削除と再作成が必要となります。増速時と同様の操作で減速することはできません。また、ExpressRoute 回線リソースの削除から再作成までの間は ExpressRoute 回線経由の通信ができないため、お客様のシステムにおいて通信断が発生します。<br><br><br>本ブログが皆様のお役に立てれば幸いです。  </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームです。 2024 年 1 月 17 日に ExpressRoute の使用に関するアナウンス Tracking ID MV1F-T9G (タイトル : We have important information for your ExpressRoute service ) が ExpressRoute をご利用中のお客様に送付されました。&lt;br&gt;アナウンスされた内容は英語でのご案内であるため、この記事にて補足させていただきます。  &lt;/p&gt;</summary>
    
    
    
    
    <category term="Network" scheme="https://jpaztech.github.io/blog/tags/Network/"/>
    
    <category term="ExpressRoute" scheme="https://jpaztech.github.io/blog/tags/ExpressRoute/"/>
    
    <category term="FAQ" scheme="https://jpaztech.github.io/blog/tags/FAQ/"/>
    
  </entry>
  
  <entry>
    <title>特定の操作における Azure カスタム ロールの作成について</title>
    <link href="https://jpaztech.github.io/blog/vm/create-custom-roles/"/>
    <id>https://jpaztech.github.io/blog/vm/create-custom-roles/</id>
    <published>2024-01-16T01:00:00.000Z</published>
    <updated>2024-02-16T07:05:26.310Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの木下です。<br>今回は特定の操作における Azure カスタム ロールの作成手順をご紹介いたします。 </p><ul><li>1.Azure カスタム ロールについて</li><li>2.カスタム ロールを作成する</li><li>3.補足情報 - ブラウザー トレースにて必要となるリソース プロバイダー操作を把握する</li><li>4.ご留意点</li></ul><h2 id="1-Azure-カスタム-ロールについて"><a href="#1-Azure-カスタム-ロールについて" class="headerlink" title="1.Azure カスタム ロールについて"></a>1.Azure カスタム ロールについて</h2><p>Azure では、ロール ベース アクセス制御 (RBAC) という機能を使用し、アクセスできるリソースを制限したり、リソースへの操作を制限したりすることが可能です。<br>Azure には既定で各リソース操作（アクション）の許可をまとめた組み込みロールのご用意がありますが、Azure 組み込みロールがお客様のご要件を満たさない場合は、独自の Azure カスタム ロールを作成することができます。 </p><p>参考）Azure 組み込みロール<br><a href="https://learn.microsoft.com/ja-jp/azure/role-based-access-control/built-in-roles">https://learn.microsoft.com/ja-jp/azure/role-based-access-control/built-in-roles</a> </p><blockquote><p>(抜粋)<br>Azure ロールベースのアクセス制御 (Azure RBAC) には、ユーザー、グループ、サービス プリンシパル、マネージド ID に割り当てることのできる Azure 組み込みロールがいくつかあります。 ロールの割り当ては、Azure リソースへのアクセスを制御する方法です。 組み込みロールが組織の特定のニーズを満たさない場合は、独自の Azure カスタム ロールを作成することができます。 ロールの割り当て方法については、「Azure ロールを割り当てる手順」を参照してください。 </p></blockquote><p>上記のドキュメントにて各組み込みロールで、実際にどのアクションが許可されているのかも確認が可能です。 </p><p>ただし、リソースへの操作に対して最低限必要となるアクションの組み合わせについては、公開ドキュメントに明記されていないこともございますので、お客様のご要件に合わせてトライ アンド エラーしながら最終的に必要となるアクションを確認し、カスタム ロールを作成いただくこととなります。<br>また、Azure サポート窓口にて、カスタム ロールの作成の代行は叶いません点あらかじめご了承ください。</p><h2 id="2-カスタム-ロールを作成する"><a href="#2-カスタム-ロールを作成する" class="headerlink" title="2.カスタム ロールを作成する"></a>2.カスタム ロールを作成する</h2><p>ここでは、Azure Portal から仮想マシンのディスクのスナップショットを取得するという操作を例に、当該操作を許可するためのアクションを確認し、カスタム ロールを作成していきます。<br>なお、他のどのような操作におきましても必要最小限のアクションのみが許可されたカスタム ロールを作成いただく場合、基本的には以下例のようにトライ アンド エラーを繰り返しながらカスタム ロールを作成いただくこととなります。</p><h3 id="手順-1-「Azure-リソース-プロバイダーの操作」より使用可能なアクセスアクションを検索し、カスタム-ロールに含めるアクセスアクションを探します。"><a href="#手順-1-「Azure-リソース-プロバイダーの操作」より使用可能なアクセスアクションを検索し、カスタム-ロールに含めるアクセスアクションを探します。" class="headerlink" title="手順 1.「Azure リソース プロバイダーの操作」より使用可能なアクセスアクションを検索し、カスタム ロールに含めるアクセスアクションを探します。"></a>手順 1.「Azure リソース プロバイダーの操作」より使用可能なアクセスアクションを検索し、カスタム ロールに含めるアクセスアクションを探します。</h3><p>Microsoft.Compute のリソース プロバイダーに対する操作となるため、Microsoft.Compute の項目を確認します。 </p><p>参考）Azure リソース プロバイダーの操作<br><a href="https://learn.microsoft.com/ja-jp/azure/role-based-access-control/resource-provider-operations">https://learn.microsoft.com/ja-jp/azure/role-based-access-control/resource-provider-operations</a> </p><p><img src="/blog/vm/create-custom-roles/01.png"></p><p>スナップショットの作成には ‘Microsoft.Compute/snapshots/write’ のアクションが必要となることを確認します。 </p><p><img src="/blog/vm/create-custom-roles/02.png"></p><p>必要となるアクションについては、既に権限のあるユーザーで実際の操作を行った際に記録されるアクティビティ ログの action 項目をご確認いただくことも有用です。 </p><p><img src="/blog/vm/create-custom-roles/03.png"></p><h3 id="手順-2-カスタム-ロールを作成します。"><a href="#手順-2-カスタム-ロールを作成します。" class="headerlink" title="手順 2.カスタム ロールを作成します。"></a>手順 2.カスタム ロールを作成します。</h3><p>手順 1 で確認した ‘Microsoft.Compute/snapshots/write’ アクションのみを許可したカスタム ロールを作成します。 </p><p><img src="/blog/vm/create-custom-roles/04.png"></p><p><img src="/blog/vm/create-custom-roles/05.png"></p><p>[JSON] タブを選択すると  ‘Microsoft.Compute/snapshots/write’ アクションのみが割り当たっていることを確認することができます。 </p><p> <img src="/blog/vm/create-custom-roles/06.png"></p><p>特定のユーザー testuser01 に当該カスタム ロールを割り当てます。 </p><p><img src="/blog/vm/create-custom-roles/07.png"></p><p>カスタム ロールの作成手順の詳細については、以下のブログ記事や公開ドキュメントをご参照ください。 </p><p>参考）カスタムロールを作成する手順<br><a href="https://jpaztech.github.io/blog/vm/rbac-vm-start-stop-restart/#%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%A0%E3%83%AD%E3%83%BC%E3%83%AB%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B%E6%89%8B%E9%A0%86">https://jpaztech.github.io/blog/vm/rbac-vm-start-stop-restart/#%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%A0%E3%83%AD%E3%83%BC%E3%83%AB%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B%E6%89%8B%E9%A0%86</a><br>参考）Azure portal を使用して Azure カスタム ロールを作成または更新する<br><a href="https://learn.microsoft.com/ja-jp/azure/role-based-access-control/custom-roles-portal">https://learn.microsoft.com/ja-jp/azure/role-based-access-control/custom-roles-portal</a><br>参考）カスタム ロールの作成手順<br><a href="https://learn.microsoft.com/ja-jp/azure/role-based-access-control/custom-roles">https://learn.microsoft.com/ja-jp/azure/role-based-access-control/custom-roles</a> </p><h3 id="手順-3-動作確認をします。"><a href="#手順-3-動作確認をします。" class="headerlink" title="手順 3.動作確認をします。"></a>手順 3.動作確認をします。</h3><p>ユーザー testuser01 で Azure Portal へサインインし、[Virtual Machines] の一覧ページへ遷移します。<br>仮想マシンが表示されていません。 </p><p><img src="/blog/vm/create-custom-roles/08.png"></p><p>これは、ユーザー testuser01 に対して [閲覧者] ロールが割り当てられていないためとなります。 </p><h3 id="手順-4-割り当てられているロールを修正します。"><a href="#手順-4-割り当てられているロールを修正します。" class="headerlink" title="手順 4. 割り当てられているロールを修正します。"></a>手順 4. 割り当てられているロールを修正します。</h3><p>リソースにアクセスできるよう ユーザー testuser01 に対して [閲覧者] ロールを割り当てます。 </p><p><img src="/blog/vm/create-custom-roles/09.png"></p><p>仮想マシンの閲覧が可能となりました。 </p><p><img src="/blog/vm/create-custom-roles/10.png"></p><h3 id="手順-5-OS-ディスクのスナップショットを作成します。"><a href="#手順-5-OS-ディスクのスナップショットを作成します。" class="headerlink" title="手順 5.OS ディスクのスナップショットを作成します。"></a>手順 5.OS ディスクのスナップショットを作成します。</h3><p>OS ディスクのスナップショットを取得するため、対象となる OS ディスク名をクリックし、[+ スナップショットの作成] へ進みます。 </p><p><img src="/blog/vm/create-custom-roles/11.png"></p><h3 id="手順-6-動作確認を行いながら、トライ-アンド-エラーを繰り返します。"><a href="#手順-6-動作確認を行いながら、トライ-アンド-エラーを繰り返します。" class="headerlink" title="手順 6. 動作確認を行いながら、トライ アンド エラーを繰り返します。"></a>手順 6. 動作確認を行いながら、トライ アンド エラーを繰り返します。</h3><p>スナップショット作成のための必要事項を編集し、作成を行うと以下のエラーが出力されました。 </p><p><img src="/blog/vm/create-custom-roles/12.png"></p><blockquote><p>{“code”:”AuthorizationFailed”,”message”:”オブジェクト ID が ‘XXX’ のクライアント ‘testuser01@XXX’ には、スコープ ‘/subscriptions/XXXXXX/resourceGroups/rg_test/providers/Microsoft.Resources/deployments/Snapshot.snapshot01-20240103123034’ でアクション ‘Microsoft.Resources/deployments/validate/action’ を実行する認可がないか、スコープが無効です。アクセスが最近許可された場合は、資格情報を更新してください。”} </p></blockquote><p>リソースのデプロイ検証に必要なアクションが不足していることが分かります。 </p><p>参考）Microsoft.Resources<br><a href="https://learn.microsoft.com/ja-jp/azure/role-based-access-control/resource-provider-operations#microsoftresources">https://learn.microsoft.com/ja-jp/azure/role-based-access-control/resource-provider-operations#microsoftresources</a></p><table><thead><tr><th align="left">アクション</th><th align="left">説明</th></tr></thead><tbody><tr><td align="left">Microsoft.Resources/deployments/validate/action</td><td align="left">デプロイを検証します。</td></tr></tbody></table><p>手順 2 で作成したカスタム ロールに ‘Microsoft.Resources/deployments/validate/action’ アクションを追加します。 </p><p><img src="/blog/vm/create-custom-roles/13.png"></p><p>次は別のエラーが出力されました。 </p><p><img src="/blog/vm/create-custom-roles/14.png"></p><blockquote><p>デプロイ要求を送信中にエラーが発生しました。<br>役立つ可能性がある基本 API から得られた追加の詳細情報: オブジェクト ID が ‘XXX’ のクライアント ‘testuser01@XXX’ には、スコープ ‘/subscriptions/XXXXX/resourceGroups/rg_test/providers/Microsoft.Resources/deployments/Snapshot.snapshot01-20240103124401’ でアクション ‘Microsoft.Resources/deployments/write’ を実行する認可がないか、スコープが無効です。アクセスが最近許可された場合は、資格情報を更新してください。 </p></blockquote><p>デプロイの作成に必要となるアクションが不足していることが分かります。 </p><p>参考）Microsoft.Resources<br><a href="https://learn.microsoft.com/ja-jp/azure/role-based-access-control/resource-provider-operations#microsoftresources">https://learn.microsoft.com/ja-jp/azure/role-based-access-control/resource-provider-operations#microsoftresources</a></p><table><thead><tr><th align="left">アクション</th><th align="left">説明</th></tr></thead><tbody><tr><td align="left">Microsoft.Resources/deployments/write</td><td align="left">デプロイを作成または更新します。</td></tr></tbody></table><p>手順 2 で作成したカスタム ロールに ‘Microsoft.Resources/deployments/write’ アクションを追加します。 </p><p><img src="/blog/vm/create-custom-roles/15.png"></p><p>今度は、’Microsoft.Compute/disks/beginGetAccess/action’ アクションが不足しているというエラーが出力されました。 </p><p><img src="/blog/vm/create-custom-roles/16.png"></p><blockquote><p>The client ‘testuser01@XXX’ with object id ‘XXX’ has permission to perform action ‘Microsoft.Compute/snapshots/write’ on scope ‘/subscriptions/XXXXX/resourcegroups/rg_test/providers/Microsoft.Compute/snapshots/snapshot01’; however, it does not have permission to perform action(s) ‘Microsoft.Compute/disks/beginGetAccess/action’ on the linked scope(s) ‘/subscriptions/XXXXX/resourceGroups/rg_test/providers/Microsoft.Compute/disks/win2022_OsDisk_1_XXX (respectively) or the linked scope(s) are invalid。詳細については、ここをクリックしてください </p></blockquote><p>参考）Microsoft.Compute<br><a href="https://learn.microsoft.com/ja-jp/azure/role-based-access-control/resource-provider-operations#microsoftcompute">https://learn.microsoft.com/ja-jp/azure/role-based-access-control/resource-provider-operations#microsoftcompute</a></p><table><thead><tr><th align="left">アクション</th><th align="left">説明</th></tr></thead><tbody><tr><td align="left">Microsoft.Compute/disks/beginGetAccess/action</td><td align="left">BLOB へのアクセス用にディスクの SAS URI を取得します。</td></tr></tbody></table><p>手順 2 で作成したカスタム ロールに “Microsoft.Compute/disks/beginGetAccess/action” を追加します。 </p><p><img src="/blog/vm/create-custom-roles/17.png"></p><p>ついに、スナップショットの作成に成功しました。 </p><p><img src="/blog/vm/create-custom-roles/18.png"></p><p><img src="/blog/vm/create-custom-roles/19.png"></p><p>最終的にユーザー testuser01 に対して必要となったアクションは以下となります。 </p><table><thead><tr><th align="left">アクション</th><th align="left">説明</th></tr></thead><tbody><tr><td align="left">*/read</td><td align="left">「閲覧者」ロール</td></tr><tr><td align="left">Microsoft.Compute/snapshots/write</td><td align="left">新しいスナップショットを作成するか、既存のスナップショットを更新します。</td></tr><tr><td align="left">Microsoft.Resources/deployments/validate/action</td><td align="left">デプロイを検証します。</td></tr><tr><td align="left">Microsoft.Resources/deployments/write</td><td align="left">デプロイを作成または更新します。</td></tr><tr><td align="left">Microsoft.Compute/disks/beginGetAccess/action</td><td align="left">BLOB へのアクセス用にディスクの SAS URI を取得します。</td></tr></tbody></table><p>以上のような手順にて、トライ アンド エラーを繰り返しながら、お客様環境にて必要最小となるアクションのみを付与したロールを作成いただく形となります。 </p><h2 id="3-補足情報-ブラウザー-トレースにて必要となるリソース-プロバイダー操作を把握する"><a href="#3-補足情報-ブラウザー-トレースにて必要となるリソース-プロバイダー操作を把握する" class="headerlink" title="3.補足情報 - ブラウザー トレースにて必要となるリソース プロバイダー操作を把握する"></a>3.補足情報 - ブラウザー トレースにて必要となるリソース プロバイダー操作を把握する</h2><p>トライ アンド エラーにてカスタム ロールを作成いただく際の補足情報となりますが、ブラウザー トレース (HAR トレース、F12 トレース) をご活用いただくことで、特定の操作を行う際に必要となるリソース プロバイダー操作をある程度把握することも可能です。 </p><h3 id="手順-1-ブラウザー-トレース-HAR-トレース、F12-トレース-を取得します。"><a href="#手順-1-ブラウザー-トレース-HAR-トレース、F12-トレース-を取得します。" class="headerlink" title="手順 1. ブラウザー トレース (HAR トレース、F12 トレース) を取得します。"></a>手順 1. ブラウザー トレース (HAR トレース、F12 トレース) を取得します。</h3><p>既に権限を持っているユーザーにてスナップショットを作成する際に、ブラウザー トレースを取得します。 </p><p> <img src="/blog/vm/create-custom-roles/20.png"></p><p>ブラウザー トレース (HAR トレース、F12 トレース) の取得手順の詳細は以下をご参照ください。 </p><p>参考）ネットワーク トレースの収集方法<br><a href="https://learn.microsoft.com/ja-jp/azure/azure-web-pubsub/howto-troubleshoot-network-trace">https://learn.microsoft.com/ja-jp/azure/azure-web-pubsub/howto-troubleshoot-network-trace</a> </p><h3 id="手順-2-取得したブラウザー-トレースを確認します。"><a href="#手順-2-取得したブラウザー-トレースを確認します。" class="headerlink" title="手順 2. 取得したブラウザー トレースを確認します。"></a>手順 2. 取得したブラウザー トレースを確認します。</h3><p>手順 1 にて生成された portal.azure.com.har という .har ファイルを開き、スナップショットを作成する際に必要となったリソース プロバイダー操作 (providers) を確認します。 </p><p><img src="/blog/vm/create-custom-roles/21.png"></p><p>以下 3 つに関するリソース プロバイダー操作が必要となることが分かります。 </p><p>Microsoft.Resources/deployments<br>Microsoft.Compute/snapshots<br>Microsoft.Compute/disks </p><p>さらに細かなアクションまでを把握することは叶いませんが、カスタム ロールを作成いただく際にどのリソース プロバイダー操作が必要となるかをある程度把握することができます。 </p><h3 id="4-ご留意点"><a href="#4-ご留意点" class="headerlink" title="4. ご留意点"></a>4. ご留意点</h3><p>・Azure RBAC のスコープについて<br>Azure RBAC の付与は、管理グループ、サブスクリプション、リソース グループ、リソースいずれかのスコープに対して適用することが可能となります。<br>今回、サブスクリプションをスコープとしたカスタム ロールを割り当てたため、サブスクリプション内に存在する全ての仮想マシンに対して同様の操作が実施可能になります。 </p><p>特定の複数の仮想マシンに対してロールを付与をしたい場合には、対象の仮想マシンが所属するリソース グループや仮想マシンひとつひとつに対して付与を行っていただくことが可能になります。<br>（親スコープに設定されたロールは、子スコープに継承されます） </p><p>参考）Azure RBAC のスコープについて<br><a href="https://docs.microsoft.com/ja-jp/azure/role-based-access-control/scope-overview">https://docs.microsoft.com/ja-jp/azure/role-based-access-control/scope-overview</a> </p><p>・リソース操作を行うツールについて </p><p>Azure Portal や Azure PowerShell、Azure CLI 等のツールからリソースを操作することが可能ですが、操作を行うツールによって必要となるアクションが異なるケースがございます。このような場合は、リソース操作を行うツールにて検証を行い、必要となるアクションを取捨選択いただきますようお願い申し上げます。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの木下です。&lt;br&gt;今回は特定の操作における Azure カスタム ロールの作成手順をご紹介いたします。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.Azure カスタム ロールについて&lt;/li&gt;
&lt;li&gt;2.カスタム ロールを作成す</summary>
      
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="RBAC" scheme="https://jpaztech.github.io/blog/tags/RBAC/"/>
    
  </entry>
  
  <entry>
    <title>Azure RHEL VM の 非 EUS/ EUS リポジトリについて</title>
    <link href="https://jpaztech.github.io/blog/vm/rhui-eus/"/>
    <id>https://jpaztech.github.io/blog/vm/rhui-eus/</id>
    <published>2024-01-15T00:00:00.000Z</published>
    <updated>2024-02-16T07:05:26.518Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは！Azure テクニカル サポート チームの高橋です。<br>今回は、Azure Marketplace から作成した Red Hat Enterprise Linux (RHEL) の<br>仮想マシンをご利用のお客様からよくお問い合わせを頂く</p><blockquote><p>・RHEL のマイナーバージョンがアップデートされない<br>・yum/dnf update したら意図せずマイナーバージョンが上がってしまった<br>・脆弱性対応のためパッケージのバージョンをアップデートしたいのに、yum/dnf update しても対象のバージョンに更新されない<br>・パッケージをインストール / 更新しようとするとパッケージの競合などのエラーが発生する</p></blockquote><p>という内容について、原因と解決方法をご紹介いたします。</p><span id="more"></span><hr><h2 id="原因について"><a href="#原因について" class="headerlink" title="原因について"></a>原因について</h2><p>結論から書いてしまうと、RHEL VM に接続されている Azure RHUI リポジトリが<br>非 EUS か EUS かによって発生している可能性が高いものと存じます。<br>RHEL VM のマイナーバージョンやパッケージのアップデートを実行する際には、<br>接続されているリポジトリの確認をする必要があります。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p>マイナーバージョンがアップデートされない事例として、</p><p>ゲスト OS 内の /etc/dnf/dnf.conf 内に exclude=kernel* の設定がないかご確認をください。</p><p>この設定がある場合、カーネルのアップデートが除外対象となっているため、マイナーバージョンのアップデートもされません。</p></div><hr><h2 id="非-EUS-と-EUS-リポジトリとは"><a href="#非-EUS-と-EUS-リポジトリとは" class="headerlink" title="非 EUS と EUS リポジトリとは"></a>非 EUS と EUS リポジトリとは</h2><p>ここでは、非 EUS、EUS リポジトリについてご紹介します。<br>Azure 上の RHEL VM は、既定で Azure RHUI (Red Hat Update Infrastructure) のリポジトリサーバーに接続されています。<br>Azure RHUI には、非 EUS (Extend Update Support) リポジトリと EUS リポジトリ の 2 種類があります。<br>RHEL VM が 非 EUS リポジトリに接続されている場合に、yum/dnf update を実施した際には、その時点で提供されている<br>最新の RHEL マイナーバージョンにアップグレードされ、最新のパッケージを取得できることとなります。 </p><p>一方で、RHEL VM が EUS リポジトリに接続されている場合、<br>yum/dnf update を実行した際に、更新プログラムは、<br>特定の RHEL マイナーバージョンを超えることはありません。<br>つまり、特定マイナーバージョンに固定されている状態 (マイナーバージョンロック) となります。<br>EUS は、ワークロードの都合上、特定のマイナーバージョンに固定して利用したいお客様向けにご利用頂けるものとなります。<br>EUS の詳細については、以下 Red Hat 社の公開情報にも纏められています。</p><blockquote><p>□ 参考 : Red Hat Enterprise Linux (RHEL) Extended Update Support (EUS) の概要<br>   <a href="https://access.redhat.com/ja/articles/3055941">https://access.redhat.com/ja/articles/3055941</a></p></blockquote><p>弊社公開情報にもリポジトリについて情報をお纏めしておりますので<br>併せてご確認ください。</p><blockquote><p>□ 参考 : Azure のオンデマンド Red Hat Enterprise Linux VM 用 Red Hat Update Infrastructure<br>  <a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/workloads/redhat/redhat-rhui?tabs=rhel7#image-update-behavior">https://learn.microsoft.com/ja-jp/azure/virtual-machines/workloads/redhat/redhat-rhui?tabs=rhel7#image-update-behavior</a></p></blockquote><hr><h2 id="接続しているリポジトリの確認方法"><a href="#接続しているリポジトリの確認方法" class="headerlink" title="接続しているリポジトリの確認方法"></a>接続しているリポジトリの確認方法</h2><p>ご利用の RHEL VM が 非 EUS / EUS リポジトリのどちらに接続されているのか<br>確認する方法についてご紹介します。<br>yum repolist コマンドで接続されているリポジトリを確認することができます。<br>yum repolist all コマンドを実行すると、以下のようにリポジトリが設定されていることが確認できます。<br>また、以下コマンドで、releasever がどのマイナーバージョンに固定されているか確認することができます。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/dnf/vars/releasever (RHEL 7 は、/etc/yum/vars/releasever)</span></span><br></pre></td></tr></table></figure><p>非 EUS リポジトリに接続されているときは以下のように releasever の固定もありません。<br><img src="/blog/vm/rhui-eus/01.png"></p><p>一方で、EUS リポジトリに接続されている環境では、リポジトリ名に <strong>“eus”</strong> の記載があり、<br>EUS リポジトリに接続されていることが確認できます。<br>例えば、EUS リポジトリに接続されている RHEL 8.4 の VM での<br>確認結果は以下のようになります。</p><p><img src="/blog/vm/rhui-eus/02.png"></p><hr><h2 id="接続しているリポジトリの変更方法と動作について"><a href="#接続しているリポジトリの変更方法と動作について" class="headerlink" title="接続しているリポジトリの変更方法と動作について"></a>接続しているリポジトリの変更方法と動作について</h2><p>それでは、接続しているリポジトリを変更する方法についてご紹介します。<br>リポジトリの変更については、以下 2 つの操作ができます。</p><blockquote><p>・非 EUS から EUS リポジトリに切り替える方法 (バージョンロック)<br>・EUS から、非 EUS リポジトリに変更する方法 (バージョンロックの解除)</p></blockquote><p>それぞれの方法について、RHEL 8 の環境を例にご紹介します。<br>なお、本操作はゲスト OS 内での作業となりますため、<br>予期せぬ問題に備えて、事前に<strong>バックアップ</strong>を取得頂くことや<strong>十分な検証</strong>をすることを推奨します。</p><h3 id="■-非-EUS-から-EUS-リポジトリに切り替える方法"><a href="#■-非-EUS-から-EUS-リポジトリに切り替える方法" class="headerlink" title="■ 非 EUS から EUS リポジトリに切り替える方法"></a>■ 非 EUS から EUS リポジトリに切り替える方法</h3><p>EUS リポジトリへ接続するためには以下の手順でコマンドを実行ください。</p><ol><li><p>EUS 以外のリポジトリを無効にする</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dnf --disablerepo=&#x27;*&#x27; remove &#x27;rhui-azure-rhel8&#x27; -y</span></span><br></pre></td></tr></table></figure></li><li><p>EUS リポジトリを追加する2 EUS リポジトリを追加する</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dnf --config=&#x27;https://rhelimage.blob.core.windows.net/repositories/rhui-microsoft-azure-rhel8-eus.config&#x27; install rhui-azure-rhel8-eus -y</span></span><br></pre></td></tr></table></figure></li><li><p>releaseverを固定する<br>EUS が提供されているバージョンを指定する必要があります。 (RHEL 8 の場合、8.1、8.2、8.4、8.6、8.8 のいずれかである必要があります)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sh -c &#x27;echo 8.x &gt; /etc/dnf/vars/releasever&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><p>EUS が提供されているバージョンは以下 Red Hat 社の公開情報からご確認ください。</p><blockquote><p>□ 参考 : Red Hat Enterprise Linux (RHEL) Extended Update Support (EUS) の概要<br>  <a href="https://access.redhat.com/ja/articles/3055941">https://access.redhat.com/ja/articles/3055941</a> </p></blockquote><p>以下の環境では、RHEL 8.4 の EUS リポジトリに接続されていることが確認できます。</p><p><img src="/blog/vm/rhui-eus/03.png"></p><p>この状態で dnf update をしても、マイナーバージョンは上がりません。(8.4 のまま)<br>また、アップデートできるパッケージは RHEL 8.4 向けのパッケージのバージョンまでしか取得できないことになります。<br>一例ではございますが、本記事の執筆時点で、httpd の最新バージョンは、<br>RHEL 8.4 に固定されている状態で、2.4.37-39 が取得できることが確認できます。</p><p><img src="/blog/vm/rhui-eus/04.png"></p><p>また、EUS リポジトリを特定のマイナーバージョンに固定することもできます。<br>以下のように releasever を固定したいバージョンに設定することが可能となります。<br>( x には、 EUS が提供されているバージョンを指定する必要があります)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo 8.x &gt; /etc/yum/vars/releasever</span></span><br></pre></td></tr></table></figure><p>以下例では、RHEL 8.4 の VM を RHEL 8.8 の EUS リポジトリに接続するよう変更しています。</p><p><img src="/blog/vm/rhui-eus/05.png"></p><p>この状態で、dnf update を実行し、再起動をすると RHEL 8.8 にマイナーバージョンがアップデートされます。<br>以下 dnf update を実施後の結果</p><p><img src="/blog/vm/rhui-eus/06.png"></p><p>また、パッケージは RHEL 8.8 向けのバージョンを取得することが可能となります。<br>httpd の場合、2.4.37-56 まで取得できることとなります。</p><p><img src="/blog/vm/rhui-eus/07.png"></p><h3 id="■-EUS-から、非-EUS-リポジトリに変更する方法"><a href="#■-EUS-から、非-EUS-リポジトリに変更する方法" class="headerlink" title="■ EUS から、非 EUS リポジトリに変更する方法"></a>■ EUS から、非 EUS リポジトリに変更する方法</h3><p>非 EUS リポジトリへ接続するためには以下の手順でコマンドを実行ください。</p><ol><li><p>releasever ファイルを削除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rm -f /etc/dnf/vars/releasever</span></span><br></pre></td></tr></table></figure></li><li><p>EUS リポジトリを無効にする</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dnf --disablerepo=&#x27;*&#x27; remove &#x27;rhui-azure-rhel8-eus&#x27; -y</span></span><br></pre></td></tr></table></figure></li><li><p>非 EUS リポジトリを追加する</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dnf --config=&#x27;https://rhelimage.blob.core.windows.net/repositories/rhui-microsoft-azure-rhel8.config&#x27; install rhui-azure-rhel8 -y</span></span><br></pre></td></tr></table></figure></li></ol><p>以下例では、RHEL 8.4 の VM を 非 EUS リポジトリに接続するよう変更しています。<br><img src="/blog/vm/rhui-eus/08.png"></p><p>この状態で dnf update をすると、その時点で提供されている最新のマイナーバージョンにアップデートされます。<br>dnf update を実施後の結果は以下のようになります。<br><img src="/blog/vm/rhui-eus/09.png"></p><p>各パッケージについては、RHEL 8 の最新のパッケージまで更新することが可能となります。<br>非 EUS リポジトリに接続することで、httpd は 2.4.37-62 のバージョンまでアップデートすることができます。<br><img src="/blog/vm/rhui-eus/10.png"></p><p>詳細な手順については、以下の公開ドキュメントにもお纏めしております。</p><blockquote><p>□ 参考 : RHEL Server を EUS リポジトリに切り替えます。<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/workloads/redhat/redhat-rhui?tabs=rhel8#switch-a-rhel-server-to-eus-repositories">https://learn.microsoft.com/ja-jp/azure/virtual-machines/workloads/redhat/redhat-rhui?tabs=rhel8#switch-a-rhel-server-to-eus-repositories</a></p></blockquote><blockquote><p>□ 参考 : RHEL Server を EUS 以外のリポジトリに切り替えます。<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/workloads/redhat/redhat-rhui?tabs=rhel8#switch-a-rhel-server-to-non-eus-repositories">https://learn.microsoft.com/ja-jp/azure/virtual-machines/workloads/redhat/redhat-rhui?tabs=rhel8#switch-a-rhel-server-to-non-eus-repositories</a></p></blockquote><p>マイナーバージョンが想定通りアップグレードできない場合や、<br>脆弱性対応などで、ご要望のパッケージバージョンが表示されない際には、<br>上記リポジトリの設定をご確認頂き、適切なリポジトリを設定頂くようご確認頂ければと思います。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p>リポジトリの設定変更作業において、ゲスト OS の再起動は不要となります。</p><p>ただし、yum / dnf update によりカーネルの更新等を行った場合には、</p><p>更新を反映させるため再起動が必要となります。</p><p>再起動の必要性はパッチの適用状況によって異なるため、一概にご案内することは難しいですが、needs-restarting -r を実施することで、再起動が必要か判断することもできます。</p><p>以下の Red Hat 社の公開情報についてもご確認頂ければと思います。</p><p>□ 参考 : 更新後にシステムの再起動が必要なパッケージを特定する</p><p><a href="https://access.redhat.com/ja/solutions/2725591">https://access.redhat.com/ja/solutions/2725591</a></p><p>＃閲覧には Red Hat 社のアカウントが必要になります。</p></div><hr><h2 id="補足-1-依存関係について"><a href="#補足-1-依存関係について" class="headerlink" title="補足 1 : 依存関係について"></a>補足 1 : 依存関係について</h2><p>マイナーバージョンの固定や、解除は環境に合わせて設定変更ができます。<br>しかしながら、以下のような場合、パッケージをインストールする際に、<br>関連するパッケージの依存関係の問題が発生し、<br>正常にインストールできないエラーが発生することがございます。 </p><blockquote><p>・マイナーバージョンを固定しない状態でパッケージのアップデートを行った後で、マイナーバージョンを固定した場合<br>・特定のマイナーバージョンに固定し、パッケージをアップデートした後に、それよりも低いマイナーバージョンに固定した場合</p></blockquote><p>イメージとしては、以下の通りとなります。<br><img src="/blog/vm/rhui-eus/11.png"></p><p>EUS リポジトリでは、問題の修正のため、取得できるパッケージのバージョンが分岐されて提供されております。<br>インストール済みのパッケージのバージョンと、<br>インストール予定のパッケージのバージョンに差があることで パッケージの <strong>conflict</strong> が発生します。</p><p>一例ではございますが、本事象は以下のような手順を実施した場合に再現します。</p><p>以下の手順を実施します。</p><blockquote><ol><li>RHEL 8.4 の VM で 非 EUS リポジトリに接続されている環境から、glibc をアップデート</li><li>非 EUS リポジトリから、RHEL 8.4 の EUS リポジトリに固定するよう変更</li><li>dnf install gcc を実行する</li></ol></blockquote><p>この手順を実施した際にパッケージの <strong>conflict</strong> が発生して、正常にインストールができない事象が発生します。</p><p>エラー内容一部抜粋</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@rhel84 ~]# cat /etc/dnf/vars/releasever</span><br><span class="line">8.4</span><br><span class="line">[root@rhel84 ~]#</span><br><span class="line">[root@rhel84 ~]# dnf install gcc</span><br><span class="line">Last metadata expiration check: 22:49:35 ago on Thu 28 Dec 2023 06:32:39 AM UTC.</span><br><span class="line">Error:</span><br><span class="line"> Problem: package gcc-8.4.1-1.1.el8_4.x86_64 requires glibc-devel &gt;= 2.2.90-12, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-127.el8_3.2.x86_64 requires glibc = 2.28-127.el8_3.2, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-101.el8.x86_64 requires glibc = 2.28-101.el8, but none of the providers can be installed</span><br><span class="line">~</span><br><span class="line">  - cannot install both glibc-2.28-101.el8.x86_64 and glibc-2.28-236.el8.7.x86_64</span><br><span class="line">  - cannot install both glibc-2.28-42.el8.x86_64 and glibc-2.28-236.el8.7.x86_64</span><br><span class="line">  - cannot install both glibc-2.28-72.el8_1.1.x86_64 and glibc-2.28-236.el8.7.x86_64</span><br><span class="line">  - cannot install both glibc-2.28-127.el8.x86_64 and glibc-2.28-236.el8.7.x86_64</span><br><span class="line">  - cannot install both glibc-2.28-72.el8.x86_64 and glibc-2.28-236.el8.7.x86_64</span><br><span class="line">  - cannot install both glibc-2.28-42.el8_0.1.x86_64 and glibc-2.28-236.el8.7.x86_64</span><br><span class="line">  - cannot install both glibc-2.28-151.el8.x86_64 and glibc-2.28-236.el8.7.x86_64</span><br><span class="line">  - package glibc-gconv-extra-2.28-236.el8.7.x86_64 requires glibc(x86-64) = 2.28-236.el8.7, but none of the providers can be installed</span><br><span class="line">  - cannot install the best candidate for the job</span><br><span class="line">  - problem with installed package glibc-gconv-extra-2.28-236.el8.7.x86_64</span><br><span class="line">(try to add &#x27;--allowerasing&#x27; to command line to replace conflicting packages or &#x27;--skip-broken&#x27; to skip uninstallable packages or &#x27;--nobest&#x27; to use not only best candidate packages)</span><br></pre></td></tr></table></figure><p>この場合、変更したマイナーバージョンへのアップデートまたは、<br>作業前のバックアップを取得している場合は、VM を復元頂くことを推奨いたします。<br>問題となっているパッケージのダウングレードや削除・再インストールで解消できる場合もありますが、<br>EUS の継続利用が困難になることや、<br>その他の予期しない問題が発生することもございますため、<br>再度マイナーバージョンの固定化を実施する際にはご留意ください。</p><h2 id="補足-2-RHUI-より提供されるパッケージバージョンについて"><a href="#補足-2-RHUI-より提供されるパッケージバージョンについて" class="headerlink" title="補足 2 : RHUI より提供されるパッケージバージョンについて"></a>補足 2 : RHUI より提供されるパッケージバージョンについて</h2><p>Azure RHUI はRed Hat社のリポジトリとの即時の同期が実施されないため、タイミングによっては、最新バージョンのパッケージがまだ提供されてない場合もありますので、そのような場合は時間をおいて再度ご確認ください。 </p><p>また、OSS のパッケージについてはその OSS が提供している最新のバージョンが RHUI では提供されていない場合もございます。 </p><p>不具合に対する修正については、パッケージのバージョンが古い場合でも Red Hatでは適切にバックポートされている場合もございます。</p><p>本稿が皆様のお役に立てれば幸いです。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは！Azure テクニカル サポート チームの高橋です。&lt;br&gt;今回は、Azure Marketplace から作成した Red Hat Enterprise Linux (RHEL) の&lt;br&gt;仮想マシンをご利用のお客様からよくお問い合わせを頂く&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;・RHEL のマイナーバージョンがアップデートされない&lt;br&gt;・yum/dnf update したら意図せずマイナーバージョンが上がってしまった&lt;br&gt;・脆弱性対応のためパッケージのバージョンをアップデートしたいのに、yum/dnf update しても対象のバージョンに更新されない&lt;br&gt;・パッケージをインストール / 更新しようとするとパッケージの競合などのエラーが発生する&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;という内容について、原因と解決方法をご紹介いたします。&lt;/p&gt;</summary>
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Linux" scheme="https://jpaztech.github.io/blog/tags/Linux/"/>
    
    <category term="RHEL" scheme="https://jpaztech.github.io/blog/tags/RHEL/"/>
    
    <category term="RHUI" scheme="https://jpaztech.github.io/blog/tags/RHUI/"/>
    
    <category term="Non EUS" scheme="https://jpaztech.github.io/blog/tags/Non-EUS/"/>
    
    <category term="EUS" scheme="https://jpaztech.github.io/blog/tags/EUS/"/>
    
  </entry>
  
  <entry>
    <title>Azure Front Door 及び Microsoft Standard SKU の Azure CDN において発生する接続の問題</title>
    <link href="https://jpaztech.github.io/blog/network/afd-connection-issue/"/>
    <id>https://jpaztech.github.io/blog/network/afd-connection-issue/</id>
    <published>2023-12-29T08:30:00.000Z</published>
    <updated>2024-02-16T07:05:26.186Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポート チームの石原です。</p><p>本ブログでは、Azure Front Door 及び Microsoft Standard SKU の Azure CDN (以降は AFD と記載致します) において起こりうる接続の問題やお客様で対策可能な内容などについてご案内致します。</p><span id="more"></span><hr><h2 id="AFD-で発生しうる接続の問題ついて"><a href="#AFD-で発生しうる接続の問題ついて" class="headerlink" title="AFD で発生しうる接続の問題ついて"></a>AFD で発生しうる接続の問題ついて</h2><p>AFD のプラットフォーム上では、より早くより適切なルートでオリジンへトラフィックをルーティングするために、さまざまな仕組みが用いられています。その仕組みの 1 つとして、AFD のプラットフォーム上にて処理するトラフィックの流量を調整する機能が存在しております。<br>AFD のサービスは世界中のエッジ サーバーに分散配置されており、複数のお客様でエッジ サーバーを共有して利用するマネージド サービスです。お客様のリクエストが、どのエッジ サーバーへルーティングされるかは、AFD によって動的にコントロールされています。<br>また、トラフィックの流量を調整する機能が特定のエッジ サーバーで起動した場合は、そのエッジ サーバーにルーティングされた一部のクライアントに対して RST パケットを送信する動作になります。<br>つまり、お客様の構成した AFD にアクセスを行い、該当のエッジ サーバーにルーティングされてしまった一部のクライアントも RST パケットを受け取る可能性があります。<br>なお、この仕組みによって、断続的に数分から数十分程度の間、クライアントから AFD への接続に影響を及ぼす可能性があります。</p><h2 id="接続の問題を受けるクライアント"><a href="#接続の問題を受けるクライアント" class="headerlink" title="接続の問題を受けるクライアント"></a>接続の問題を受けるクライアント</h2><p>TCP RST パケットを受信したクライアントが TCP レイヤー レベルで接続をリトライしない場合は、トラフィックの流量の調整が機能している間は、クライアントから AFD への接続に影響が発生してしまいます。<br>例えば、アプリケーション システムのフロントとして AFD を使用しており、一般ユーザーが PC 端末やスマートフォンの WEB ブラウザを用いて直接 AFD にアクセスする場合は、一時的に接続エラーになっても、WEB ブラウザにて画面を更新することによって正常に接続できる可能性があります。<br>一方で、API を処理するようなシステムのフロントとして AFD を使用しており、API を送信するクライアント側で TCP レイヤー レベルで再送処理を考慮していない場合は、RST パケットを受信したあとで AFD への TCP レイヤーでの再接続が実行されずに通信が失敗します。他には、Zabbix などの監視システムにおいて curl コマンドを AFD に送信している場合も同様のことが発生する可能性があります。</p><h2 id="リトライ-ロジックの実装"><a href="#リトライ-ロジックの実装" class="headerlink" title="リトライ ロジックの実装"></a>リトライ ロジックの実装</h2><p>一時的な接続の問題をクライアントが処理できるようにするために、AFD に接続を行うクライアント サイドの動作にてリトライ ロジックやサーキット ブレークの実装をご検討ください。これにより、アプリケーション システム上の通信の安定性を向上させることに繋がります。<br>リトライ ロジックやサーキット ブレークの必要性や実装の概要について記載されている公開ドキュメントやブログ (英語) につきましては、下記の URL に記載がございますので、ご参考になれば幸いです。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/architecture/patterns/retry">再試行パターン</a></p><p><a href="https://azure.microsoft.com/en-us/blog/using-the-retry-pattern-to-make-your-cloud-application-more-resilient/">Using the Retry pattern to make your cloud application more resilient</a></p><h2 id="詳細な調査が必要なケース"><a href="#詳細な調査が必要なケース" class="headerlink" title="詳細な調査が必要なケース"></a>詳細な調査が必要なケース</h2><p>リトライ ロジックやサーキット ブレークを実装しているにもかかわらず、AFD への接続で遅延やタイムアウトなどの問題が、数分程度ではなく長時間にわたって事象が継続している場合は、詳細に調査を行う必要がございますので、サポート窓口までお問い合わせください。<br>なお、お問い合わせをいただく際には、AFD へ接続を実施している通信状況が分かるネットワーク パケットのキャプチャー ファイルとカスタム ドメインを nslookup コマンドなどで名前解決した結果をサポートまで提供いただくことにより、お客様とサポートとの間でのヒアリングをスムーズに進めることができます。<br>お手数をおかけいたしますが、下記の手順を参考にネットワーク パケット キャプチャー ファイルの採取及びカスタム ドメインの名前解決結果にご協力いただけますと幸いです。</p><h4 id="■-ネットワーク-パケット-キャプチャー-ファイルの採取"><a href="#■-ネットワーク-パケット-キャプチャー-ファイルの採取" class="headerlink" title="■ ネットワーク パケット キャプチャー ファイルの採取"></a>■ ネットワーク パケット キャプチャー ファイルの採取</h4><p>【クライアントが Windows OS の場合】</p><ol><li>管理者権限を持つアカウントでコマンド プロンプトを開きます (UAC が有効の場合には、”管理者として実行” します)。</li><li>コマンド プロンプト上で次のコマンドを実行して、ネットワーク パケットのキャプチャを開始します。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh trace start capture=yes</span><br></pre></td></tr></table></figure></li><li>お客様のアプリケーションを配信元として設定している AFD に対し、クライアント上で WEB ブラウザや curl コマンドなどを使用して AFD へリクエストを送って接続問題の事象を再現させます。この操作を 5 秒ほどの間隔をあけて 2 ~ 3 度リクエストを送ってください。</li><li>コマンド プロンプト上で次のコマンドを実行して、ネットワーク パケット キャプチャを停止します。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh trace stop</span><br></pre></td></tr></table></figure>トレース ファイルの収集処理が完了しましたら、コマンド プロンプト上で “ファイルの場所” として表示されている NetTrace.etl ファイル、及び同じフォルダ内の NetTrace.cab の 2 つのファイルを取得します。</li></ol><p>【クライアントが Linux OS の場合】</p><ol><li>sudo 権限を持っているユーザーとしてログインし、次のコマンドを実行し、キャプチャを開始します。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -s0 -i any -n -w outfile.pcap</span><br></pre></td></tr></table></figure></li><li>お客様のアプリケーションを配信元として設定している AFD に対し、クライアント上で WEB ブラウザや curl コマンドなどを使用して AFD へリクエストを送って接続問題の事象を再現させます。この操作を 5 秒ほどの間隔をあけて 2 ~ 3 度リクエストを送ってください。</li><li>Ctrl + C でパケットキャプチャを停止します。</li><li>コマンドを実行した場所にある outfile.pcap を取得します。</li></ol><h4 id="■-カスタム-ドメインの名前解決結果"><a href="#■-カスタム-ドメインの名前解決結果" class="headerlink" title="■ カスタム ドメインの名前解決結果"></a>■ カスタム ドメインの名前解決結果</h4><p>お手元の端末においてコマンド プロンプトなどを開き、以下のコマンドを実行します。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup &lt;カスタム ドメイン名&gt;</span><br></pre></td></tr></table></figure><p>もしくは</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig &lt;カスタム ドメイン名&gt;</span><br></pre></td></tr></table></figure><p>また、お問い合わせをいただいた後に、担当のサポート エンジニアよりヒアリング シートへの記入をお願いする可能性もございます。その際はご協力の程よろしくお願い致します。</p><h2 id="AFD-の接続の問題によって大きなサービス-インパクトが発生するシステムの場合"><a href="#AFD-の接続の問題によって大きなサービス-インパクトが発生するシステムの場合" class="headerlink" title="AFD の接続の問題によって大きなサービス インパクトが発生するシステムの場合"></a>AFD の接続の問題によって大きなサービス インパクトが発生するシステムの場合</h2><p>AFD はマネージド サービスになるため、場合によっては短期間で完全な対策を講じることができない可能性もあります。<br>AFD の接続の問題が長時間にわたって継続することによって、お客様のシステムに大きなサービス インパクトが懸念される場合は、お客様にて影響範囲や時間、発生パターンなどに応じてシステムを継続するための代替構成の導入をご検討をお願いする場合があります。<br>あくまで例としてですが、代替システムの構成例としては、以下のようなパターンがございます。</p><h4 id="パターン-1-AFD-を経由しない構成"><a href="#パターン-1-AFD-を経由しない構成" class="headerlink" title="パターン 1 : AFD を経由しない構成"></a>パターン 1 : AFD を経由しない構成</h4><p>AFD に登録しているカスタム ドメインの名前解決先を AFD のエンドポイントではなく、オリジンのパブリック IP アドレスや FQDN になるように DNS レコードを更新して、AFD を経由せずに直接オリジンにアクセスします。</p><h4 id="パターン-2-Traffic-Manager-と-Application-Gateway-を組み合わせた構成"><a href="#パターン-2-Traffic-Manager-と-Application-Gateway-を組み合わせた構成" class="headerlink" title="パターン 2 : Traffic Manager と Application Gateway を組み合わせた構成"></a>パターン 2 : Traffic Manager と Application Gateway を組み合わせた構成</h4><p>AFD と同じように L7 のリバース プロキシとして動作するサービスに Application Gateway がありますが、リージョン レベルでの冗長性を確保するために AFD をご利用いただいているお客様も多いかと存じます。<br>複数の Application Gateway を異なるリージョンにデプロイして、Traffic Manager のエンドポイントに Application Gateway パブリック IP アドレスや FQDN を登録し、AFD に登録しているカスタム ドメインの名前解決先を Traffic Manager の FQDN に変更することで、リージョン レベルでの冗長性を確保して継続稼働することが可能になります。<br>Traffic Manager と Application Gateway を組み合わせた構成については、下記の公開ドキュメントに記載がございますので、ご参考になれば幸いです。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/traffic-manager/traffic-manager-load-balancing-azure">Azure で負荷分散サービスを使用する</a></p><div class="alert is-info"><p class="alert-title">Note</p><p>なお AFD とは異なり、Application Gateway ではバックエンドから取得したコンテンツをキャッシュしたり、コンテンツを圧縮してクライアントに配信することはできませんので、その点をご理解いただいたうえで、Application Gateway の使用をご検討ください。</p></div><h4 id="パターン-3-Edgio-SKU-の-Azure-CDN-の利用"><a href="#パターン-3-Edgio-SKU-の-Azure-CDN-の利用" class="headerlink" title="パターン 3 : Edgio SKU の Azure CDN の利用"></a>パターン 3 : Edgio SKU の Azure CDN の利用</h4><p>Azure Front Door と Microsoft Standard SKU の Azure CDN は同じプラットフォーム上で動作しています。一方で、Edgio SKU の Azure CDN は Edgio 社が管理しているプラットフォーム上で動作しているため、AFD にて接続の問題が発生している間、Edgio SKU の Azure CDN にて同一の原因で接続の問題が発生することはありません。<br>また、AFD で使用しているカスタム ドメインを予め Edgio SKU の Azure CDN に登録いただけますので、予め Edgio SKU の Azure CDN を準備してカスタム ドメインを登録しておくことにより、AFD から Edgio SKU の Azure CDN に切り替えて継続稼働することが可能になります。<br>なお、Edgio SKU の Azure CDN に固定費用はなくデータ転送量による従量課金制になるため、アクセスが発生しない限りは課金されることはございません。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポート チームの石原です。&lt;/p&gt;
&lt;p&gt;本ブログでは、Azure Front Door 及び Microsoft Standard SKU の Azure CDN (以降は AFD と記載致します) において起こりうる接続の問題やお客様で対策可能な内容などについてご案内致します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Network" scheme="https://jpaztech.github.io/blog/tags/Network/"/>
    
    <category term="AzureFrontDoor" scheme="https://jpaztech.github.io/blog/tags/AzureFrontDoor/"/>
    
    <category term="AzureCDN" scheme="https://jpaztech.github.io/blog/tags/AzureCDN/"/>
    
  </entry>
  
  <entry>
    <title>Azure VM の「再起動を必要としないメンテナンス」を事前に検知する方法</title>
    <link href="https://jpaztech.github.io/blog/vm/get-scheduled-events-from-imds/"/>
    <id>https://jpaztech.github.io/blog/vm/get-scheduled-events-from-imds/</id>
    <published>2023-12-29T07:00:00.000Z</published>
    <updated>2024-02-16T07:05:26.374Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの富田です。<br>今回は表題の通り、Azure VM の再起動を必要としないメンテナンスを事前に検知する方法をご紹介させていただきます。<br>IMDS を用いて Scheduled Events を監視することで、再起動を必要としないメンテナンスを事前に検知することが可能です。  </p><hr><h2 id="Azure-VM-のメンテナンスについて"><a href="#Azure-VM-のメンテナンスについて" class="headerlink" title="Azure VM のメンテナンスについて"></a>Azure VM のメンテナンスについて</h2><p>Azure VM はお客様に安心してご利用いただくためにセキュリティ向上の対応や機能改善等を目的として定期的に Azure 基盤側のメンテナンスを行っております。<br>お客様の VM に影響の発生する可能性のあるメンテナンスとして、大きく以下の 2 種類に分けられます。  </p><ul><li>再起動を<strong>必要とする</strong>メンテナンス</li><li>再起動を必要としないメンテナンス（ライブマイグレーションを含む）</li></ul><blockquote><p>■ご参考：Azure での仮想マシンのメンテナンス<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-and-updates">https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-and-updates</a></p></blockquote><p>再起動を<strong>必要とする</strong>メンテナンスについては、以下の通り Azure Portal の [サービスの正常性] で事前に確認が可能です。</p><blockquote><p>■ご参考：計画メンテナンスの通知の処理<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications">https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-notifications</a></p></blockquote><p>再起動を必要としないメンテナンスについては、恐縮ながら Azure Portal での事前の確認をすることや、既定でメールの通知がされるものではございません。<br>そのため、「何とかして再起動を必要としないメンテナンスが発生することを事前に確認することができないか？」というお問い合わせをいただくこともございます。<br>後述の通り、IMDS を用いて Scheduled Events を監視することで再起動を必要としないメンテナンスを事前に確認する事が可能です。  </p><hr><h2 id="IMDS-を用いて-Scheduled-Events-を確認する"><a href="#IMDS-を用いて-Scheduled-Events-を確認する" class="headerlink" title="IMDS を用いて Scheduled Events を確認する"></a>IMDS を用いて Scheduled Events を確認する</h2><p>まずは IMDS について簡単に解説させていただきます。<br>IMDS（Instance Metadata Service）は、現在実行中の VM に関する情報を取得できるものとなっております。<br>実行中の VM 内から IMDS に HTTP アクセスを行うことで、情報を取得することが可能です。<br>なお、同一の可用性セット内の VM もしくは同じ VMSS 内のインスタンスについても合わせて情報を取得できます。</p><blockquote><p>■ご参考：Azure Instance Metadata Service<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/instance-metadata-service">https://learn.microsoft.com/ja-jp/azure/virtual-machines/instance-metadata-service</a></p></blockquote><p>この IMDS のエンドポイントの 1 つとして、Scheduled Events というものがございます。<br>これは VM の近い将来にスケジュールされている VM の再起動やメンテナンスのイベントを確認できるものとなっております。  </p><blockquote><p>■ご参考：Azure Metadata Service: Windows VM のScheduled Events<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/scheduled-events">https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/scheduled-events</a></p></blockquote><blockquote><p>■ご参考：Azure Metadata Service: Linux VM の Scheduled Events<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/scheduled-events">https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/scheduled-events</a></p></blockquote><p>それでは、Scheduled Events の確認を実際にやってましょう。<br>以下のコマンドを Azure VM 上のゲスト OS 内にて実行します。  </p><p><strong>Windows</strong> の場合は PowerShell より以下のコマンドで、IMDS の Scheduled Events のエンドポイントに HTTP でアクセスします。  </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-RestMethod -Headers @&#123;&quot;Metadata&quot;=&quot;true&quot;&#125; -Method GET -Uri &quot;http://169.254.169.254/metadata/scheduledevents?api-version=2020-07-01&quot; | ConvertTo-Json -Depth 64</span><br></pre></td></tr></table></figure><p><strong>Linux</strong> の場合は以下の通り Bash で curl コマンドで、IMDS の Scheduled Events のエンドポイントに HTTP でアクセスします。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H Metadata:<span class="literal">true</span> http://169.254.169.254/metadata/scheduledevents?api-version=2020-07-01</span><br></pre></td></tr></table></figure><p>実行結果として、以下の例のように直近のスケジュールされたイベントがレスポンスとして確認できます。</p><h3 id="特に何もスケジュールされたイベントが無い場合"><a href="#特に何もスケジュールされたイベントが無い場合" class="headerlink" title="特に何もスケジュールされたイベントが無い場合"></a>特に何もスケジュールされたイベントが無い場合</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;DocumentIncarnation&quot;</span>:  <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;Events&quot;</span>:  [</span><br><span class="line"></span><br><span class="line">               ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="起動を必要としないメンテナンスがスケジュールされている場合"><a href="#起動を必要としないメンテナンスがスケジュールされている場合" class="headerlink" title="起動を必要としないメンテナンスがスケジュールされている場合"></a>起動を必要としないメンテナンスがスケジュールされている場合</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;DocumentIncarnation&quot;</span>:  <span class="number">28</span>,</span><br><span class="line">    <span class="attr">&quot;Events&quot;</span>:  [</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="attr">&quot;EventId&quot;</span>:  <span class="string">&quot;E92E64F9-XXXX-XXXX-XXXX-FF3EBA4C0090&quot;</span>,</span><br><span class="line">                       <span class="attr">&quot;EventStatus&quot;</span>:  <span class="string">&quot;Scheduled&quot;</span>, → スケジュールされたイベントがある。★★★</span><br><span class="line">                       <span class="attr">&quot;EventType&quot;</span>:  <span class="string">&quot;Freeze&quot;</span>, → 再起動を伴わないメンテナンスである。★★★</span><br><span class="line">                       <span class="attr">&quot;ResourceType&quot;</span>:  <span class="string">&quot;VirtualMachine&quot;</span>,</span><br><span class="line">                       <span class="attr">&quot;Resources&quot;</span>:  [</span><br><span class="line">                                         <span class="string">&quot;VMName&quot;</span> → 対象の VM 名。★★★</span><br><span class="line">                                     ],</span><br><span class="line">                       <span class="attr">&quot;NotBefore&quot;</span>:  <span class="string">&quot;Mon, 19 Sep 2023 18:00:00 GMT&quot;</span>, → この時刻以降にメンテナンスが実行される。★★★</span><br><span class="line">                       <span class="attr">&quot;Description&quot;</span>:  <span class="string">&quot;This is sample Description&quot;</span>,</span><br><span class="line">                       <span class="attr">&quot;EventSource&quot;</span>:  <span class="string">&quot;Platform&quot;</span>,</span><br><span class="line">                       <span class="attr">&quot;DurationInSeconds&quot;</span>:  <span class="number">2</span> → 想定される影響時間は <span class="number">2</span> 秒である。★★★</span><br><span class="line">                   &#125;</span><br><span class="line">               ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>イベントによって何分前までには通知されるといった NotBefore の時間が違いますが、再起動を必要としないメンテナンスについては、実行される約 15 分前までにはスケジュールが設定されます。<br>つまり 20 分前といった場合はまだスケジュールが設定されていないために、確認が叶わない場合もございます点、ご留意ください。  </p><p>すなわち、定期的に IMDS の Scheduled Events をアクセスすることで、再起動を必要としないメンテナンス実行の約 15 分前には事前にメンテナンスが発生する予定を確認することが可能です。<br>次のセクションではこの Scheduled Events を定期的に確認する方法についてご案内させていただきます。  </p><hr><h2 id="Windows-環境で定期的に-Scheduled-Events-を監視し、再起動を必要としないメンテナンスがあった際にアラート通知を行うサンプル"><a href="#Windows-環境で定期的に-Scheduled-Events-を監視し、再起動を必要としないメンテナンスがあった際にアラート通知を行うサンプル" class="headerlink" title="Windows 環境で定期的に Scheduled Events を監視し、再起動を必要としないメンテナンスがあった際にアラート通知を行うサンプル"></a>Windows 環境で定期的に Scheduled Events を監視し、再起動を必要としないメンテナンスがあった際にアラート通知を行うサンプル</h2><p>Windows 環境においては、以下の通り公開ドキュメントとして、定期的に Scheduled Events を監視し、再起動を必要としないメンテナンスがスケジュールされた際にアラート通知を行うサンプルがございます。  </p><blockquote><p>■ご参考：Azure VM のスケジュールされたイベントを監視する<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/scheduled-event-service">https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/scheduled-event-service</a></p></blockquote><p>具体的な内容は実際のドキュメントをご確認いただきたく存じますが、簡単に内容を解説すると以下の通りとなります。  </p><ul><li>同一の可用性セットに VM を 2 つ作成する。</li><li>片方の VM にて SchService.ps1 という定期的な Scheduled Events のアクセスを行うスクリプトを実行する。</li><li>SchService.ps1 は同一の可用性セット内 VM に対する Scheduled Events を検知すると、その内容をイベントログに記録する。</li><li>Azure Monitor の Log Analytics を用いて、その記録されたイベントログを監視する。</li><li>Scheduled Events が記録されたイベントログを発見すると、アラート（メール通知等）を発報する。</li></ul><p>なお、恐縮ながら再起動を必要としないメンテナンスを疑似的に発生させて “EventType”:”Freeze” の Scheduled Events を発生させることは叶いません。<br>そのため、このサンプルの動作確認としては代替として再起動イベントを検知する形となっております。  </p><p>上記のサンプルによって、同一の可用性セット内の VM で再起動を必要としないメンテナンスがスケジュールされた際に、自動的にメール通知を行うといったことが可能となります。<br>また、SchService.ps1 をご自身で拡張いただくことで、Scheduled Events を検知したら自動的に何かを実行するといったスクリプトにしていただくことも可能です。</p><hr><h2 id="Linux-環境で定期的に-Scheduled-Events-を監視するサンプル"><a href="#Linux-環境で定期的に-Scheduled-Events-を監視するサンプル" class="headerlink" title="Linux 環境で定期的に Scheduled Events を監視するサンプル"></a>Linux 環境で定期的に Scheduled Events を監視するサンプル</h2><p>Linux 環境においては、上記の Windows のようにアラート通知を行うといったサンプルのご用意がございませんが、定期的な Scheduled Events の監視をするサンプルが以下の通りご用意されております。  </p><blockquote><p>■ご参考：Azure Metadata Service: Scheduled Events Samples<br><a href="https://github.com/Azure-Samples/virtual-machines-scheduled-events-discover-endpoint-for-non-vnet-vm">https://github.com/Azure-Samples/virtual-machines-scheduled-events-discover-endpoint-for-non-vnet-vm</a></p></blockquote><p>勿論、上記サンプル以外にも Scheduled Events へ定期的なアクセスを試みる方法を実行頂いても構いません。  </p><hr><p>以上の通り、Azure VM の再起動を必要としないメンテナンスを事前に検知する方法をご紹介させていただきました。<br>なお、再起動を必要としないメンテナンスを実行するタイミングをコントロールしたいといった場合は、Dedicated Host もしくは分離された仮想マシンをご利用の上、メンテナンス構成を設定いただくことで実現可能でございます。<br>この点については以下の公式ドキュメント等をご参照ください。  </p><blockquote><p>■ご参考：メンテナンス構成による VM の更新の管理<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-configurations">https://learn.microsoft.com/ja-jp/azure/virtual-machines/maintenance-configurations</a></p></blockquote><p>定期的なメンテナンスは安心してお客様に Azure をご利用いただく上で必要不可欠でございます点、ご理解賜りますと幸いでございます。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの富田です。&lt;br&gt;今回は表題の通り、Azure VM の再起動を必要としないメンテナンスを事前に検知する方法をご紹介させていただきます。&lt;br&gt;IMDS を用いて Scheduled Events を監視することで、再起</summary>
      
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="Linux" scheme="https://jpaztech.github.io/blog/tags/Linux/"/>
    
    <category term="HowTo" scheme="https://jpaztech.github.io/blog/tags/HowTo/"/>
    
  </entry>
  
  <entry>
    <title>サービスタグに必要なアクセス制御 (RBAC) について</title>
    <link href="https://jpaztech.github.io/blog/network/azure-service-tag-authority/"/>
    <id>https://jpaztech.github.io/blog/network/azure-service-tag-authority/</id>
    <published>2023-12-25T06:00:00.000Z</published>
    <updated>2024-02-16T07:05:26.190Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームです。</p><p>Azure サービスをご利用いただく中で、Azure ロールベースのアクセス制御 (RBAC) を利用し、必要な権限をユーザーに付与し、運用いただいているお客様も多いかと存じます。その中で、Azure Portal 上の NSG のサービスタグが一部しか表示されない事象があるというお問い合わせを多くいただいておりますので、その原因および回避策について本ブログでご説明いたします。</p><h2 id="NSG-のサービスタグが一部しか表示されない原因"><a href="#NSG-のサービスタグが一部しか表示されない原因" class="headerlink" title="NSG のサービスタグが一部しか表示されない原因"></a>NSG のサービスタグが一部しか表示されない原因</h2><p>以下のように、一部のサービスタグのみしか表示されないというお問い合わせをいただいております。</p><p><img src="/blog/network/azure-service-tag-authority/service-tag-rbac-ng.png"></p><p>結論から申し上げると、サービスタグを表示させるための、RBAC 権限が付与されていない、不足している場合、上記のような事象が発生いたします。上記のように一部のサービスタグのみしか表示されない場合、サービスタグを表示させるための、読み取りアクセス許可をユーザーに対して付与いただく必要がございます。具体的には、すべてのサービスタグを表示させるために、<span style="color: red; "><strong>サブスクリプション</strong></span>のスコープに対して、以下の 2 つの読み取り権限を付与いただく必要がございます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;Microsoft.Network/locations/serviceTags/read&quot;</span><br><span class="line">&quot;Microsoft.Network/locations/serviceTagDetails/read&quot;</span><br></pre></td></tr></table></figure><p><a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/service-tags-overview">仮想ネットワーク サービス タグ - Virtual Network | Microsoft Learn</a></p><blockquote><p>現在のサブスクリプションに対して、認証され、読み取りアクセス許可を持つロールを持っている必要があります。</p></blockquote><h2 id="全てのサービスタグを表示させる方法"><a href="#全てのサービスタグを表示させる方法" class="headerlink" title="全てのサービスタグを表示させる方法"></a>全てのサービスタグを表示させる方法</h2><p>一部のサービスタグのみしか表示されない場合、以下の手順をご確認下さい。</p><h3 id="1-読み取りアクセス許可権限が付与されているか"><a href="#1-読み取りアクセス許可権限が付与されているか" class="headerlink" title="1. 読み取りアクセス許可権限が付与されているか"></a>1. 読み取りアクセス許可権限が付与されているか</h3><p>Azure Portal からサブスクリプションへ遷移いただき、[アクセス制御 (IAM)] &gt; アクセスの確認 &gt; 対象のユーザーを検索 &gt; 割り当てられているロールを選択 &gt; JSON から、上述の 2 つの権限、または 2 つの権限を含む権限 (e.g. “Microsoft.Network/*/read”, “*“) が付与されているかご確認下さい。</p><h3 id="2-読み取りアクセス許可権限を付与する"><a href="#2-読み取りアクセス許可権限を付与する" class="headerlink" title="2. 読み取りアクセス許可権限を付与する"></a>2. 読み取りアクセス許可権限を付与する</h3><ol><li>の手順において、サービスタグの読み取りアクセス許可が無かった場合、サブスクリプションのスコープに対して、閲覧者ロールを付与する、または、カスタムロールで最小限の権限を付与したい場合、以下の 2 つの権限をカスタムロールに追加ください。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;Microsoft.Network/locations/serviceTags/read&quot;</span><br><span class="line">&quot;Microsoft.Network/locations/serviceTagDetails/read&quot;</span><br></pre></td></tr></table></figure><p>サブスクリプションのスコープに対して、閲覧者権限を付与したい場合、Azure Portal からサブスクリプションへ遷移いただき、[アクセス制御 (IAM)] &gt; [+追加] &gt; [ロールの割り当ての追加] &gt; [閲覧者]を指定し、任意のユーザー、グループに権限を付与いただけます。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/role-based-access-control/quickstart-assign-role-user-portal#grant-access">アクセス権の付与 - ロールベースのアクセス制御 | Microsoft Learn</a></p><p>カスタムロールをご利用いただいている場合、Azure Portal からサブスクリプションへ遷移いただき、[アクセス制御 (IAM)] &gt; ユーザーに付与しているカスタムロールから [編集] を押下 &gt; JSON から上記 2 つの権限を追加ください。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/role-based-access-control/custom-roles-portal#update-a-custom-role">カスタム ロールの更新 - ロールベースのアクセス制御 | Microsoft Learn</a></p><p>上記設定適用後、ロールの更新には少々お時間を要しますので、一度 Azure Portal からログアウトいただき、再ログインいただいた後、サービスタグが表示されるようになるかご確認いただければと存じます。</p><h2 id="カスタムロールのご利用について"><a href="#カスタムロールのご利用について" class="headerlink" title="カスタムロールのご利用について"></a>カスタムロールのご利用について</h2><p>Azure Portal の UI はサービスタグに関わらず、高頻度で改善/改修が行われているため、それに伴い、必要な権限が追加・変更になる場合がございます。そのため、カスタムロールで細かく権限を制御されている場合、Azure Portal の UI 変更にともなって、権限修正が必要になる可能性もございます。カスタムロールをご利用の場合には、お客様側でも十分に検証いただくと共に、修正が必要になる点も予めご認識いただきますようお願い申し上げます。</p><p>以上、ご参考になりましたら幸いでございます。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームです。&lt;/p&gt;
&lt;p&gt;Azure サービスをご利用いただく中で、Azure ロールベースのアクセス制御 (RBAC) を利用し、必要な権限をユーザーに付与し、運用いただいているお客様も多いかと存じます。その中で、Azure</summary>
      
    
    
    
    
    <category term="Network" scheme="https://jpaztech.github.io/blog/tags/Network/"/>
    
    <category term="Network Security Group" scheme="https://jpaztech.github.io/blog/tags/Network-Security-Group/"/>
    
    <category term="Service Tag" scheme="https://jpaztech.github.io/blog/tags/Service-Tag/"/>
    
    <category term="RBAC" scheme="https://jpaztech.github.io/blog/tags/RBAC/"/>
    
  </entry>
  
  <entry>
    <title>Artifact Streaming とは？ ACR のイメージを AKS にデプロイして試してみた</title>
    <link href="https://jpaztech.github.io/blog/containers/aks-artifact-streaming/"/>
    <id>https://jpaztech.github.io/blog/containers/aks-artifact-streaming/</id>
    <published>2023-12-24T03:00:00.000Z</published>
    <updated>2024-02-16T07:05:26.138Z</updated>
    
    <content type="html"><![CDATA[<p>この記事は <a href="https://qiita.com/advent-calendar/2023/microsoft-azure-tech">Microsoft Azure Tech Advent Calendar 2023</a> の 24 日目の記事になります🎅</p><p>こんにちは。Azure テクニカル サポートチームの桐井です。</p><p><a href="https://techcommunity.microsoft.com/t5/apps-on-azure-blog/aks-welcomes-you-to-ignite-2023/ba-p/3983317">Ignite 2023</a> で、ACR/AKS 関連の機能としてArtifact Streaming が発表されました。<br>本記事では、Artifact Streaming を使って ACR にあるコンテナー イメージを AKS クラスターにデプロイする様子を紹介します。</p><p>Artifact Streaming は 2023/12 現在、プレビュー機能として提供されております。<br>今後のアップデートにより、将来この記事で紹介した内容から変更される可能性があることを何卒ご了承ください！</p><span id="more"></span><h2 id="Artifact-Streaming-とは"><a href="#Artifact-Streaming-とは" class="headerlink" title="Artifact Streaming とは"></a>Artifact Streaming とは</h2><blockquote><p>ご参考) Public preview: Artifact streaming support in Azure Kubernetes Service (AKS)<br><a href="https://azure.microsoft.com/ja-jp/updates/public-review-artifact-streaming-support-in-azure-kubernetes-service-aks/">https://azure.microsoft.com/ja-jp/updates/public-review-artifact-streaming-support-in-azure-kubernetes-service-aks/</a></p></blockquote><p>コンテナー イメージは、データの実体を表す複数の<code>レイヤー</code>と、イメージに含まれるレイヤーの情報をまとめた<code>マニフェスト</code>によって構成されています。</p><p>通常、コンテナー化されたアプリケーションを起動するには、コンテナー イメージの Pull (ダウンロードと展開) が必要になります。<br>イメージの Pull では次のような処理が行われます:</p><ol><li>コンテナー レジストリにアクセスし、マニフェストからレイヤーの情報を取得する</li><li>レイヤーのダウンロードが必要か確認する (ローカル キャッシュが利用できるか確認する)</li><li>各レイヤーをダウンロードする</li><li>ダウンロード済みのレイヤーを展開する</li><li>コンテナーを起動する</li></ol><p>このように、コンテナーの起動に至るまでには、イメージを構成するレイヤーのダウンロードと展開の処理が必要となります。<br>そのため、レイヤーのデータ サイズが大きい場合や、レイヤー数が多いコンテナー イメージの場合は、コンテナーが起動するまでに時間を要すことがあります。</p><p>特に、Pod のオートスケールをするシナリオでは、Pod の起動時間がオートスケールの速度に影響を与えます。</p><p>また、クラスター オートスケーラーによってノードが削減され、その後新規ノードが追加された場合には、ノード内のコンテナー イメージのキャッシュが利用できません (AKS ではノードプールの <a href="https://learn.microsoft.com/ja-jp/azure/aks/scale-down-mode">スケールダウン モード</a>が <code>Delete</code> の場合)。<br>新規ノードでは、コンテナー イメージのダウンロードと展開が再び必要となってしまうため、Pod の起動完了までに時間を要する要因となってしまいます。</p><p>これらの問題は、Artifact Streaming を利用することで、解決を図ることができます。<br>Artifact Streaming を利用すると、コンテナー イメージ全体のダウンロードと展開を待つことなく、コンテナーを開始できます。</p><h2 id="Artifact-Streaming-を試してみよう"><a href="#Artifact-Streaming-を試してみよう" class="headerlink" title="Artifact Streaming を試してみよう"></a>Artifact Streaming を試してみよう</h2><p>実際に AKS クラスターへコンテナー イメージをデプロイして、Artifact Streaming によってイメージの Pull 時間が変化するかを試してみましょう。</p><p>今回の検証では、コンテナー イメージとして <code>docker.io/jupyter/all-spark-notebook:latest</code> を使用します。<br>AKS にデプロイをする前に、まずは手元の PC でイメージの Pull を試してみます。<br>次のように、多数のレイヤーによって構成されているコンテナー イメージであることがわかります。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull docker.io/jupyter/all-spark-notebook:latest</span></span><br><span class="line">latest: Pulling from jupyter/all-spark-notebook</span><br><span class="line">aece8493d397: Pull complete</span><br><span class="line">fd92c719666c: Pull complete</span><br><span class="line">088f11eb1e74: Pull complete</span><br><span class="line">4f4fb700ef54: Pull complete</span><br><span class="line">ef8373d600b0: Pull complete</span><br><span class="line">77e45ee945dc: Pull complete</span><br><span class="line">a30f89a0af6c: Download complete</span><br><span class="line">dc42adc7eb73: Download complete</span><br><span class="line">abaa8376a650: Downloading [==&gt;                                                ]  4.314MB/104.8MB</span><br><span class="line">aa099bb9e49a: Download complete</span><br><span class="line">822c4cbcf6a6: Download complete</span><br><span class="line">d25166dcdc7b: Downloading [====&gt;                                              ]  2.494MB/30.5MB</span><br><span class="line">964fc3e4ff9f: Waiting</span><br><span class="line">2c4c69587ee4: Waiting</span><br><span class="line">de2cdd875fa8: Waiting</span><br><span class="line">75d33599f5f2: Waiting</span><br><span class="line">31973ea82470: Waiting</span><br><span class="line">96ee7e4439c7: Waiting</span><br><span class="line">1f9ad23c07ac: Waiting</span><br><span class="line">d19266e0cb17: Waiting</span><br><span class="line">9a165b6e9dc7: Pulling fs layer</span><br><span class="line">5689442fd4e1: Pulling fs layer</span><br><span class="line">9a6a202f62a6: Waiting</span><br><span class="line">734ea0c3d94e: Waiting</span><br><span class="line">a21a167f7127: Waiting</span><br><span class="line">467e20fcd668: Waiting</span><br><span class="line">7024bb03412a: Waiting</span><br><span class="line">7c128e9d2ddd: Waiting</span><br><span class="line">80782ae10995: Waiting</span><br><span class="line">691924032e73: Waiting</span><br><span class="line">05c5a5d9ae5f: Waiting</span><br><span class="line">15a3d66e1b80: Waiting</span><br><span class="line">688c0dcd61fc: Waiting</span><br><span class="line">ed7d16094f4e: Waiting</span><br></pre></td></tr></table></figure><h3 id="Artifact-Streaming-を使用する準備"><a href="#Artifact-Streaming-を使用する準備" class="headerlink" title="Artifact Streaming を使用する準備"></a>Artifact Streaming を使用する準備</h3><p>本記事の手順は、次のドキュメントに記載されている手順に沿っています。<br>ドキュメントをあわせてご参照ください。</p><blockquote><p>Azure Kubernetes Service (AKS) の成果物ストリーミングを使用してイメージのプル時間を短縮する (プレビュー)<br><a href="https://learn.microsoft.com/ja-jp/azure/aks/artifact-streaming">https://learn.microsoft.com/ja-jp/azure/aks/artifact-streaming</a></p></blockquote><p>Artifact Streaming を利用するために、Azure Container Registry (ACR) のリポジトリを設定していきます。</p><p>はじめに、今回利用するコンテナーイメージを ACR にインポートします。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az acr import -n &#123;ACR_NAME&#125; \</span></span><br><span class="line"><span class="bash">    --<span class="built_in">source</span> docker.io/jupyter/all-spark-notebook:latest \</span></span><br><span class="line"><span class="bash">    -t jupyter/all-spark-notebook:latest</span></span><br></pre></td></tr></table></figure><p>イメージのインポートが完了したら、Artifact Streaming を作成します。<br>作成にはしばらく時間がかかります。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az acr artifact-streaming create -n &#123;ACR_NAME&#125; \</span></span><br><span class="line"><span class="bash">    --image jupyter/all-spark-notebook:latest</span></span><br></pre></td></tr></table></figure><p><code>az acr artifact-streaming create</code> コマンドを実行すると、作成の進捗を確認するためのコマンド例が表示されます。<br><code>az acr artifact-streaming operation show</code> コマンドで進捗が確認できます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az acr artifact-streaming operation show -n &#123;ACR_NAME&#125; \</span></span><br><span class="line"><span class="bash">    --repository jupyter/all-spark-notebook \</span></span><br><span class="line"><span class="bash">    --id d7ea8de0-1810-48a1-b9b8-ed7f667ae1f6</span></span><br><span class="line"></span><br><span class="line">Command group &#x27;acr artifact-streaming&#x27; is in preview and under development. Reference and support levels: https://aka.ms/CLI_refstatus</span><br><span class="line">&#123;</span><br><span class="line">  &quot;details&quot;: &quot;Conversion ongoing for resource jupyter/all-spark-notebook@sha256:b63bae2d9d34779ac969deeb4834efd838991f77269ca9a76bf6b0d1f8678d29&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;ArtifactStreamingConversion&quot;,</span><br><span class="line">  &quot;progress&quot;: &quot;8%&quot;,</span><br><span class="line">  &quot;resource&quot;: &quot;jupyter/all-spark-notebook@sha256:b63bae2d9d34779ac969deeb4834efd838991f77269ca9a76bf6b0d1f8678d29&quot;,</span><br><span class="line">  &quot;startTime&quot;: &quot;2023-12-07T07:27:12Z&quot;,</span><br><span class="line">  &quot;status&quot;: &quot;Running&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Artifact Streaming の作成が完了したら、レジストリに存在する Artifact Streaming の一覧を確認してみましょう。<br><code>az acr manifest list-referrers</code> コマンドに、レジストリ名とイメージ名を指定して実行します。<br><code>&quot;artifactType&quot;</code> が <code>&quot;application/vnd.azure.artifact.streaming.v1&quot;</code> となっていますね。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az acr manifest list-referrers -r &#123;ACR_NAME&#125; \</span></span><br><span class="line"><span class="bash">    -n jupyter/all-spark-notebook:latest</span></span><br><span class="line"></span><br><span class="line">Command group &#x27;acr manifest&#x27; is in preview and under development. Reference and support levels: https://aka.ms/CLI_refstatus</span><br><span class="line">&#123;</span><br><span class="line">  &quot;manifests&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;annotations&quot;: &#123;</span><br><span class="line">        &quot;streaming.format&quot;: &quot;overlaybd&quot;,</span><br><span class="line">        &quot;streaming.platform.arch&quot;: &quot;amd64&quot;,</span><br><span class="line">        &quot;streaming.platform.os&quot;: &quot;linux&quot;,</span><br><span class="line">        &quot;streaming.version&quot;: &quot;v1&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;artifactType&quot;: &quot;application/vnd.azure.artifact.streaming.v1&quot;,</span><br><span class="line">      &quot;digest&quot;: &quot;sha256:2cba83dae18f99b6c958e9e34421dadaeee0db1cde4adc0241180de80efd4f34&quot;,</span><br><span class="line">      &quot;mediaType&quot;: &quot;application/vnd.oci.image.manifest.v1+json&quot;,</span><br><span class="line">      &quot;size&quot;: 17266</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>続いて AKS 側の設定をします。<br>Artifact Streaming を利用するには、Artifact Streaming オプションを有効化した AKS ノードプールが必要になります。</p><p><code>az aks nodepool add</code> コマンドに <code>--enable-artifact-streaming</code> オプションを付与して、新しいノードプールを追加します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az aks nodepool add \</span></span><br><span class="line"><span class="bash">    --resource-group myResourceGroup \</span></span><br><span class="line"><span class="bash">    --cluster-name myAKSCluster \</span></span><br><span class="line"><span class="bash">    --name acrtest \</span></span><br><span class="line"><span class="bash">    --node-count 1 \</span></span><br><span class="line"><span class="bash">    --enable-artifact-streaming</span></span><br></pre></td></tr></table></figure><p>ここでは <code>acrtest</code> という名前でノードプールを追加しました。<br><code>kubectl get nodes</code> コマンドでノードの一覧を表示すると、新しいノードが追加されていることが確認できます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get nodes</span></span><br><span class="line">NAME                                STATUS   ROLES   AGE     VERSION</span><br><span class="line">aks-acrtest-29138108-vmss000000     Ready    agent   4h15m   v1.27.3</span><br><span class="line">aks-nodepool2-20356098-vmss00001d   Ready    agent   27h     v1.27.3</span><br></pre></td></tr></table></figure><p>これで ACR と AKS の準備は完了です！</p><h3 id="AKS-へのデプロイを試してみる"><a href="#AKS-へのデプロイを試してみる" class="headerlink" title="AKS へのデプロイを試してみる"></a>AKS へのデプロイを試してみる</h3><p>準備したコンテナー イメージを AKS クラスターにデプロイして、Artifact Streaming によってイメージの Pull 時間が短縮されているか確かめてみましょう。</p><p>検証では、Artifact Streaming が無効のノードプールと、有効のノードプールのそれぞれに、同じコンテナー イメージを使用する Deployment をデプロイします。</p><h4 id="Artifact-Streaming-が無効の場合"><a href="#Artifact-Streaming-が無効の場合" class="headerlink" title="Artifact Streaming が無効の場合"></a>Artifact Streaming が無効の場合</h4><p><code>nodeSelector</code> を使用して、Artifact Streaming が無効のノードプールに Pod をデプロイします。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">jupyter</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">jupyter</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">jupyter</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">jupyter</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">&quot;agentpool&quot;:</span> <span class="string">nodepool2</span>  <span class="comment"># Artifact Streaming が無効のノードプール</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">jupyter</span></span><br><span class="line">        <span class="attr">image:</span> &#123;<span class="string">ACR_NAME</span>&#125;<span class="string">.azurecr.io/jupyter/all-spark-notebook:latest</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br></pre></td></tr></table></figure><p>YAML マニフェストをクラスターにデプロイします。<br><code>jupyter-79c4469c65-5cfpf</code> Pod が生成されました。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -o wide</span></span><br><span class="line">NAME                                          READY   STATUS    RESTARTS   AGE     IP            NODE                                NOMINATED NODE   READINESS GATES</span><br><span class="line">jupyter-79c4469c65-5cfpf                      1/1     Running   0          3m16s   10.244.0.19   aks-nodepool2-20356098-vmss00001i   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p><code>kubectl describe pod</code> コマンドの結果から、Events フィールドのメッセージを確認します。</p><p><code>Pulled</code> イベントでは、<code>Successfully pulled image &quot;&#123;イメージ名&#125;&quot; in 1m25.27926119s</code> のようにメッセージが表示されています。<br>イメージの Pull に 1分25秒 ほど要したようです。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod jupyter-79c4469c65-5cfpf</span></span><br><span class="line">Name:             jupyter-79c4469c65-5cfpf</span><br><span class="line">  ...</span><br><span class="line">Node:             aks-nodepool2-20356098-vmss00001i/10.240.0.4</span><br><span class="line">  ...</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age    From               Message</span><br><span class="line">  ----    ------     ----   ----               -------</span><br><span class="line">  Normal  Scheduled  3m25s  default-scheduler  Successfully assigned default/jupyter-79c4469c65-5cfpf to aks-nodepool2-20356098-vmss00001i</span><br><span class="line">  Normal  Pulling    3m25s  kubelet            Pulling image &quot;&#123;ACR_NAME&#125;.azurecr.io/jupyter/all-spark-notebook:latest&quot;</span><br><span class="line">  Normal  Pulled     2m     kubelet            Successfully pulled image &quot;&#123;ACR_NAME&#125;.azurecr.io/jupyter/all-spark-notebook:latest&quot; in 1m25.27926119s (1m25.279277391s including waiting)</span><br><span class="line">  Normal  Created    2m     kubelet            Created container jupyter</span><br><span class="line">  Normal  Started    119s   kubelet            Started container jupyter</span><br></pre></td></tr></table></figure><h4 id="Artifact-Streaming-が有効の場合"><a href="#Artifact-Streaming-が有効の場合" class="headerlink" title="Artifact Streaming が有効の場合"></a>Artifact Streaming が有効の場合</h4><p>続いて Artifact Streaming を利用した場合の動作を確認してみましょう。</p><p><code>nodeSelector</code> を使用して、Artifact Streaming が有効のノードプールに Pod をデプロイします。<br>Pod 名やコンテナー名を変更していますが、使用するコンテナー イメージは先ほどと同じ <code>&#123;ACR_NAME&#125;.azurecr.io/jupyter/all-spark-notebook:latest</code> です。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">jupyter-artifact-streaming</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">jupyter-artifact-streaming</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">jupyter-artifact-streaming</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">jupyter-artifact-streaming</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">&quot;agentpool&quot;:</span> <span class="string">acrtest</span>  <span class="comment"># Artifact Streaming が有効のノードプール</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">jupyter</span></span><br><span class="line">        <span class="attr">image:</span> &#123;<span class="string">ACR_NAME</span>&#125;<span class="string">.azurecr.io/jupyter/all-spark-notebook:latest</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br></pre></td></tr></table></figure><p>YAML マニフェストをクラスターにデプロイします。<br><code>jupyter-artifact-streaming-5b58c9c797-pxs4l</code> Pod が生成されました。デプロイ先を指定したので、<code>acrtest</code>ノードプールのノードにデプロイされていますね。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -o wide</span></span><br><span class="line">NAME                                          READY   STATUS    RESTARTS   AGE     IP            NODE                                NOMINATED NODE   READINESS GATES</span><br><span class="line">jupyter-79c4469c65-c8hm6                      1/1     Running   0          2m10s   10.244.1.24   aks-nodepool2-20356098-vmss00001d   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">jupyter-artifact-streaming-5b58c9c797-pxs4l   1/1     Running   0          6s      10.244.2.5    aks-acrtest-29138108-vmss000000     &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p><code>kubectl describe pod</code> コマンドの結果から、Events フィールドのメッセージを確認します。</p><p><code>Pulling</code> イベントでは、<code>Streaming enabled for &quot;&#123;イメージ名&#125;&quot;</code> のようにメッセージが表示されており、Artifact Streaming が利用されていることが確認できます。</p><p>また、<code>Pulled</code> イベントでは、<code>Successfully pulled image &quot;&#123;イメージ名&#125;&quot; in 3.442267417s</code> のようにメッセージが表示されています。<br>およそ 3.44 秒ほどでイメージ Pull が完了しました！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod jupyter-artifact-streaming-5b58c9c797-pxs4l</span></span><br><span class="line">Name:             jupyter-artifact-streaming-5b58c9c797-pxs4l</span><br><span class="line">  ...</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age        From                                                   Message</span><br><span class="line">  ----    ------     ----       ----                                                   -------</span><br><span class="line">  Normal  Pulling    &lt;unknown&gt;  acr-nodemon, kubelet, aks-acrtest-29138108-vmss000000  Streaming enabled for &quot;&#123;ACR_NAME&#125;.azurecr.io/jupyter/all-spark-notebook:latest&quot;, upgraded to streaming artifact with digest &quot;sha256:2cba83dae18f99b6c958e9e34421dadaeee0db1cde4adc0241180de80efd4f34&quot;, container started in 5s</span><br><span class="line">  Normal  Scheduled  19s        default-scheduler                                      Successfully assigned default/jupyter-artifact-streaming-5b58c9c797-pxs4l to aks-acrtest-29138108-vmss000000</span><br><span class="line">  Normal  Pulling    19s        kubelet                                                Pulling image &quot;&#123;ACR_NAME&#125;.azurecr.io/jupyter/all-spark-notebook:latest&quot;</span><br><span class="line">  Normal  Pulled     15s        kubelet                                                Successfully pulled image &quot;&#123;ACR_NAME&#125;.azurecr.io/jupyter/all-spark-notebook:latest&quot; in 3.442267417s (3.442273818s including waiting)</span><br><span class="line">  Normal  Created    14s        kubelet                                                Created container jupyter</span><br><span class="line">  Normal  Started    14s        kubelet                                                Started container jupyter</span><br></pre></td></tr></table></figure><p>Artifact Streaming を使わない場合では 1分25秒 ほど要したため、大幅に短縮されていますね！</p><h3 id="Artifact-Streaming-を削除するには？"><a href="#Artifact-Streaming-を削除するには？" class="headerlink" title="Artifact Streaming を削除するには？"></a>Artifact Streaming を削除するには？</h3><p><code>az acr artifact-streaming delete</code> というコマンドは存在しないようです。</p><p>作成した Artifact Streaming を削除したい場合には、リポジトリに存在するイメージ自体を削除します。<br>イメージの削除にともない Artifact Streaming も一緒に削除されます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az acr repository delete -n &#123;ACR_NAME&#125; --repository jupyter/all-spark-notebook</span></span><br></pre></td></tr></table></figure><h3 id="どのようなしくみなのか？"><a href="#どのようなしくみなのか？" class="headerlink" title="どのようなしくみなのか？"></a>どのようなしくみなのか？</h3><p>Artifact Streaming を使うと、なぜイメージ Pull の時間が短縮されるのでしょうか？</p><p>Artifact Streaming では、OverlayBD イメージ フォーマットというオープンソースのソリューションを利用しています。</p><blockquote><p>ご参考) containerd/overlaybd<br><a href="https://github.com/containerd/overlaybd">https://github.com/containerd/overlaybd</a></p></blockquote><blockquote><p>ご参考) containerd/accelerated-container-image<br><a href="https://github.com/containerd/accelerated-container-image">https://github.com/containerd/accelerated-container-image</a></p></blockquote><p>OverlayBD は、アリババクラウドのコンテナーイメージ加速技術プロジェクト DADI で開発されました。</p><blockquote><p>DADI: Alibaba Cloud’s Open-Source Accelerated Container Image Technology<br><a href="https://www.alibabacloud.com/blog/dadi-alibaba-clouds-open-source-accelerated-container-image-technology_597956">https://www.alibabacloud.com/blog/dadi-alibaba-clouds-open-source-accelerated-container-image-technology_597956</a></p></blockquote><p>OverlayBD は、コンテナー イメージのレイヤーを仮想ブロック デバイスとして提供し、オーバーレイ ファイルシステムとしてマウントします。<br>コンテナーは、オーバーレイ ファイルシステムを通してイメージのデータにアクセスをします。<br>コンテナーの起動前にイメージ全体をダウンロードや展開することなく、必要なデータのみをネットワーク経由でオンデマンドに読み込むことができます。</p><p>ネットワーク ドライブに保存されたファイルを、手元のマシンに一度ダウンロードしてから開くのではなく、SMB/CIFS でマウントして直接開く様子に似ていますね。</p><p>Pod がデプロイされたノードにログインし、<code>df</code> コマンドを実行すると、出力結果の中に <code>io.containerd.snapshotter.v1.overlaybd</code> の文字列が含まれていることが確認できます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@aks-acrtest-29138108-vmss000000:/# df -h | grep overlaybd</span><br><span class="line">/dev/sdc        252G  5.6G  234G   3% /var/lib/containerd/io.containerd.snapshotter.v1.overlaybd/snapshots/239/block/mountpoint</span><br></pre></td></tr></table></figure><hr><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>本記事では、Artifact Streaming の概要と、実際に AKS クラスターへコンテナーをデプロイした様子を紹介しました。<br>サイズの大きいコンテナー イメージを使用する Pod で起動時間を短縮したい場合に、利用を検討してみると良さそうです。</p><p>今回紹介しました Artifact Streaming が、今後の技術選定や AKS をよりご活用いただくうえでのご参考になりましたら幸いです。</p><p>Artifact Streaming は2023年12月現在、パブリック プレビューとして提供されております。ご利用いただきました際にお気づきの点やご要望などがございました際は、お気兼ねなくフィードバックいただけましたら幸いでございます。<br>また、AKS のご利用において、お困りの点やご不明点がありました際は、いつでも Azure サポートまでお気兼ねなくご相談ください。</p><hr><p>最後まで読んでいただきありがとうございました！<br><a href="https://qiita.com/advent-calendar/2023/microsoft-azure-tech">Microsoft Azure Tech Advent Calendar 2023</a> は明日が最終日となります。是非ご覧くださいー！</p><p>本年は多くのお客様にお世話になりました。ありがとうございました。<br>来年もみなさまにとって素晴らしい年でありますように、心よりお祈り申し上げます。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;この記事は &lt;a href=&quot;https://qiita.com/advent-calendar/2023/microsoft-azure-tech&quot;&gt;Microsoft Azure Tech Advent Calendar 2023&lt;/a&gt; の 24 日目の記事になります🎅&lt;/p&gt;
&lt;p&gt;こんにちは。Azure テクニカル サポートチームの桐井です。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://techcommunity.microsoft.com/t5/apps-on-azure-blog/aks-welcomes-you-to-ignite-2023/ba-p/3983317&quot;&gt;Ignite 2023&lt;/a&gt; で、ACR/AKS 関連の機能としてArtifact Streaming が発表されました。&lt;br&gt;本記事では、Artifact Streaming を使って ACR にあるコンテナー イメージを AKS クラスターにデプロイする様子を紹介します。&lt;/p&gt;
&lt;p&gt;Artifact Streaming は 2023/12 現在、プレビュー機能として提供されております。&lt;br&gt;今後のアップデートにより、将来この記事で紹介した内容から変更される可能性があることを何卒ご了承ください！&lt;/p&gt;</summary>
    
    
    
    
    <category term="Containers" scheme="https://jpaztech.github.io/blog/tags/Containers/"/>
    
    <category term="Azure Kubernetes Service (AKS)" scheme="https://jpaztech.github.io/blog/tags/Azure-Kubernetes-Service-AKS/"/>
    
    <category term="Azure Container Registry (ACR)" scheme="https://jpaztech.github.io/blog/tags/Azure-Container-Registry-ACR/"/>
    
  </entry>
  
  <entry>
    <title>ACR の Firewall 機能を有効にした状態で ACR の機能を用いてコンテナー イメージをビルドする方法について</title>
    <link href="https://jpaztech.github.io/blog/containers/acr-how-to-build-image-with-firewall/"/>
    <id>https://jpaztech.github.io/blog/containers/acr-how-to-build-image-with-firewall/</id>
    <published>2023-12-22T03:00:00.000Z</published>
    <updated>2024-02-16T07:05:26.130Z</updated>
    
    <content type="html"><![CDATA[<p>この記事は<a href="https://qiita.com/advent-calendar/2023/microsoft-azure-tech">Microsoft Azure Tech Advent Calendar 2023</a> の 22 日目の記事になります。</p><p>こんにちは！ Azure テクニカル サポート チームの川畑です。<br>az acr buildコマンドを用いてコンテナー イメージをビルドする際に、ACR の Firewall 機能によって失敗するお問い合わせを頂きます。<br>この記事では、ACR のFirewall 機能を有効にした状態で ACR の機能を用いてコンテナー イメージをビルドする方法についてご紹介します。</p><span id="more"></span><hr><h2 id="ACR-のパブリック-ネットワーク-アクセス機能とは"><a href="#ACR-のパブリック-ネットワーク-アクセス機能とは" class="headerlink" title="ACR のパブリック ネットワーク アクセス機能とは"></a>ACR のパブリック ネットワーク アクセス機能とは</h2><p>ACR では、お客様のコンテナー イメージなど OCI アーティファクトをより安全に管理いただくために、ACR にアクセス可能な端末を制限するためのパブリック ネットワーク アクセス機能を提供しております。<br>パブリック ネットワーク アクセスの設定には、次の3 種類があります。</p><ul><li><p>「すべてのネットワーク」<br>名前の通りネットワーク レベルでの制限を実施いたしません。<br>そのため、インターネット経由でのアクセスを受け付けることが可能となります。</p></li><li><p>「選択されたネットワーク」<br>ACR の Firewall 機能を用いて、IP アドレス ベースでのアクセス制限を設けることが可能となります。<br>なお、ここで許可可能な IP アドレスの形式は CIDR 形式となっているため、IP アドレス レンジを許可することなども可能となります。</p><div class="alert is-warning"><p class="alert-title">警告</p><p>許可可能な IP 規則は最大 100 個までとなります。</br></p><p>　ご参考情報：パブリック IP ネットワーク ルールを構成する </br></p><p>　<a href="https://learn.microsoft.com/ja-jp/azure/container-registry/container-registry-access-selected-networks">https://learn.microsoft.com/ja-jp/azure/container-registry/container-registry-access-selected-networks</a> </br></p></div><div class="alert is-warning"><p class="alert-title">警告</p><p>この設定を入れることによって、Azure Portal からリポジトリの情報を参照できなくなる 場合があります。</br></p><p>これは、Azure Portal を用いて ACR へアクセスしているクライアント端末の IP アドレスが許可されていないためとなります。</br></p><p>そのため、Azure Portal より ACR 内の情報を参照する必要がある場合には、クライアント端末のパブリック IP アドレスを許可してください。</p></div></li><li><p>「無効」<br>名前の通りパブリック IP アドレス経由でのアクセスを全て防ぐことが可能となります。<br>この設定だけでは、ACR にアクセス可能な端末が存在しなくなるため、あわせてプライベート エンドポイントを経由したアクセスを可能なように構成いただく必要があります。<br>下記ドキュメントに設定方法がまとまっておりますので、あわせてご参照ください。<br>　ご参考情報：Azure Private Link を使用して Azure Container Registry にプライベートで接続する<br>　<a href="https://learn.microsoft.com/ja-jp/azure/container-registry/container-registry-private-link">https://learn.microsoft.com/ja-jp/azure/container-registry/container-registry-private-link</a></p></li></ul><h2 id="ACR-ビルドとは"><a href="#ACR-ビルドとは" class="headerlink" title="ACR ビルドとは"></a>ACR ビルドとは</h2><p>ACR ビルドとは、お客様のクライアント端末上ではなく、Azure が管理している各リージョンに存在する ACR 用のエージェントを用いてコンテナー イメージを作成する機能となります。</p><p>この機能を用いることで、お客様のクライアント端末にて Docker などのコンテナー ランタイムをインストールすることなく、Azure が用意しているエージェントを用いてコンテナー イメージを作成、ACR へプッシュすることが出来ます。</p><p>下記 は ACR ビルドの実行結果の一例となります。<br>今回の例では、 外部のコンテナー レジストリー (mcr.microsoft.com) より hello-world というコンテナー イメージを取得し、起動する Docker イメージを作成、ACR へプッシュします。</p><p>まずは、Docker イメージを作成するために Dockerfile を用意します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;FROM mcr.microsoft.com/hello-world&quot;</span> &gt; Dockerfile</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat Dockerfile</span> </span><br><span class="line">FROM mcr.microsoft.com/hello-world</span><br></pre></td></tr></table></figure><p>それでは、この Dockerfile を基に ACR ビルドを使って Docker イメージの作成、ACR へプッシュを行います。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az acr build --registry blogbuildtest --image buildtest/hello-world:v1 --file Dockerfile .</span></span><br><span class="line">Packing source code into tar to upload...</span><br><span class="line">Uploading archived source code from &#x27;/tmp/build_archive_6d41a3f0c1e24e1cbac736d1b271ad6c.tar.gz&#x27;...</span><br><span class="line">Sending context (345.000 Bytes) to registry: blogbuildtest...</span><br><span class="line">Queued a build with ID: ca1</span><br><span class="line">Waiting for an agent...</span><br><span class="line">2023/12/11 05:16:49 Downloading source code...</span><br><span class="line">2023/12/11 05:16:49 Finished downloading source code</span><br><span class="line">2023/12/11 05:16:50 Using acb_vol_4cfc16ec-0963-4b43-8581-f87207679198 as the home volume</span><br><span class="line">2023/12/11 05:16:50 Setting up Docker configuration...</span><br><span class="line">2023/12/11 05:16:50 Successfully set up Docker configuration</span><br><span class="line">2023/12/11 05:16:50 Logging in to registry: blogbuildtest.azurecr.io</span><br><span class="line">2023/12/11 05:16:51 Successfully logged into blogbuildtest.azurecr.io</span><br><span class="line">2023/12/11 05:16:51 Executing step ID: build. Timeout(sec): 28800, Working directory: &#x27;&#x27;, Network: &#x27;&#x27;</span><br><span class="line">2023/12/11 05:16:51 Scanning for dependencies...</span><br><span class="line">2023/12/11 05:16:51 Successfully scanned dependencies</span><br><span class="line">2023/12/11 05:16:51 Launching container with name: build</span><br><span class="line">Sending build context to Docker daemon  3.072kB</span><br><span class="line">Step 1/1 : FROM mcr.microsoft.com/hello-world</span><br><span class="line">latest: Pulling from hello-world</span><br><span class="line">1b930d010525: Pulling fs layer</span><br><span class="line">1b930d010525: Verifying Checksum</span><br><span class="line">1b930d010525: Download complete</span><br><span class="line">1b930d010525: Pull complete</span><br><span class="line">Digest: sha256:92c7f9c92844bbbb5d0a101b22f7c2a7949e40f8ea90c8b3bc396879d95e899a</span><br><span class="line">Status: Downloaded newer image for mcr.microsoft.com/hello-world:latest</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> fce289e99eb9</span></span><br><span class="line">Successfully built fce289e99eb9</span><br><span class="line">Successfully tagged blogbuildtest.azurecr.io/buildtest/hello-world:v1</span><br><span class="line">2023/12/11 05:16:52 Successfully executed container: build</span><br><span class="line">2023/12/11 05:16:52 Executing step ID: push. Timeout(sec): 3600, Working directory: &#x27;&#x27;, Network: &#x27;&#x27;</span><br><span class="line">2023/12/11 05:16:52 Pushing image: blogbuildtest.azurecr.io/buildtest/hello-world:v1, attempt 1</span><br><span class="line">The push refers to repository [blogbuildtest.azurecr.io/buildtest/hello-world]</span><br><span class="line">af0b15c8625b: Preparing</span><br><span class="line">af0b15c8625b: Pushed</span><br><span class="line">v1: digest: sha256:92c7f9c92844bbbb5d0a101b22f7c2a7949e40f8ea90c8b3bc396879d95e899a size: 524</span><br><span class="line">2023/12/11 05:16:54 Successfully pushed image: blogbuildtest.azurecr.io/buildtest/hello-world:v1</span><br><span class="line">2023/12/11 05:16:54 Step ID: build marked as successful (elapsed time in seconds: 1.093391)</span><br><span class="line">2023/12/11 05:16:54 Populating digests for step ID: build...</span><br><span class="line">2023/12/11 05:16:54 Successfully populated digests for step ID: build</span><br><span class="line">2023/12/11 05:16:54 Step ID: push marked as successful (elapsed time in seconds: 1.829038)</span><br><span class="line">2023/12/11 05:16:54 The following dependencies were found:</span><br><span class="line">2023/12/11 05:16:54 </span><br><span class="line">- image:</span><br><span class="line">    registry: blogbuildtest.azurecr.io</span><br><span class="line">    repository: buildtest/hello-world</span><br><span class="line">    tag: v1</span><br><span class="line">    digest: sha256:92c7f9c92844bbbb5d0a101b22f7c2a7949e40f8ea90c8b3bc396879d95e899a</span><br><span class="line">  runtime-dependency:</span><br><span class="line">    registry: mcr.microsoft.com</span><br><span class="line">    repository: hello-world</span><br><span class="line">    tag: latest</span><br><span class="line">    digest: sha256:92c7f9c92844bbbb5d0a101b22f7c2a7949e40f8ea90c8b3bc396879d95e899a</span><br><span class="line">  git: &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Run ID: ca1 was successful after 6s</span><br></pre></td></tr></table></figure><p>しかしながら、上述の通り、ACR ビルドは Azure にて管理している各リージョンに存在する ACR 用のエージェントによってコンテナー イメージの作成、ACR へのプッシュをする機能であるため、<strong>ACR 用のエージェントからお客様の ACR へのアクセス</strong>が行われます。</p><p>このアクセスには、パブリック IP アドレスが使われているため、ACR の Firewall 機能を用いてパブリック アクセスを防がれている ACR へのアクセスが失敗することが予想されます。</p><p>試しに Azure VM を用意し、この Azure VM が利用しているパブリック IP アドレスを ACR の Firewall 機能によって許可します。</p><p>この設定の場合、Azure VM から ACR への通信は成功するため、ACR からコンテナー イメージの取得等は実行できますが、ACR ビルドは失敗します。</p><p>作成した Azure VM は以下の通りであり、割り当てられたパブリック IP アドレスは 4.xxx.xxx.xxx となります。</p><p><img src="/blog/containers/acr-how-to-build-image-with-firewall/vm_information.png"><br>それでは、この IP アドレスを ACR の Firewall 機能で許可します。</p><p><img src="/blog/containers/acr-how-to-build-image-with-firewall/acr_information.png"><br>では、Azure VM に SSH をして、Docker イメージを ACR から取得してみます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker pull blogbuildtest.azurecr.io/buildtest/hello-world:v1</span></span><br><span class="line">v1: Pulling from buildtest/hello-world</span><br><span class="line">1b930d010525: Pull complete</span><br><span class="line">Digest: sha256:92c7f9c92844bbbb5d0a101b22f7c2a7949e40f8ea90c8b3bc396879d95e899a</span><br><span class="line">Status: Downloaded newer image for blogbuildtest.azurecr.io/buildtest/hello-world:v1</span><br><span class="line">blogbuildtest.azurecr.io/buildtest/hello-world:v1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker images</span></span><br><span class="line">REPOSITORY                                       TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">blogbuildtest.azurecr.io/buildtest/hello-world   v1        fce289e99eb9   4 years ago   1.84kB</span><br></pre></td></tr></table></figure><p>docker pull コマンドによってコンテナー イメージを ACR から取得出来ました。<br>次に ACR ビルドを使ってコンテナー イメージの作成をしてみます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az acr build --registry blogbuildtest --image buildtestfromvm/hello-world:v1 --file Dockerfile .</span></span><br><span class="line">Packing source code into tar to upload...</span><br><span class="line">Uploading archived source code from &#x27;/tmp/build_archive_ba9f4b643e5b4b79b251d6213e8abd99.tar.gz&#x27;...</span><br><span class="line">Sending context (26.336 KiB) to registry: blogbuildtest...</span><br><span class="line">Queued a build with ID: ca2</span><br><span class="line">Waiting for an agent...</span><br><span class="line">2023/12/11 06:06:48 Downloading source code...</span><br><span class="line">2023/12/11 06:06:48 Finished downloading source code</span><br><span class="line">2023/12/11 06:06:48 Using acb_vol_f6e0b320-1247-4584-b5c3-c620a4d138e5 as the home volume</span><br><span class="line">2023/12/11 06:06:48 Setting up Docker configuration...</span><br><span class="line">2023/12/11 06:06:49 Successfully set up Docker configuration</span><br><span class="line">2023/12/11 06:06:49 Logging in to registry: blogbuildtest.azurecr.io</span><br><span class="line">failed to login, ran out of retries: failed to set docker credentials: Error response from daemon: Get &quot;https://blogbuildtest.azurecr.io/v2/&quot;: denied: client with IP &#x27;52.xxx. xxx.  xxx &#x27; is not allowed access. Refer https://aka.ms/acr/firewall to grant access.</span><br><span class="line">: exit status 1</span><br><span class="line">Run ID: ca2 failed after 5s. Error: failed during run, err: exit status 1</span><br><span class="line">Run failed</span><br></pre></td></tr></table></figure><p>予想通り Failed となることが確認できました。<br>なお、この IP アドレス 52.xxx.xxx.xxx が ACR のエージェントが利用しているパブリック IP アドレスとなり、このパブリック IP アドレスが許可されていないことから処理が失敗したことが確認できました。</p><h2 id="ACR-ビルドの代替策"><a href="#ACR-ビルドの代替策" class="headerlink" title="ACR ビルドの代替策"></a>ACR ビルドの代替策</h2><p>前置きが長くなってしまいましたが、上述のように ACR ビルドを用いてコンテナー イメージを作成する場合、ACR の Firewall 機能によってアクセスが防がれてしまう場合があります。<br>この回避策としては、以下の方法が挙げられます。</p><ol><li><p>パブリック ネットワーク アクセスの設定を「すべてのネットワーク」に変更する<br>ACR のエージェントが ACR へアクセスする際に使用しているパブリック IP アドレスが許可されていないことで本事象は発生するため、インターネットからのアクセスを全て受け付けるよう変更いただくことで事象が改善します。</p></li><li><p>ACR のエージェントが利用するパブリック IP アドレスを許可する<br>ACR のエージェントが利用するパブリック IP アドレスを「選択されたネットワーク」の IP 規則に追加する方法が挙げられます。<br>Azure では、下記サイトにて  Azure の各サービスが利用する IP アドレスを公開しているため、こちらの AzureContainerRegistry.<region> の IP アドレスを追加いただくことで事象が改善することが想定されます。<br>　ご参考情報：Download Azure IP Ranges and Service Tags – Public Cloud from Official Microsoft Download Center<br>　<a href="https://www.microsoft.com/en-us/download/confirmation.aspx?id=56519">https://www.microsoft.com/en-us/download/confirmation.aspx?id=56519</a></p><div class="alert is-warning"><p class="alert-title">警告</p><p>ACR 含め Azure が利用するパブリック IP アドレスは動的なものであり、今後変更される可能性があります。</p><p>そのため、定期的もしくはアクセスが失敗するようになりましたら、最新の ACR のパブリック IP アドレスをご確認・更新いただく必要があります。</p></div></li><li><p>ACR タスクを利用する<br>ACR の Firewall 機能では、「信頼されたサービス」のアクセスについては別途 IP 規則を追加いただくことなく、アクセスを許可することが可能となります。<br>そして、この 「信頼されたサービス」に、下記ドキュメントに記載の通り ACR タスクが登録されています。<br>　ご参考情報：信頼できるサービス<br>　<a href="https://learn.microsoft.com/ja-jp/azure/container-registry/allow-access-trusted-services#trusted-services">https://learn.microsoft.com/ja-jp/azure/container-registry/allow-access-trusted-services#trusted-services</a> </p><p>ACR タスクは、ACR ビルドの制御等を行うことができ、ACR ビルド同様にコンテナー イメージの作成を行うことが可能となります。<br>そのため、ACR ビルドの代替方法として ACR タスクをご利用いただくことで ACR の Firewall 機能でパブリック アクセスを防いだまま ACR の機能によってコンテナー イメージを作成することが可能となります。<br>次のセクションにて ACR タスクを使ったコンテナー イメージの作成方法について紹介します。</p></li></ol><h2 id="ACR-タスクのご紹介"><a href="#ACR-タスクのご紹介" class="headerlink" title="ACR タスクのご紹介"></a>ACR タスクのご紹介</h2><p>上述の通り、ACR タスクでは、ACR ビルドと同様に ACR の機能を使ってコンテナー イメージを作成することが可能となります。<br>それでは、早速 ACR タスクを使って Firewall 機能を有効化した ACR に対してコンテナー イメージの作成、プッシュをしてみます。</p><p>なお、おおまかな手順につきましては、下記ドキュメントにて記載されています。<br>こちらを参考に実施してみます。<br>　ご参考情報：例:ACR タスク<br>　<a href="https://learn.microsoft.com/ja-jp/azure/container-registry/allow-access-trusted-services#example-acr-tasks">https://learn.microsoft.com/ja-jp/azure/container-registry/allow-access-trusted-services#example-acr-tasks</a></p><p>ACR タスクを作成する前に事前準備が必要となります。</p><p>ACR ビルドでは、コンテナー イメージの作成に使用していた Dockerfile を az acr build コマンドを実行したクライアント端末に存在していましたが、ACR タスクでは ACR のエージェントにてアクセスが可能な場所に配置する必要があります。<br>ここでは、Dockerfile を ACR 上に配置し、ACR 上に配置した Dockerfile を ACR タスクより使用してコンテナー イメージを作成してみます。</p><p>ACR に Dockerfile を配置するにあたり、オープン ソースにて開発がされている ORAS を使用します。<br>簡単な使用方法につきましては、下記ドキュメントでも紹介されておりますので、ご参考ください。<br>　ご参考情報：Azure コンテナー レジストリを使って OCI 成果物をプッシュおよびプルする<br>　<a href="https://learn.microsoft.com/ja-jp/azure/container-registry/container-registry-oci-artifacts">https://learn.microsoft.com/ja-jp/azure/container-registry/container-registry-oci-artifacts</a></p><p>それでは、ORAS を使って Dockerfile を ACR にプッシュします。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> oras push blogbuildtest.azurecr.io/hello-world.dockerfile:1.0 Dockerfile</span></span><br></pre></td></tr></table></figure><p>今回は hello-world.dockerfile というリポジトリとしてプッシュしました。<br>では、この hello-world.dockerfile を用いるよう ACR タスクを作成してみます。<br>コマンドは下記のような形式となります。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az acr task create -t &lt;イメージ名&gt; --registry &lt;ACR 名&gt; --name &lt;タスク名&gt; --context oci://&lt;ACR 名&gt;.azurecr.io/&lt;Dockerfile の OCI アーティファクト名&gt;:&lt;Tag&gt;  --file &lt;Dockerfile名&gt; --assign-identity &lt;[system] | マネージド ID のリソース ID&gt; -g &lt;リソース グループ名&gt;</span></span><br></pre></td></tr></table></figure><p>今回の環境では、下記のコマンドとなります。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az acr task create -t helloworld --registry blogbuildtest --name helloworldtask  --context oci://blogbuildtest.azurecr.io/hello-world.dockerfile:1.0  --file hello-world.dockerfile --assign-identity [system]</span></span><br></pre></td></tr></table></figure><p>なお、「信頼されたサービス」を利用してアクセスを行う場合には、ACR タスクにマネージド ID を利用する必要があります。</p><p>先ほど実行したコマンドにて、今回作成した ACR タスクにはシステム割り当てマネージド ID を利用するよう設定しているため、このシステム割り当てマネージド ID に必要な権限 (ACRPUSH) を割り当てます。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> principalID=$(az acr task show --name helloworldtask --registry tasktest --query identity.principalId --output tsv -g blog)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> baseregID=$(az acr show --name blogbuildtest --query id --output tsv -g blog)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> az role assignment create --assignee <span class="variable">$principalID</span> --scope <span class="variable">$baseregID</span> --role acrpush</span></span><br></pre></td></tr></table></figure><p>次に、ACR タスク “helloworldtask” に対して  ACR “blogbuildtest” へのアクセスにマネージド ID を利用するよう設定を行います。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az acr task credential add --name helloworldtask --registry blogbuildtest --login-server blogbuildtest.azurecr.io --use-identity [system] -g blog</span></span><br></pre></td></tr></table></figure><p>これで準備は完了です。それでは、ACR タスクを実行します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az acr task run --name helloworldtask --registry blogbuildtest -g blog                                                                                              Queued a run with ID: cad</span></span><br><span class="line">Waiting for an agent...</span><br><span class="line">2023/12/14 19:29:42 Downloading source code...</span><br><span class="line">2023/12/14 19:29:45 Finished downloading source code</span><br><span class="line">2023/12/14 19:29:45 Using acb_vol_efd7cb79-502a-47b0-8e44-9689138ae1cb as the home volume</span><br><span class="line">2023/12/14 19:29:46 Setting up Docker configuration...</span><br><span class="line">2023/12/14 19:29:46 Successfully set up Docker configuration</span><br><span class="line">2023/12/14 19:29:46 Logging in to registry: blogbuildtest.azurecr.io</span><br><span class="line">2023/12/14 19:29:47 Successfully logged into blogbuildtest.azurecr.io</span><br><span class="line">2023/12/14 19:29:47 Executing step ID: build. Timeout(sec): 28800, Working directory: &#x27;&#x27;, Network: &#x27;&#x27;</span><br><span class="line">2023/12/14 19:29:47 Scanning for dependencies...</span><br><span class="line">2023/12/14 19:29:47 Successfully scanned dependencies</span><br><span class="line">2023/12/14 19:29:47 Launching container with name: build</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/1 : FROM mcr.microsoft.com/hello-world</span><br><span class="line">latest: Pulling from hello-world</span><br><span class="line">1b930d010525: Pulling fs layer</span><br><span class="line">1b930d010525: Verifying Checksum</span><br><span class="line">1b930d010525: Download complete</span><br><span class="line">1b930d010525: Pull complete</span><br><span class="line">Digest: sha256:92c7f9c92844bbbb5d0a101b22f7c2a7949e40f8ea90c8b3bc396879d95e899a</span><br><span class="line">Status: Downloaded newer image for mcr.microsoft.com/hello-world:latest</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> fce289e99eb9</span></span><br><span class="line">Successfully built fce289e99eb9</span><br><span class="line">Successfully tagged blogbuildtest.azurecr.io/helloworld:latest</span><br><span class="line">2023/12/14 19:29:48 Successfully executed container: build</span><br><span class="line">2023/12/14 19:29:48 Executing step ID: push. Timeout(sec): 3600, Working directory: &#x27;&#x27;, Network: &#x27;&#x27;</span><br><span class="line">2023/12/14 19:29:48 Pushing image: blogbuildtest.azurecr.io/helloworld:latest, attempt 1</span><br><span class="line">The push refers to repository [blogbuildtest.azurecr.io/helloworld]</span><br><span class="line">af0b15c8625b: Preparing</span><br><span class="line">af0b15c8625b: Layer already exists</span><br><span class="line">latest: digest: sha256:92c7f9c92844bbbb5d0a101b22f7c2a7949e40f8ea90c8b3bc396879d95e899a size: 524</span><br><span class="line">2023/12/14 19:29:49 Successfully pushed image: blogbuildtest.azurecr.io/helloworld:latest</span><br><span class="line">2023/12/14 19:29:49 Step ID: build marked as successful (elapsed time in seconds: 1.140930)</span><br><span class="line">2023/12/14 19:29:49 Populating digests for step ID: build...</span><br><span class="line">2023/12/14 19:29:49 Successfully populated digests for step ID: build</span><br><span class="line">2023/12/14 19:29:49 Step ID: push marked as successful (elapsed time in seconds: 0.898327)</span><br><span class="line">2023/12/14 19:29:49 The following dependencies were found:</span><br><span class="line">2023/12/14 19:29:49</span><br><span class="line">- image:</span><br><span class="line">    registry: blogbuildtest.azurecr.io</span><br><span class="line">    repository: helloworld</span><br><span class="line">    tag: latest</span><br><span class="line">    digest: sha256:92c7f9c92844bbbb5d0a101b22f7c2a7949e40f8ea90c8b3bc396879d95e899a</span><br><span class="line">  runtime-dependency:</span><br><span class="line">    registry: mcr.microsoft.com</span><br><span class="line">    repository: hello-world</span><br><span class="line">    tag: latest</span><br><span class="line">    digest: sha256:92c7f9c92844bbbb5d0a101b22f7c2a7949e40f8ea90c8b3bc396879d95e899a</span><br><span class="line">  git: &#123;&#125;</span><br><span class="line"></span><br><span class="line">Run ID: cad was successful after 8s</span><br></pre></td></tr></table></figure><p>これで、Firewall を有効化している ACR に対して、ACR タスクを用いてコンテナー イメージを作成することが出来ました。</p><h3 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h3><p>この記事では、ACR のFirewall 機能を有効にした状態で ACR の機能を用いてコンテナー イメージをビルドする方法をご紹介しました。<br>ご参考にいただけますと幸いです。</p><p>本稿が皆様のお役に立ちましたら幸いです。</p><p>最後まで読んでいただきありがとうございました！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;この記事は&lt;a href=&quot;https://qiita.com/advent-calendar/2023/microsoft-azure-tech&quot;&gt;Microsoft Azure Tech Advent Calendar 2023&lt;/a&gt; の 22 日目の記事になります。&lt;/p&gt;
&lt;p&gt;こんにちは！ Azure テクニカル サポート チームの川畑です。&lt;br&gt;az acr buildコマンドを用いてコンテナー イメージをビルドする際に、ACR の Firewall 機能によって失敗するお問い合わせを頂きます。&lt;br&gt;この記事では、ACR のFirewall 機能を有効にした状態で ACR の機能を用いてコンテナー イメージをビルドする方法についてご紹介します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Containers" scheme="https://jpaztech.github.io/blog/tags/Containers/"/>
    
    <category term="Azure Container Registry (ACR)" scheme="https://jpaztech.github.io/blog/tags/Azure-Container-Registry-ACR/"/>
    
  </entry>
  
  <entry>
    <title>マネージドディスクとスナップショットのネットワーク設定について</title>
    <link href="https://jpaztech.github.io/blog/vm/network-setting-of-disk-and-snapshot/"/>
    <id>https://jpaztech.github.io/blog/vm/network-setting-of-disk-and-snapshot/</id>
    <published>2023-12-18T08:00:00.000Z</published>
    <updated>2024-02-16T07:05:26.474Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの富田です。<br>マネージドディスクとスナップショットのネットワーク設定について、どういったものであるかといった点をお問い合わせいただくことがございますので、この点を解説させていただきます。</p><hr><h2 id="マネージドディスクとスナップショットのネットワーク設定"><a href="#マネージドディスクとスナップショットのネットワーク設定" class="headerlink" title="マネージドディスクとスナップショットのネットワーク設定"></a>マネージドディスクとスナップショットのネットワーク設定</h2><p>マネージドディスクやスナップショットを新規作成する際に、作成画面にて以下のように「ネットワーク」というタブで、ネットワーク設定をすることができます。<br>（作成後に、後から編集することも可能です。）  </p><p><img src="/blog/vm/network-setting-of-disk-and-snapshot/2023-12-12-14-03-30.png"></p><p>既定では、「すべてのネットワークからのパブリック アクセスを有効にする」となっておりますため、「ディスクに対し外部から不正アクセスされてしまうのでは？」というお問い合わせをいただくこともございます。<br>このネットワークの設定は<strong>マネージドディスクとスナップショットのエクスポート/インポートをする際に、アクセス許可をするネットワークを設定する</strong>ものとなっております。<br>すなわち、明示的にエクスポート URL の生成を行わない場合は、パブリック上の不特定多数からディスクにアクセスされるといったことはございませんのでご安心ください。<br>また Azure VM から接続されているマネージドディスクへの通信に影響を及ぼす設定でもございません。  </p><blockquote><p>■ご参考：マネージド ディスクがインポートまたはエクスポートされる操作を制限する<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/disks-restrict-import-export-overview">https://learn.microsoft.com/ja-jp/azure/virtual-machines/disks-restrict-import-export-overview</a></p></blockquote><hr><h2 id="マネージドディスク-スナップショットのエクスポートについて"><a href="#マネージドディスク-スナップショットのエクスポートについて" class="headerlink" title="マネージドディスク / スナップショットのエクスポートについて"></a>マネージドディスク / スナップショットのエクスポートについて</h2><p>マネージドディスクとスナップショットは以下の通り、ポータル等でエクスポート URL を発行し、VHD ファイルとしてダウンロードを行うといったことが可能です。<br>セキュリティ上の観点より、明示的にエクスポート URL を発行しない場合はエクスポートはできず、URL も有効期限を設ける必要がございます。  </p><p><img src="/blog/vm/network-setting-of-disk-and-snapshot/2023-12-12-14-05-35.png"></p><blockquote><p>■ご参考：Azure から Windows VHD をダウンロードする<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/download-vhd">https://learn.microsoft.com/ja-jp/azure/virtual-machines/windows/download-vhd</a></p></blockquote><blockquote><p>■ご参考：Azure から Linux VHD をダウンロードする<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/download-vhd">https://learn.microsoft.com/ja-jp/azure/virtual-machines/linux/download-vhd</a></p></blockquote><p>この際、マネージドディスクおよびスナップショットのネットワーク設定にて既定の「すべてのネットワークからのパブリック アクセスを有効にする」という設定にしている場合、エクスポート URL があればどのパブリックネットワークからも VHD のダウンロード等が可能となります。<br>しかしながら、万が一悪意のあるユーザーにエクスポート URL が入手されてしまった場合にも VHD ダウンロードを不可とさせるための設定として、  </p><ul><li>パブリック アクセスを無効にし、プライベート アクセスを有効にする</li><li>パブリック アクセスとプライベート アクセスを無効にする</li></ul><p>というオプションもご用意しているといったこととなります。  </p><p>「パブリック アクセスを無効にし、プライベート アクセスを有効にする」の設定とした場合は、エクスポート URL があったとしてもパブリックネットワークからのアクセスはできず、Azure 仮想ネットワーク上のクライアントからプライベート リンクを介してでないとアクセスできないといった、よりセキュリティの高い設定となります。<br>この点詳細については以下の公開ドキュメントをご参照ください。  </p><blockquote><p>■ご参考：Azure Private Link を使用してマネージド ディスクに対するインポートおよびエクスポートのアクセスを制限する<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/disks-enable-private-links-for-import-export-portal">https://learn.microsoft.com/ja-jp/azure/virtual-machines/disks-enable-private-links-for-import-export-portal</a></p></blockquote><p>「パブリック アクセスとプライベート アクセスを無効にする」の設定にした場合は、エクスポート URL の発行自体が不可になります。  </p><p>上記、エクスポートを例として記載しましたが以下のマネージドディスクに対する VHD インポートについても同じようにネットワークの制限の設定か可能です。</p><blockquote><p>■ご参考：お使いの VHD をアップロードする<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/managed-disks-overview#upload-your-vhd">https://learn.microsoft.com/ja-jp/azure/virtual-machines/managed-disks-overview#upload-your-vhd</a></p></blockquote><hr><p>上述の通り、こちらのネットワーク設定はあくまでエクスポート/インポート時のネットワーク制限の設定を行うものである点、ご理解賜りますと幸いでございます。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの富田です。&lt;br&gt;マネージドディスクとスナップショットのネットワーク設定について、どういったものであるかといった点をお問い合わせいただくことがございますので、この点を解説させていただきます。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 i</summary>
      
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Disk" scheme="https://jpaztech.github.io/blog/tags/Disk/"/>
    
  </entry>
  
  <entry>
    <title>AKSノード上でのOOMKillの挙動と調査方法</title>
    <link href="https://jpaztech.github.io/blog/containers/aks-oom-202312/"/>
    <id>https://jpaztech.github.io/blog/containers/aks-oom-202312/</id>
    <published>2023-12-17T03:00:00.000Z</published>
    <updated>2024-02-16T07:05:26.170Z</updated>
    
    <content type="html"><![CDATA[<p>この記事は<a href="https://qiita.com/advent-calendar/2023/microsoft-azure-tech">Microsoft Azure Tech Advent Calendar 2023</a> の 17 日目の記事になります。</p><p>こんにちは、 Azure テクニカル サポート チームの高田です。<br>AKS(に限らず、Kubernetes全般)を利用する際に難しいことの一つとして、メモリの割り当てや制限の管理があります。<br>ノードやその上のメモリ(を確保するための予算)にも限りがあるので<br>必要十分で済ませようとしたものの、思わぬときにOOMKillでワークロードに<br>影響が発生した、という経験をされた方も多いかと思います。</p><p>この記事では、OOMKillが発生したときにせめて速やかに対処できるよう、<br>OOMKillの際の挙動やこれに基づく原因調査方法について<br>いくつかのトピックを紹介させて頂きます。</p><h2 id="扱うトピック、扱わないトピック"><a href="#扱うトピック、扱わないトピック" class="headerlink" title="扱うトピック、扱わないトピック"></a>扱うトピック、扱わないトピック</h2><p>本記事では、AKSノード上に配置されたPodのメモリ利用に起因してOOMKillが発生した場合の<br>挙動や、原因の調査方法を紹介します。</p><p>そもそもノードのリソース不足でPodがスケジューリングされない(Pendingのままとなる)場合につきましては<br>スコープ外とさせて頂きますのでご了承下さい。</p><h2 id="2種類のメモリ利用制限"><a href="#2種類のメモリ利用制限" class="headerlink" title="2種類のメモリ利用制限"></a>2種類のメモリ利用制限</h2><p>AKSノード上でPodがメモリを確保・利用する際、Pod・コンテナーレベル、<br>ノードレベルの2つの観点にて利用量が制限されます。OOMKillは各レベルで発生し得ます。</p><h3 id="Pod・コンテナーレベルでの制限・OOMKill"><a href="#Pod・コンテナーレベルでの制限・OOMKill" class="headerlink" title="Pod・コンテナーレベルでの制限・OOMKill"></a>Pod・コンテナーレベルでの制限・OOMKill</h3><p>Pod内のコンテナーが確保・利用可能なメモリの上限は、Podのmanifest(YAML)中の<br><code>spec.containers[].resources.limits.memory</code>にて指定できます。<br>コンテナーがこの制限を超えてメモリを確保・利用しようとした場合に、OOMKillが発生します。</p><p>(設定方法や考え方については下記のドキュメント等をご参照下さい)</p><p><a href="https://learn.microsoft.com/ja-jp/azure/aks/developer-best-practices-resource-management">Azure Kubernetes Service (AKS) でリソースを管理するアプリケーション開発者のベスト プラクティス</a></p><p><a href="https://kubernetes.io/ja/docs/tasks/configure-pod-container/assign-memory-resource/">コンテナおよびPodへのメモリーリソースの割り当て</a></p><p><a href="https://kubernetes.io/ja/docs/concepts/configuration/manage-resources-containers/">コンテナのリソース管理</a></p><h3 id="ノードレベルでの制限・OOMKill"><a href="#ノードレベルでの制限・OOMKill" class="headerlink" title="ノードレベルでの制限・OOMKill"></a>ノードレベルでの制限・OOMKill</h3><p>Podがノードにスケジュールされる際、ノードが提供可能なメモリが<br>Pod・コンテナーに対して十分か否かの判定は、<code>spec.containers[].resources.limits.memory</code><br>(制限)ではなく、<code>spec.containers[].resources.limits.memory</code>(要求)に基づいて<br>行われます。このため、あるノード上にスケジュールされたPod・コンテナーの<br>制限値の合計が、実際にそのノード上で利用可能なメモリ量よりはるかに多い、ということが<br>起こり得ます。</p><p>この場合、まず、 Pod・コンテナーによるメモリ使用量の合計が割り当て可能(Allocatable)な<br>メモリ量を超えた時点で、evict(退去)によるメモリ逼迫の解消が試みられます。<br>ただ、evict(退去)が間に合わず、メモリ使用量が割り当て可能なメモリ量 + eviction-threshold<br>の値を超過した場合に、ノードレベルでのOOMKillが発生します。</p><p>割り当て可能なメモリ量は、ノードに搭載されている(=VMサイズにて提供される)<br>メモリ量から、 kube-reserved, system-reserved, 前述のeviction-thresholdの値を<br>引いた値となっています。</p><p><a href="https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable">Reserve Compute Resources for System Daemons: Node Allocatable</a></p><p>AKS(Kubernetes バージョン1.28以下)の場合、eviction-thresholdは750MiB、kube-reservedは<br>ノードに搭載されているメモリ量に基づき一定の法則にて算出された値の量となります。<br>(system-reservedは定義されていません)</p><p><a href="https://learn.microsoft.com/ja-jp/azure/aks/concepts-clusters-workloads#memory">Azure Kubernetes Services (AKS) における Kubernetes の中心概念:<br>メモリ</a></p><p>ノードに搭載されているメモリ量、割り当て可能な量は各々、<code>kubectl describe node</code>コマンドの出力中の<br>Capacityの項、Allocatableの項などにて確認できます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe node &lt;ノード名&gt;</span><br><span class="line">(略)</span><br><span class="line">Capacity:</span><br><span class="line">  cpu:                2</span><br><span class="line">  ephemeral-storage:  129886128Ki</span><br><span class="line">  hugepages-1Gi:      0</span><br><span class="line">  hugepages-2Mi:      0</span><br><span class="line">  memory:             4007948Ki</span><br><span class="line">  pods:               110</span><br><span class="line">Allocatable:</span><br><span class="line">  cpu:                1900m</span><br><span class="line">  ephemeral-storage:  119703055367</span><br><span class="line">  hugepages-1Gi:      0</span><br><span class="line">  hugepages-2Mi:      0</span><br><span class="line">  memory:             2191372Ki</span><br><span class="line">  pods:               110</span><br><span class="line">(略)</span><br></pre></td></tr></table></figure><h2 id="Pod・コンテナーの情報でわかること、わからないこと"><a href="#Pod・コンテナーの情報でわかること、わからないこと" class="headerlink" title="Pod・コンテナーの情報でわかること、わからないこと"></a>Pod・コンテナーの情報でわかること、わからないこと</h2><p>あるコンテナーに関してOOMKillによるコンテナーの再起動が発生した場合、<br>コンテナーの過去の状態としてそのことが記録されます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe pod &lt;Pod名&gt;</span><br><span class="line">(略)</span><br><span class="line">  &lt;コンテナー名&gt;:</span><br><span class="line">    Last State:     Terminated</span><br><span class="line">      Reason:       OOMKilled</span><br><span class="line">      Exit Code:    0</span><br><span class="line">      Started:      Wed, 13 Dec 2023 06:23:20 +0000</span><br><span class="line">      Finished:     Wed, 13 Dec 2023 06:23:21 +0000</span><br></pre></td></tr></table></figure><p>ただ、これのみでは、OOMKillが発生した原因<br>(Pod・コンテナーレベルかノードレベルか)はわかりません。<br>また、コンテナー内の子プロセスが大量にメモリを使用していた場合、<br>その子プロセスがOOMkillの対象となることがありますが、<br>このとき他のプロセスが動作を継続していた場合は、<br>そもそもコンテナーの再起動とならず、<code>kubectl describe pod</code>コマンドなどでは<br>確認できません。<br>(このときの挙動については後述します)</p><h2 id="ノードの情報にてわかること、わからないこと"><a href="#ノードの情報にてわかること、わからないこと" class="headerlink" title="ノードの情報にてわかること、わからないこと"></a>ノードの情報にてわかること、わからないこと</h2><p>ノードレベルでメモリの逼迫が発生していた場合、<br>ノードの情報(<code>kubectl describe node</code>)やイベントとして、<br><code>NodeHasInsufficientMemory</code> を確認できます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe node &lt;ノード名&gt;</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason                     Age                   From            Message</span><br><span class="line">  ----     ------                     ----                  ----            -------</span><br><span class="line">  Normal   NodeHasInsufficientMemory  9m33s (x2 over 18m)   kubelet         Node &lt;ノード名&gt; status is now: NodeHasInsufficientMemory</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get events</span><br><span class="line">LAST SEEN   TYPE      REASON                      OBJECT               MESSAGE</span><br><span class="line">(略)</span><br><span class="line">8m21s       Warning   EvictionThresholdMet        node/&lt;ノード名&gt;       Attempting to reclaim memory</span><br><span class="line">10m         Normal    NodeHasInsufficientMemory   node/&lt;ノード名&gt;       Node &lt;ノード名&gt; status is now: NodeHasInsufficientMemory</span><br></pre></td></tr></table></figure><p>これらの情報は、あくまでもこのタイミングでメモリの逼迫が発生していた、ということを示すものであり、<br>同時期にOOMKillが発生していた場合にも、それがPod・コンテナーレベルのものである可能性は<br>否定できません。ただ、いずれにせよメモリの逼迫が発生していたことには違いないので、<br>要求(requests)の見直しや、これとあわせてのノードの増強などを検討すべき、という<br>判断は可能です。</p><h2 id="ノードのログからわかること"><a href="#ノードのログからわかること" class="headerlink" title="ノードのログからわかること"></a>ノードのログからわかること</h2><p>とはいえ、関係者への説明のためなど、確実に原因を特定したい場合もあるかと思います。<br>そのような場合は、ノードのログを見ることでPod・コンテナーレベルか<br>ノードレベルか確認・判断することができます。</p><p>OOMKillはLinuxカーネルの機能により実行されるため、OOMKillが発生した際には<br>ノードのログ(/var/log/syslog, /var/log/kern.log など)にメッセージが出力されます。<br>下記の例のように、OOMKillが発生した際には<code>&lt;プロセス名&gt;　invoked oom-killer</code><br>から始まり、ハードウェア情報、発生時のスタック情報、メモリ利用状況など、<br>様々な情報が出力されます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036951] stress-ng-vm invoked oom-killer: gfp_mask=0xcc0(GFP_KERNEL), order=0, oom_score_adj=1000</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036958] CPU: 1 PID: 716580 Comm: stress-ng-vm Not tainted 5.15.0-1051-azure #59-Ubuntu</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036961] Hardware name: Microsoft Corporation Virtual Machine/Virtual Machine, BIOS 090008  12/07/2018</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036962] Call Trace:</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036964]  &lt;TASK&gt;</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036967]  show_stack+0x52/0x5c</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036973]  dump_stack_lvl+0x38/0x4d</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036978]  dump_stack+0x10/0x16</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036980]  dump_header+0x53/0x228</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036984]  oom_kill_process.cold+0xb/0x10</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036986]  out_of_memory+0x106/0x2e0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036989]  mem_cgroup_out_of_memory+0x13f/0x160</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036992]  try_charge_memcg+0x6cd/0x790</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036995]  charge_memcg+0x45/0xa0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.036997]  __mem_cgroup_charge+0x2d/0x90</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037000]  do_anonymous_page+0x104/0x4c0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037003]  handle_pte_fault+0x21b/0x260</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037006]  __handle_mm_fault+0x409/0x760</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037009]  ? sched_clock+0x9/0x10</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037014]  handle_mm_fault+0xc8/0x2a0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037017]  do_user_addr_fault+0x1bc/0x660</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037020]  exc_page_fault+0x71/0x160</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037024]  asm_exc_page_fault+0x27/0x30</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037027] RIP: 0033:0x55fbbb223b65</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037031] Code: 98 00 41 54 49 89 fa 55 48 89 cd 48 01 fa 53 4c 8b 59 10 4c 39 ca 0f 83 01 01 00 00 31 c9 0f 1f 80 00 00 00 00 89 cf 83 c1 01 &lt;40&gt; 88 3a 48 8b 3d 99 f7 98 00 48 01 fa 4c 39 ca 72 e9 48 89 f0 31</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037033] RSP: 002b:00007ffd1b287520 EFLAGS: 00010206</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037035] RAX: 0000000000000010 RBX: 00007f1d90825000 RCX: 0000000000734f41</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037036] RDX: 00007f1dad562000 RSI: 0000000040000000 RDI: 0000000000734f40</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037038] RBP: 00007f1dd2c1e398 R08: 0000000000000000 R09: 00007f1dd0825000</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037039] R10: 00007f1d90825000 R11: 0000000000000000 R12: 0000000040000000</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037040] R13: 0000000000000000 R14: 00007ffd1b287670 R15: 000055fbbb2224b0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037044]  &lt;/TASK&gt;</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037045] memory: usage 512000kB, limit 512000kB, failcnt 37</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037046] swap: usage 0kB, limit 9007199254740988kB, failcnt 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037047] Memory cgroup stats for /kubepods.slice/kubepods-burstable.slice/kubepods-burstable-pod479f327f_a27b_4eda_8523_90bdabcf0a27.slice:</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] anon 484630528</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] file 37752832</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] kernel_stack 65536</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] pagetables 1212416</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] percpu 11752</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] sock 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] shmem 37720064</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] file_mapped 37720064</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] file_dirty 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] file_writeback 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] swapcached 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] anon_thp 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] file_thp 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] shmem_thp 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] inactive_anon 522346496</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] active_anon 4096</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] inactive_file 16384</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] active_file 16384</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] unevictable 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] slab_reclaimable 303008</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] slab_unreclaimable 210008</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] slab 513016</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] workingset_refault_anon 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] workingset_refault_file 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] workingset_activate_anon 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] workingset_activate_file 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] workingset_restore_anon 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037069] workingset_restore_file 0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037071] Tasks state (memory values in pages):</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037072] [  pid  ]   uid  tgid total_vm      rss pgtables_bytes swapents oom_score_adj name</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037073] [ 716518] 65535 716518      243        1    28672        0          -998 pause</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037077] [ 716566]     0 716566    13966    10178   139264        0           975 stress-ng</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037079] [ 716579]     0 716579    13967      424    73728        0          1000 stress-ng-vm</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037082] [ 716580]     0 716580   276111   118439  1015808        0          1000 stress-ng-vm</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037084] oom-kill:constraint=CONSTRAINT_MEMCG,nodemask=(null),cpuset=cri-containerd-679f9845995b4ae4812789eb3c3d1df88040a1bc3f0c046a05c9aa9b5b5f93be.scope,mems_allowed=0,oom_memcg=/kubepods.slice/kubepods-burstable.slice/kubepods-burstable-pod479f327f_a27b_4eda_8523_90bdabcf0a27.slice,task_memcg=/kubepods.slice/kubepods-burstable.slice/kubepods-burstable-pod479f327f_a27b_4eda_8523_90bdabcf0a27.slice/cri-containerd-679f9845995b4ae4812789eb3c3d1df88040a1bc3f0c046a05c9aa9b5b5f93be.scope,task=stress-ng-vm,pid=716580,uid=0</span><br><span class="line">Dec 13 07:23:21 aks-ubuntu-26835060-vmss000000 kernel: [36370.037095] Memory cgroup out of memory: Killed process 716580 (stress-ng-vm) total-vm:1104444kB, anon-rss:473048kB, file-rss:644kB, shmem-rss:64kB, UID:0 pgtables:992kB oom_score_adj:1000</span><br></pre></td></tr></table></figure><p>このメッセージから、いくつかのことがわかります。</p><h3 id="コンテナーレベル-ノードレベルの判断"><a href="#コンテナーレベル-ノードレベルの判断" class="headerlink" title="コンテナーレベル/ノードレベルの判断"></a>コンテナーレベル/ノードレベルの判断</h3><p><code>spec.containers[].resources.limits.memory</code>にて指定した制限は、<br>memcg(cgroupsのメモリコントローラ)により適用されます。</p><p>cgroupsはLinux上でコンテナーを実現するための主要な機能の一つであり、<br>control group(cgroup)に分類されたプロセス群について、グループごとに<br>メモリやCPU等のリソースの使用量を制限するものです。</p><p><a href="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html#memory">Control Group v2: Memory</a></p><p>メモリ制限(limits)は、Pod・コンテナーに対応するcgroupに関して<br>確保・利用可能なメモリ量の上限が設定され、上限を超過したときに<br>memcgがOOMKillを発生させることで実現されています。</p><p>下記の行からは、<code>oom_memcg</code>として、OOMの発生要因となったcgroupが<br><code>/kubepods.slice/kubepods-burstable.slice/kubepods-burstable-pod479f327f_a27b_4eda_8523_90bdabcf0a27.slice</code><br>(特定のPodに対応するcgroup)であることがわかります。すなわち、Pod・コンテナーレベルのOOMKillであると判断できます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oom-kill:constraint=CONSTRAINT_MEMCG,nodemask=(null),cpuset=cri-containerd-679f9845995b4ae4812789eb3c3d1df88040a1bc3f0c046a05c9aa9b5b5f93be.scope,mems_allowed=0,oom_memcg=/kubepods.slice/kubepods-burstable.slice/kubepods-burstable-pod479f327f_a27b_4eda_8523_90bdabcf0a27.slice,task_memcg=/kubepods.slice/kubepods-burstable.slice/kubepods-burstable-pod479f327f_a27b_4eda_8523_90bdabcf0a27.slice/cri-containerd-679f9845995b4ae4812789eb3c3d1df88040a1bc3f0c046a05c9aa9b5b5f93be.scope,task=stress-ng-vm,pid=716580,uid=0</span><br></pre></td></tr></table></figure><p>一方、ノードレベルの場合は、例えば下記のように、 <code>oom_memcg</code>が<code>/kubepods.slice</code>となっている(個々のPod等に対応する<br>cgroupではなく、その上位のcgroupとなっている)ことから、そのOOMKillがノードレベルのものであると判断できます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oom-kill:constraint=CONSTRAINT_MEMCG,nodemask=(null),cpuset=cri-containerd-4d2af8acef61505159dd1fb6e232eacd1b724e1d629f043fcaa47809544f6d92.scope,mems_allowed=0,oom_memcg=/kubepods.slice,task_memcg=/kubepods.slice/kubepods-burstable.slice/kubepods-burstable-poda9d4b3f1_0189_4f5e_a8ee_94f0a3f53ab0.slice/cri-containerd-4d2af8acef61505159dd1fb6e232eacd1b724e1d629f043fcaa47809544f6d92.scope,task=stress-ng-vm,pid=728241,uid=0</span><br></pre></td></tr></table></figure><h3 id="他にわかること"><a href="#他にわかること" class="headerlink" title="他にわかること"></a>他にわかること</h3><p>この他、OOMKillメッセージには発生時のcgroup内のメモリ使用量の内訳、プロセス毎のメモリ使用状況などの情報が含まれます。<br>もし、Pod・コンテナーが意図せず大量のメモリを確保・利用していた場合、これらの情報を参照することで<br>原因の絞り込みに役立つかもしれません。</p><h2 id="子プロセスがOOMKillされたときの挙動"><a href="#子プロセスがOOMKillされたときの挙動" class="headerlink" title="子プロセスがOOMKillされたときの挙動"></a>子プロセスがOOMKillされたときの挙動</h2><h3 id="Kubernetes-1-27-まで"><a href="#Kubernetes-1-27-まで" class="headerlink" title="Kubernetes 1.27 まで"></a>Kubernetes 1.27 まで</h3><p>既に解説した通り、Pod・コンテナーレベルのOOMKillは、Pod・コンテナーに対応するcgroupに関して<br>メモリ使用量が制限値を超過することで発生します。<br>ただ、このとき行われるOOMKillの対象は、あくまでもコンテナー内で(メモリ使用量等の観点で)選ばれた<br>特定のプロセスとなります。従って、例えばコンテナー内で作成された子プロセスの一つが<br>OOMKillにより終了した場合、コンテナー内のプロセスの構成次第では<br>他のプロセスが(場合によってはコンテナーとして不完全なまま)動作を継続する場合があります。</p><p>このとき、コンテナーとしての再起動は発生しないため、<br><code>kubectl describe pod</code>コマンドの結果などからは、そもそもOOMKillが発生したことすらわかりません。</p><p>このような場合にOOMKillの発生を検知するには、ノードのログ等から<br>OOMKillのメッセージの有無を確認する必要があります。<br>(memcgの統計情報を確認する、などの方法もありますが割愛させて頂きます)</p><h3 id="Kubernetes-1-28-以降"><a href="#Kubernetes-1-28-以降" class="headerlink" title="Kubernetes 1.28 以降"></a>Kubernetes 1.28 以降</h3><p>Kubernetes バージョン1.28以降では、cgroups v2のmemcgで採用された<br><code>memory.oom.group</code>という機能を、Pod・コンテナーのcgroupに関して<br>有効化するようになりました。<br>この機能は、cgroup内の任意のプロセスがOOMKillの対象となった場合に<br>同じcgroup内の全プロセスに関してOOMKillを実行する、というものです。<br>すなわち、 Kubernetes バージョンが1.28以降であり、<br>かつ、利用されているcgroupsがv2の場合、<br>任意の子プロセスがOOMKillとなった際に、(<code>restartPolicy</code>がNeverでなければ)<br>確実にコンテナーの再起動が発生するようになります。</p><p><a href="https://github.com/kubernetes/kubernetes/issues/117070">[SIG-Node] Cgroups v2 memory.oom.group support (kill all pids in a pod on oom)</a></p><p><a href="https://github.com/kubernetes/kubernetes/pull/117793">use the cgroup aware OOM killer if available</a></p><p>AKS では、Kubernetes バージョン1.25以降のAKSクラスターの<br>Ubuntuノード(Ubuntu 22.04ノード)でcgroups v2が利用されております。<br>Azure Linuxノードの場合はKubernetes バージョン1.28の時点にて<br>まだcgroups v1が利用されますが、バージョン1.29以降では<br>cgroups v2の利用に切り替わる予定です。</p><p><a href="https://github.com/Azure/AKS/releases/tag/2023-11-28">AKS Release 2023-11-28</a></p><p>まとめると、Ubuntuノードの場合は Kuberenetes バージョン1.28以降、<br>Azure Linuxノードの場合はバージョン1.29以降にて、<br>Pod・コンテナーのcgroupに対して<code>memory.oom.group</code>が有効化され、<br>OOMKillの発生時にはコンテナー内の全プロセスがOOMKill対象となります。</p><p>なお、<code>memory.oom.group</code>が有効化されているコンテナーに関してOOMKillが発生した場合、<br>下記のように、ログメッセージでもcgroup内の全プロセスがkillされる旨のメッセージが出力されます。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dec 13 07:54:24 aks-ubuntu-26253795-vmss000000 kernel: [41725.949137] Tasks in /kubepods.slice/kubepods-burstable.slice/kubepods-burstable-podc9658b52_5194_4250_87f2_ec380cce2915.slice/cri-containerd-6793e00dcd36f430871d321242bbd79c1c186a3fad6615a98a1cc0b24c3e7f8f.scope are going to be killed due to memory.oom.group set</span><br></pre></td></tr></table></figure><h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><p>この記事では、AKSノードにおけるOOOMKillの際の挙動や、これに基づく原因調査方法について紹介しました。<br>OOMKill発生時には、紹介した方法にて原因を確認の上、Pod・コンテナーレベルのOOMKillの場合は<br>制限(limits)の増加、ノードレベルの場合は要求(requests)の増加やノードの増強等を<br>ご検討下さい。<br>また、<code>memory.oom.group</code>未対応の構成では、Kubernetes リソースの情報としては<br>わからない形でOOMKillが発生していた、ということもありますので、<br>プロセスがいつの間にか終了していた、といった場合には<br>OOMKillが発生していた可能性もご確認下さい。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;この記事は&lt;a href=&quot;https://qiita.com/advent-calendar/2023/microsoft-azure-tech&quot;&gt;Microsoft Azure Tech Advent Calendar 2023&lt;/a&gt; の 17 日目の記事になります。</summary>
      
    
    
    
    
    <category term="Containers" scheme="https://jpaztech.github.io/blog/tags/Containers/"/>
    
    <category term="Azure Kubernetes Service (AKS)" scheme="https://jpaztech.github.io/blog/tags/Azure-Kubernetes-Service-AKS/"/>
    
  </entry>
  
  <entry>
    <title>Azure Cloud Shell を仮想ネットワークにデプロイする手順のご紹介</title>
    <link href="https://jpaztech.github.io/blog/vm/UseCloudShellinAzureVirtualNetwork/"/>
    <id>https://jpaztech.github.io/blog/vm/UseCloudShellinAzureVirtualNetwork/</id>
    <published>2023-12-13T14:09:00.000Z</published>
    <updated>2024-02-16T07:05:26.278Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカルサポートチームの小田です。<br>今回は仮想ネットワークに対して Azure Cloud Shell をデプロイする手順を紹介いたします。</p><span id="more"></span><h2 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h2><p>通常 Azure Cloud Shell のマシンは、お客様が管理されている仮想ネットワークとは異なる Azure が管理するネットワークに対して展開されます。<br>Azure Cloud Shell が存在するネットワークは、お客様ではなくマイクロソフトが管理を行っております。 </p><p>そのため、Azure Cloud Shell のご利用において以下のような制約でお困りのお客様から、お問い合わせを頂くことがしばしばございます。</p><ul><li>Azure Cloud Shell から仮想マシンなどのリソースが持つプライベート IP アドレスに対して接続ができない</li><li>Azure Cloud Shell が使用する IP アドレスをお客様が設定 / 管理できないため、Azure Cloud Shell からの通信を NSG などによりを制御することができない</li></ul><p>このような場合にはAzure Cloud Shell を仮想ネットワークにデプロイすることで、Azure Cloud Shell が使用する IP アドレスをお客様が管理することができ、これらの制約が解消されます。<br>なお補足となりますが、この Azure Cloud Shell を仮想ネットワークに対してデプロイすることを “VNET の分離” とも呼びます。<br>必要に応じて、Azure Cloud Shell を仮想ネットワークに対してデプロイすることについてご検討をいただけますと幸いです。</p><h2 id="ご利用にあたっての注意事項"><a href="#ご利用にあたっての注意事項" class="headerlink" title="ご利用にあたっての注意事項"></a>ご利用にあたっての注意事項</h2><p>ご利用に際して以下 2 点の注意事項がございますのでご確認ください。</p><h3 id="注意事項①-Azure-Relay-リソースの利用は有償となります"><a href="#注意事項①-Azure-Relay-リソースの利用は有償となります" class="headerlink" title="注意事項① Azure Relay リソースの利用は有償となります"></a>注意事項① Azure Relay リソースの利用は有償となります</h3><p>Azure Cloud Shell を仮想ネットワークに対してデプロイする場合には、Azure Relay をご利用いただく必要がございますが、Azure Relay は有料サービスとなります。<br>この点につきましてご留意をいただけますと幸いです。</p><blockquote><p>・ご参考: <a href="https://learn.microsoft.com/ja-jp/azure/cloud-shell/private-vnet#things-to-consider-before-deploying-azure-cloud-shell-in-a-vnet">VNET に Azure Cloud Shell をデプロイする前に考慮すべき事項</a><br>—- 抜粋 —–<br>VNET の分離では、有料サービスである Azure Relay を使用する必要があります。<br>—- 抜粋 —–</p></blockquote><h3 id="注意事項②-デプロイできるリージョンが限られます"><a href="#注意事項②-デプロイできるリージョンが限られます" class="headerlink" title="注意事項② デプロイできるリージョンが限られます"></a>注意事項② デプロイできるリージョンが限られます</h3><p>また、Azure Cloud Shell を仮想ネットワークに対してデプロイする場合にも、 Azure Cloud Shell  を展開できるリージョンは限られます。東日本や西日本リージョンには Cloud Shell 端末をデプロイできない点についてご留意をください。</p><blockquote><p>・ご参考: <a href="https://learn.microsoft.com/ja-jp/azure/cloud-shell/persisting-shell-storage#supported-storage-regions">サポートされているストレージ リージョン</a><br>—- 抜粋 —–<br>Azure Cloud Shellは、次の各リージョンに存在します。</p><table><thead><tr><th>領域</th><th>リージョン</th></tr></thead><tbody><tr><td>アメリカ</td><td>米国東部、米国中南部、米国西部</td></tr><tr><td>ヨーロッパ</td><td>北ヨーロッパ、西ヨーロッパ</td></tr><tr><td>アジア太平洋</td><td>インド中部、東南アジア</td></tr><tr><td>—- 抜粋 —–</td><td></td></tr></tbody></table></blockquote><p>そのため VNET に対して Azure Cloud Shell をデプロイする場合にも、Azure Cloud Shell から東日本や西日本リージョンのリソースに対してプライベート IP アドレスを使用した接続をご希望の場合には、Azure Cloud Shell がデプロイされる VNET と東日本や西日本リージョンの VNET 間で VNET ピアリングが必要となります。</p><blockquote><p>・ご参考: <a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/virtual-network-peering-overview">Azure 仮想ネットワーク ピアリング</a></p></blockquote><h2 id="デプロイ手順"><a href="#デプロイ手順" class="headerlink" title="デプロイ手順"></a>デプロイ手順</h2><p>本稿では、Azure Cloud Shell や仮想ネットワーク、ストレージアカウントをARM テンプレートにより新規に作成し、仮想ネットワーク上に Azure Cloud Shell をデプロイする手順をご紹介いたします。<br>以下の公式ドキュメントが対応いたしますので、併せてご参考ください。</p><blockquote><p>・ご参考: <a href="https://learn.microsoft.com/ja-jp/azure/cloud-shell/quickstart-deploy-vnet">クイックスタート テンプレートを使用して VNET に Azure Cloud Shell をデプロイする</a></p></blockquote><h3 id="手順の概要"><a href="#手順の概要" class="headerlink" title="手順の概要"></a>手順の概要</h3><p>具体的な手順の説明に入る前に、まずは手順の概要を説明させて頂きます。<br>作業は以下 7 つの手順にて実施いたします。</p><p>手順① リソースグループの作成<br>手順② 仮想ネットワークの作成<br>手順③ リソースプロバイダーの登録<br>手順④ Azure Container Instance ID の確認<br>手順⑤ ARM テンプレートを使用してストレージアカウント以外のリソースを作成<br>手順⑥ ARM テンプレートを使用してストレージアカウントを作成<br>手順⑦ 仮想ネットワークを使用するように Cloud Shell を構成</p><h3 id="手順の詳細"><a href="#手順の詳細" class="headerlink" title="手順の詳細"></a>手順の詳細</h3><p>具体的なデプロイ手順を以下にご案内いたします。</p><h4 id="手順①-リソースグループを作成する"><a href="#手順①-リソースグループを作成する" class="headerlink" title="手順① リソースグループを作成する"></a>手順① リソースグループを作成する</h4><p>Cloud Shell 端末をデプロイできるリージョンを指定し（以下の画面例では ”southeastasia”を指定）リソースグループを作成いたします。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step1-1.jpg" alt="手順①"></p><h4 id="手順②-仮想ネットワークを作成する"><a href="#手順②-仮想ネットワークを作成する" class="headerlink" title="手順②　仮想ネットワークを作成する"></a>手順②　仮想ネットワークを作成する</h4><p>前項で作成したリソースグループおよび対象のリージョンを指定し、仮想ネットワークを作成いたします。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step2-1.jpg" alt="手順②"></p><p>IP アドレス タブにて、ご希望の IP アドレス レンジをご指定ください。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step2-2.jpg" alt="手順②"></p><h4 id="手順③リソースプロバイダーの登録"><a href="#手順③リソースプロバイダーの登録" class="headerlink" title="手順③リソースプロバイダーの登録"></a>手順③リソースプロバイダーの登録</h4><p>Azure Cloud Shell はコンテナーを使用して実行されるため、ご利用のサブスクリプションにおいて、”Microsoft.ContainerInstances” リソースプロバイダーを登録する必要があります。<br>当該リソースプロバイダーは自動的に登録されている場合がございますので、まずは Azure PowerShell より以下のコマンドを使用して、リソースプロバイダーの登録状況を確認してください。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-AzContext</span> <span class="literal">-Subscription</span> &lt;サブスクリプション名&gt;</span><br><span class="line"><span class="built_in">Get-AzResourceProvider</span> <span class="literal">-ProviderNamespace</span> Microsoft.ContainerInstance |</span><br><span class="line">    <span class="built_in">Select-Object</span> ResourceTypes, RegistrationState</span><br></pre></td></tr></table></figure><p>登録がされていない場合は、以下の出力例のように各 RegistrationState  がNotRegistered と表示されます。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\shoheioda&gt; <span class="built_in">Get-AzResourceProvider</span> <span class="literal">-ProviderNamespace</span> Microsoft.ContainerInstance | <span class="built_in">select</span> ResourceTypes,RegistrationState</span><br><span class="line"> </span><br><span class="line">ResourceTypes                                     RegistrationState</span><br><span class="line">-------------                                     -----------------</span><br><span class="line">&#123;containerGroups&#125;                                 NotRegistered</span><br><span class="line">&#123;serviceAssociationLinks&#125;                         NotRegistered</span><br><span class="line">&#123;locations&#125;                                       NotRegistered</span><br><span class="line">&#123;locations/capabilities&#125;                          NotRegistered</span><br><span class="line">&#123;locations/usages&#125;                                NotRegistered</span><br><span class="line">&#123;locations/operations&#125;                            NotRegistered</span><br><span class="line">&#123;locations/operationresults&#125;                      NotRegistered</span><br><span class="line">&#123;operations&#125;                                      NotRegistered</span><br><span class="line">&#123;locations/cachedImages&#125;                          NotRegistered</span><br><span class="line">&#123;locations/validateDeleteVirtualNetworkOrSubnets&#125; NotRegistered</span><br><span class="line">&#123;locations/deleteVirtualNetworkOrSubnets&#125;         NotRegistered</span><br></pre></td></tr></table></figure><p>登録を行うには、以下のコマンドを実行してください。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\shoheioda&gt; <span class="built_in">Get-AzResourceProvider</span> <span class="literal">-ProviderNamespace</span> Microsoft.ContainerInstance | <span class="built_in">select</span> ResourceTypes,RegistrationState</span><br><span class="line"> </span><br><span class="line">ResourceTypes                                     RegistrationState</span><br><span class="line">-------------                                     -----------------</span><br><span class="line">&#123;containerGroups&#125;                                 Registered</span><br><span class="line">&#123;serviceAssociationLinks&#125;                         Registered</span><br><span class="line">&#123;locations&#125;                                       Registered</span><br><span class="line">&#123;locations/capabilities&#125;                          Registered</span><br><span class="line">&#123;locations/usages&#125;                                Registered</span><br><span class="line">&#123;locations/operations&#125;                            Registered</span><br><span class="line">&#123;locations/operationresults&#125;                      Registered</span><br><span class="line">&#123;operations&#125;                                      Registered</span><br><span class="line">&#123;locations/cachedImages&#125;                          Registered</span><br><span class="line">&#123;locations/validateDeleteVirtualNetworkOrSubnets&#125; Registered</span><br><span class="line">&#123;locations/deleteVirtualNetworkOrSubnets&#125;         Registered</span><br></pre></td></tr></table></figure><h4 id="手順④-Azure-Container-Instance-ID-を確認する"><a href="#手順④-Azure-Container-Instance-ID-を確認する" class="headerlink" title="手順④ Azure Container Instance ID を確認する"></a>手順④ Azure Container Instance ID を確認する</h4><p>後続の手順において必要となるサービスプリンシパル “Azure Container Instance” に割り当てられた Azure Container Instance ID を、Azure PowerShell より以下のコマンドを実行して確認してください。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-AzADServicePrincipal</span> <span class="literal">-DisplayNameBeginsWith</span> <span class="string">&#x27;Azure Container Instance&#x27;</span></span><br></pre></td></tr></table></figure><p>以下の出力例の場合には、 Azure Container Instance Id は “8fe7fd25-33fe-4f89-ade3-0e705fcf4370” となります。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DisplayName                      Id                                   AppId</span><br><span class="line">-----------                      --                                   -----</span><br><span class="line">Azure Container Instance Service <span class="number">8</span>fe7fd25<span class="literal">-33fe</span><span class="literal">-4f89</span><span class="literal">-ade3</span><span class="literal">-0e705fcf4370</span> <span class="number">34</span>fbe509<span class="literal">-d6cb</span><span class="literal">-4813</span><span class="literal">-99df</span><span class="literal">-52d944bfd95a</span></span><br></pre></td></tr></table></figure><h4 id="手順⑤-ARM-テンプレートを使用してリソースをプロビジョニングする"><a href="#手順⑤-ARM-テンプレートを使用してリソースをプロビジョニングする" class="headerlink" title="手順⑤ ARM テンプレートを使用してリソースをプロビジョニングする"></a>手順⑤ ARM テンプレートを使用してリソースをプロビジョニングする</h4><p>以下のリンクへアクセスして、 ARM テンプレートを使用して仮想ネットワークに対して Cloud Shell リソースを作成いたします。</p><p><a href="https://aka.ms/cloudshell/docs/vnet/template">https://aka.ms/cloudshell/docs/vnet/template</a></p><p>上記リンクへアクセスしたら表示される画面において、の “Deploy to Azure” のリンクを選択してください。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step5-1.jpg" alt="手順⑤"></p><p>表示されたテンプレートの各項目に必要な情報を入力して、”確認と作成”を 選択してください。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step5-2.jpg" alt="手順⑤"></p><p>入力したリソースの名称など確認画面が表示されますので、問題なければ “作成” を選択してください。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step5-3.jpg" alt="手順⑤"></p><p>対象のリソースグループ内に必要なリソースが まとめて作成されます。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step5-4.jpg" alt="手順⑤"></p><h4 id="手順⑥-ストレージアカウントを作成する。"><a href="#手順⑥-ストレージアカウントを作成する。" class="headerlink" title="手順⑥ ストレージアカウントを作成する。"></a>手順⑥ ストレージアカウントを作成する。</h4><p>以下のリンクへアクセスして、 ARM テンプレートを使用してCloud Shell が使用するストレージアカウントを作成します。</p><p><a href="https://azure.microsoft.com/resources/templates/cloud-shell-vnet-storage/">https://azure.microsoft.com/resources/templates/cloud-shell-vnet-storage/</a></p><p>上記リンクへアクセスしたら表示される画面において “Deploy to Azure” のリンクを選択してください。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step6-1.jpg" alt="手順⑥"></p><p>表示されたテンプレートの各項目に必要な情報を入力して、”確認と作成”を 選択してください。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step6-2.jpg" alt="手順⑥"></p><p>入力したリソースの名称など確認画面が表示されますので、問題なければ “作成” を選択してください。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step6-3.jpg" alt="手順⑥"></p><p>対象のリソースグループ内にストレージアカウントが作成されます。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step6-4.jpg" alt="手順⑥"></p><h4 id="手順⑦-仮想ネットワークを使用するように-Cloud-Shell-を構成する"><a href="#手順⑦-仮想ネットワークを使用するように-Cloud-Shell-を構成する" class="headerlink" title="手順⑦ 仮想ネットワークを使用するように Cloud Shell を構成する"></a>手順⑦ 仮想ネットワークを使用するように Cloud Shell を構成する</h4><p>Azure ポータル画面上部のメニューより Cloud Shell のアイコンを選択いたします。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step7-1.jpg" alt="手順⑦"></p><p>初期時点では、以下のように “ストレージアカウントがマウントされていません” とCloud Shell 端末を新規に作成される画面が表示されますので、ここでリンク “詳細設定の表示” を選択してください。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step7-2.jpg" alt="手順⑦"></p><p>なお、既に既定の設定で Cloud Shell をご利用されており、上記の画面が表示されない場合には、以下のように Cloud Shell 画面より、メニューバーの歯車アイコンから “ユーザー設定のリセット” を選択して設定を初期化させてください。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step7-3.jpg" alt="手順⑦"></p><p>再度 Cloud Shell を起動することで、上述の “ストレージアカウントがマウントされていません” とCloud Shell 端末を新規に作成される画面が表示されますので、“詳細設定の表示” を選択してください。</p><p>“詳細設定の表示” より以下のように必要な項目を入力して、”ストレージの作成” を選択してください。</p><p><img src="/blog/vm/UseCloudShellinAzureVirtualNetwork/step7-4.jpg" alt="手順⑦"></p><h4 id="補足：-仮想ネットワークにデプロイした場合の状態確認"><a href="#補足：-仮想ネットワークにデプロイした場合の状態確認" class="headerlink" title="補足： 仮想ネットワークにデプロイした場合の状態確認"></a>補足： 仮想ネットワークにデプロイした場合の状態確認</h4><p>Cloud Shell 端末を仮想ネットワークにデプロイした状況について以下のように状態を確認することが可能で</p><p>Get-CloudDrive コマンドレットにより、Cloud Shell がマウントしているファイル共有のリソース情報を確認することが可能です。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> /home/user&gt; <span class="built_in">Get-CloudDrive</span>                                                                  ter<span class="string">&#x27; -PassThru</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">FileShareName      : acsshare</span></span><br><span class="line"><span class="string">FileSharePath      : //srtrgaccctcloudshellvnet.file.core.windows.net/acsshare</span></span><br><span class="line"><span class="string">MountPoint         : /home/user/clouddrive</span></span><br><span class="line"><span class="string">Name               : srtrgaccctcloudshellvnet</span></span><br><span class="line"><span class="string">ResourceGroupName  : rg-cloudshellvnet</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">StorageAccountName : srtrgaccctcloudshellvnet</span></span><br><span class="line"><span class="string">SubscriptionId     : XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX</span></span><br></pre></td></tr></table></figure><p>以下のように対象の VNET から到達可能な プライベート IP  に対して Ping やSSH により接続が可能です。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> /home/user&gt; ping <span class="number">10.8</span>.<span class="number">0.20</span></span><br><span class="line">PING <span class="number">10.8</span>.<span class="number">0.20</span> (<span class="number">10.8</span>.<span class="number">0.20</span>) <span class="number">56</span>(<span class="number">84</span>) bytes of <span class="keyword">data</span>.</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">10.8</span>.<span class="number">0.20</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">64</span> time=<span class="number">68.7</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">10.8</span>.<span class="number">0.20</span>: icmp_seq=<span class="number">4</span> ttl=<span class="number">64</span> time=<span class="number">68.5</span> ms</span><br><span class="line"><span class="number">64</span> bytes from <span class="number">10.8</span>.<span class="number">0.20</span>: icmp_seq=<span class="number">5</span> ttl=<span class="number">64</span> time=<span class="number">68.2</span> ms</span><br><span class="line">^C</span><br><span class="line">--- <span class="number">10.8</span>.<span class="number">0.20</span> ping statistics ---</span><br><span class="line"><span class="number">5</span> packets transmitted, <span class="number">3</span> received, <span class="number">40</span>% packet loss, time <span class="number">4062</span>ms</span><br><span class="line">rtt min/avg/max/mdev = <span class="number">68.233</span>/<span class="number">68.479</span>/<span class="number">68.665</span>/<span class="number">0.181</span> ms</span><br><span class="line"><span class="built_in">PS</span> /home/user&gt;</span><br><span class="line"><span class="built_in">PS</span> /home/user&gt; ssh <span class="literal">-i</span> rhel<span class="literal">-86</span><span class="literal">-02_20230912</span>.pem azureuser@<span class="number">10.8</span>.<span class="number">0.20</span></span><br><span class="line">Activate the web console with: systemctl enable -<span class="literal">-now</span> cockpit.socket</span><br><span class="line"></span><br><span class="line">Register this system with Red Hat Insights: insights<span class="literal">-client</span> -<span class="literal">-register</span></span><br><span class="line">Create an account or view all your systems at https://red.ht/insights<span class="literal">-dashboard</span></span><br><span class="line">Last login: Tue Sep <span class="number">12</span> <span class="number">04</span>:<span class="number">16</span>:<span class="number">23</span> <span class="number">2023</span> from XX.XX.XX.XX</span><br><span class="line">[<span class="type">azureuser</span>@<span class="type">rhel</span>-<span class="number">86</span>-<span class="number">02</span> ~]<span class="variable">$</span> </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカルサポートチームの小田です。&lt;br&gt;今回は仮想ネットワークに対して Azure Cloud Shell をデプロイする手順を紹介いたします。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Azure Cloud Shell" scheme="https://jpaztech.github.io/blog/tags/Azure-Cloud-Shell/"/>
    
    <category term="Token" scheme="https://jpaztech.github.io/blog/tags/Token/"/>
    
    <category term="OAuth" scheme="https://jpaztech.github.io/blog/tags/OAuth/"/>
    
  </entry>
  
  <entry>
    <title>AKS ノードが起動しない場合のトラブルシューティング</title>
    <link href="https://jpaztech.github.io/blog/containers/aks-vmsscse/"/>
    <id>https://jpaztech.github.io/blog/containers/aks-vmsscse/</id>
    <published>2023-12-12T03:00:00.000Z</published>
    <updated>2024-02-16T07:05:26.170Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは。Azure テクニカル サポートチームの桐井です。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/aks/intro-kubernetes">Azure Kubernetes Service (AKS)</a> クラスターで、ノードの新規作成が成功しない事象や、停止したクラスターの起動が成功しないといった事象が発生することがございます。</p><p>このような事象は、ノードの初期化が成功していない場合に発生するもので、弊社サポート事例においても多くのお客様よりご相談をいただくことがございます。</p><p>本記事では、AKS ノードの初期化を担う vmssCSE 拡張機能についての解説と、ノード初期化が成功しない代表的な要因とトラブルシューティング方法について紹介します。</p><span id="more"></span><hr><h2 id="vmssCSE-拡張機能とは"><a href="#vmssCSE-拡張機能とは" class="headerlink" title="vmssCSE 拡張機能とは"></a>vmssCSE 拡張機能とは</h2><p>AKS クラスターのノードには VMSS インスタンスが使用されています。AKS ノードを作成すると、それに応じて VMSS インスタンスが作成されます。</p><p>vmssCSE 拡張機能は、VMSS インスタンスを AKS ノードとして利用可能な状態にするために初期化する役割を担います。<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/extensions/overview">Azure 仮想マシンの拡張機能</a>を利用して、AKS ノードの初期化をするスクリプトが実行されます。<br>vmssCSE は VMSS (Virtual Machine Scale Set) Custom Script Extension の略称です。</p><p>初期化スクリプトが実行されると、はじめに、<a href="https://learn.microsoft.com/ja-jp/azure/aks/outbound-rules-control-egress#required-outbound-network-rules-and-fqdns-for-aks-clusters">AKS ノードに必要なネットワーク要件</a>が満たされているか検証されます。<br>AKS のAPI サーバーや、システム コンポーネントの取得元となるコンテナー レジストリに対してアクセス可能か検証し、必要な通信ができる状態であるかチェックされます。<br>その後、AKS ノードとして動作させるために必要なコンポーネント (kubelet や CNI プラグインなど) がダウンロードされ、VMSS インスタンスにインストールされます。<br>インストールが完了すると、AKS クラスターにノードが追加されます。</p><p>vmssCSE 拡張機能は、Azure 仮想マシンのプロビジョニング プロセスの一部として実行されます。<br>何らかの要因によって vmssCSE 拡張機能によるノードの初期化が成功しなかった場合には、新規作成された AKS ノードの起動が完了しない状態となります。</p><p>vmssCSE 拡張機能によるノードの初期化が成功しないと、次のような事象が発生します。</p><ul><li>AKS クラスターの作成失敗</li><li>AKS クラスターやノードプールのアップグレード失敗</li><li>ノードプール追加やスケールアウト失敗</li><li>停止された AKS クラスターの起動失敗</li></ul><p>ノードの初期化が成功しない理由の多くは、ネットワーク通信に関連する要因です。<br>特に、ファイアーウォールやカスタム DNS サーバーなど、ネットワーク構成をカスタマイズしている環境において、AKS クラスターの動作に必要な通信が成功しないことによって事象が発生します。</p><p><img src="/blog/containers/aks-vmsscse/aks-vmsscse01.png" alt="ノード初期化が成功しない場合に想定される要因箇所"></p><p>Azure 仮想マシンの拡張機能は、<a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/extensions/troubleshoot">実行結果をお客様にてご確認いただくことが可能です</a>。<br>また、vmssCSE 拡張機能で実行されるノードの初期化スクリプトは、成功しなかった理由に応じてエラー ステータスを出力します。</p><p>そのため、上記のような事象が発生した場合には、vmssCSE 拡張機能の実行結果をご確認いただくことで、要因箇所の特定に役立つ手がかりを得ることができます。</p><h2 id="vmssCSE-拡張機能のステータスと確認方法"><a href="#vmssCSE-拡張機能のステータスと確認方法" class="headerlink" title="vmssCSE 拡張機能のステータスと確認方法"></a>vmssCSE 拡張機能のステータスと確認方法</h2><p>vmssCSE 拡張機能のステータスから、AKS ノードの初期化が正常に実行されたかどうかを確認できます。主な確認項目は次の2つです。</p><ol><li>ステータス コード (code)<ul><li>拡張機能の実行結果を示します</li><li><code>ProvisioningState/succeeded</code> の場合は成功です</li><li><code>ProvisioningState/failed</code> の場合は失敗です</li></ul></li><li>メッセージ (message)<ul><li>初期化スクリプトの実行結果とログが出力されます</li><li>トラブルシューティングでは特に <code>ExitCode</code> の値に注目します</li><li><code>ExitCode</code> が <code>0</code> の場合は成功です</li><li><code>0</code> 以外 (<code>50</code>, <code>51</code>, など) の場合は何らかの要因で失敗しています</li></ul></li></ol><p>次に、Azure Portal と Azure CLI で確認する方法を紹介します。</p><h3 id="Azure-Portal-で確認する方法"><a href="#Azure-Portal-で確認する方法" class="headerlink" title="Azure Portal で確認する方法"></a>Azure Portal で確認する方法</h3><p>ノード リソース グループ (既定では <code>MC_</code> で始まるリソース グループ) を開き、ノードプールで使用されている VMSS リソースを開きます。<br>左メニューから [インスタンス] を選択し、状態を確認したい VMSS インスタンスをクリックします。</p><p><img src="/blog/containers/aks-vmsscse/aks-vmsscse02.png"></p><p>インスタンスの詳細画面の [状態] 項目のリンクをクリックします。</p><p><img src="/blog/containers/aks-vmsscse/aks-vmsscse03.png"></p><p>[拡張機能の状態] &gt; [vmssCSE] をクリックし、メッセージ内容を確認します。</p><p><img src="/blog/containers/aks-vmsscse/aks-vmsscse04.png"></p><h3 id="Azure-CLI-で確認する方法"><a href="#Azure-CLI-で確認する方法" class="headerlink" title="Azure CLI で確認する方法"></a>Azure CLI で確認する方法</h3><p>Azure CLI では下記コマンドで確認できます。<br>ノード リソース グループと VMSS リソース名を指定してコマンドを実行します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">az vmss list-instances --resource-group &lt;NODE RESOURCE GROUP&gt; --name &lt;VMSS NAME&gt; \</span><br><span class="line">    --expand instanceView --query &quot;[].&#123;name:name, extensions: instanceView.extensions&#125;&quot;</span><br></pre></td></tr></table></figure><p>下記が実行例となります。<br><code>&quot;extensions&quot;</code> の配下に<code>&quot;name&quot;: &quot;vmssCSE&quot;</code> という名前で情報が出力されます。<br><code>&quot;statuses&quot;</code> の <code>&quot;code&quot;</code> と、<code>&quot;message&quot;</code> に含まれる <code>\&quot;ExitCode\&quot;</code> の値を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az vmss list-instances --resource-group MC_myResourceGroup_myAKSCluster_japaneast --name aks-agentpool-20329050-vmss \</span></span><br><span class="line"><span class="bash">    --expand instanceView --query <span class="string">&quot;[].&#123;name:name, extensions: instanceView.extensions&#125;&quot;</span></span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;extensions&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;vmssCSE&quot;,</span><br><span class="line">        &quot;statuses&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;code&quot;: &quot;ProvisioningState/succeeded&quot;,</span><br><span class="line">            &quot;displayStatus&quot;: &quot;Provisioning succeeded&quot;,</span><br><span class="line">            &quot;level&quot;: &quot;Info&quot;,</span><br><span class="line">            &quot;message&quot;: &quot;Enable succeeded: \n[stdout]\n&#123; \&quot;ExitCode\&quot;: \&quot;0\&quot;, \&quot;Output\&quot;: \&quot;Wed Feb 2 10:21:47 UTC 2022,aks-agentpool-20329050-vmss000004\\n(省略)&quot;,</span><br><span class="line">            &quot;time&quot;: null</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;substatuses&quot;: null,</span><br><span class="line">        &quot;type&quot;: &quot;Microsoft.Azure.Extensions.CustomScript&quot;,</span><br><span class="line">        &quot;typeHandlerVersion&quot;: &quot;2.1.6&quot;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      (省略)</span><br><span class="line"></span><br><span class="line">    ],</span><br><span class="line">    &quot;name&quot;: &quot;aks-agentpool-20329050-vmss_4&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="vmssCSE-拡張機能の代表的な-ExitCode"><a href="#vmssCSE-拡張機能の代表的な-ExitCode" class="headerlink" title="vmssCSE 拡張機能の代表的な ExitCode"></a>vmssCSE 拡張機能の代表的な ExitCode</h2><p>このセクションでは、vmssCSE 拡張機能で発生することがある代表的な ExitCode について、原因とトラブルシューティングの方法を解説します。</p><ul><li><a href="./#ExitCode-50">ExitCode: 50 (送信接続の失敗)</a></li><li><a href="./#ExitCode-51">ExitCode: 51 (AKS API サーバーへのコネクション失敗)</a></li><li><a href="./#ExitCode-52">ExitCode: 52 (AKS API サーバーの名前解決が失敗)</a></li><li><a href="./#ExitCode-53">ExitCode: 53 (Azure DNS Service による AKS API サーバーの名前解決が失敗)</a></li></ul><h3 id="ExitCode-50"><a href="#ExitCode-50" class="headerlink" title="ExitCode: 50"></a>ExitCode: 50</h3><p>ExitCode: 50 のエラーは、AKS ノードの動作に必要となる通信先へのコネクションが成功しない場合に発生します。</p><blockquote><p><strong>OutboundConnFailVMExtensionError エラー コードのトラブルシューティング (50) - Azure / Microsoft Learn</strong><br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/azure-kubernetes/error-code-outboundconnfailvmextensionerror">https://learn.microsoft.com/ja-jp/troubleshoot/azure/azure-kubernetes/error-code-outboundconnfailvmextensionerror</a></p></blockquote><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>AKS ノードに必要なコンポーネントは、Microsoft Container Registry (MCR) のエンドポイント (mcr.microsoft.com, 443/tcp) から取得されます。</p><p>ノードの初期化スクリプトが実行されると、はじめに MCR のエンドポイントへ到達可能であるかアクセス検証を行います。<br>このとき、ノードから MCR エンドポイントへのコネクションが成功しなかった場合に、ExitCode: 50 のエラーが発生します。</p><p>MCR エンドポイントへのコネクションが成功しない要因としては、次のような理由が挙げられます。</p><ul><li>DNS による名前解決が失敗している</li><li>NSG でブロックされている</li><li>Azure Firewall / ネットワーク仮想アプライアンス (NVA) でブロックされている</li></ul><h4 id="トラブルシューティング"><a href="#トラブルシューティング" class="headerlink" title="トラブルシューティング"></a>トラブルシューティング</h4><p>AKS ノードから mcr.microsoft.com に対して、実際にアクセスできる状態であるかを確認します。<br><code>az vmss run-command</code> コマンドを利用して、VMSS インスタンス上でアクセス検証用のコマンドを実行します。</p><p>はじめに、mcr.microsoft.com の名前解決が成功するかどうかを確認します。<br>次のように、<code>az vmss run-command</code> コマンドの <code>--scripts</code> オプションに <code>nslookup</code> コマンドを指定して実行します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">az vmss run-command invoke -g &lt;NODE RESOURCE GROUP&gt; -n &lt;VMSS NAME&gt; \</span><br><span class="line">    --command-id RunShellScript --instance-id &lt;INSTANCE_ID&gt; \</span><br><span class="line">    --scripts &quot;nslookup mcr.microsoft.com&quot;</span><br></pre></td></tr></table></figure><p><strong>成功の例</strong></p><p><code>&quot;message&quot;</code> フィールドに <code>nslookup</code> コマンドの実行結果が出力されます。<br><code>Address: 204.79.197.219</code> のように、mcr.microsoft.com の IP アドレスが表示されていれば、名前解決は成功しています。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az vmss run-command invoke -g MC_myResourceGroup_myAKSCluster_japaneast -n aks-agentpool-20329050-vmss \</span></span><br><span class="line"><span class="bash">    --command-id RunShellScript --instance-id 0 \</span></span><br><span class="line"><span class="bash">    --scripts <span class="string">&quot;nslookup mcr.microsoft.com&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;value&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: &quot;ProvisioningState/succeeded&quot;,</span><br><span class="line">      &quot;displayStatus&quot;: &quot;Provisioning succeeded&quot;,</span><br><span class="line">      &quot;level&quot;: &quot;Info&quot;,</span><br><span class="line">      &quot;message&quot;: &quot;Enable succeeded: \n[stdout]\nServer:\t\t168.63.129.16\nAddress:\t168.63.129.16#53\n\nNon-authoritative answer:\nmcr.microsoft.com\tcanonical name = global.fe.mscr.io.\nglobal.fe.mscr.io\tcanonical name = mcr-microsoft-com.a-0016.a-msedge.net.\nmcr-microsoft-com.a-0016.a-msedge.net\tcanonical name = a-0016.a-msedge.net.\nName:\ta-0016.a-msedge.net\nAddress: 204.79.197.219\n\n\n[stderr]\n&quot;,</span><br><span class="line">      &quot;time&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>失敗の例</strong></p><p>IP アドレスが出力されておらず、<code>server can&#39;t find mcr.microsoft.com</code> のようなエラーメッセージや <code>NXDOMAIN</code> が出力されている場合は、名前解決が成功していません。</p><p>ご利用の環境において<a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/virtual-networks-name-resolution-for-vms-and-role-instances?tabs=redhat#name-resolution-that-uses-your-own-dns-server">カスタム DNS サーバーを使用している</a>場合は、AKS ノードが存在する VNet に対して、カスタム DNS サーバーが正しく構成されているかどうかをご確認ください。<br>また、カスタム DNS サーバーが mcr.microsoft.com の名前解決をできる状態であるか、動作・設定をご確認ください。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az vmss run-command invoke -g MC_myRG_myAKSCluster_japaneast -n aks-nodepool1-15399206-vmss \</span></span><br><span class="line"><span class="bash">    --command-id RunShellScript --instance-id 2 \</span></span><br><span class="line"><span class="bash">    --scripts <span class="string">&quot;nslookup mcr.microsoft.com&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;value&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: &quot;ProvisioningState/succeeded&quot;,</span><br><span class="line">      &quot;displayStatus&quot;: &quot;Provisioning succeeded&quot;,</span><br><span class="line">      &quot;level&quot;: &quot;Info&quot;,</span><br><span class="line">      &quot;message&quot;: &quot;Enable succeeded: \n[stdout]\nServer:\t\t127.0.0.53\nAddress:\t127.0.0.53#53\n\n** server can&#x27;t find mcr.microsoft.com: SERVFAIL\n\n\n[stderr]\n&quot;,</span><br><span class="line">      &quot;time&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>名前解決が成功したら、mcr.microsoft.com への疎通ができる状態であるかを確認します。<br>次のように、<code>nc</code> コマンドを指定して実行します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">az vmss run-command invoke -g &lt;NODE RESOURCE GROUP&gt; -n &lt;VMSS NAME&gt; \</span><br><span class="line">    --command-id RunShellScript --instance-id &lt;INSTANCE_ID&gt; \</span><br><span class="line">    --scripts &quot;nc -vz mcr.microsoft.com 443&quot;</span><br></pre></td></tr></table></figure><p><strong>成功の例</strong></p><p><code>Connection to mcr.microsoft.com 443 port [tcp/https] succeeded!</code> とメッセージが表示されていれば、アクセスが成功しています。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az vmss run-command invoke -g MC_myResourceGroup_myAKSCluster_japaneast -n aks-agentpool-20329050-vmss \</span></span><br><span class="line"><span class="bash">    --command-id RunShellScript --instance-id 1 \</span></span><br><span class="line"><span class="bash">    --scripts <span class="string">&quot;nc -vz mcr.microsoft.com 443&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;value&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: &quot;ProvisioningState/succeeded&quot;,</span><br><span class="line">      &quot;displayStatus&quot;: &quot;Provisioning succeeded&quot;,</span><br><span class="line">      &quot;level&quot;: &quot;Info&quot;,</span><br><span class="line">      &quot;message&quot;: &quot;Enable succeeded: \n[stdout]\n\n[stderr]\nConnection to mcr.microsoft.com 443 port [tcp/https] succeeded!\n&quot;,</span><br><span class="line">      &quot;time&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>失敗の例</strong></p><p><code>nc: connect to mcr.microsoft.com port 443 (tcp) failed</code> と表示された場合には、通信が失敗しています。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az vmss run-command invoke -g MC_myRG_myAKSCluster_japaneast -n aks-nodepool1-20916290-vmss \</span></span><br><span class="line"><span class="bash">    --command-id RunShellScript --instance-id 1 \</span></span><br><span class="line"><span class="bash">    --scripts <span class="string">&quot;nc -vz mcr.microsoft.com 443&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;value&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: &quot;ProvisioningState/succeeded&quot;,</span><br><span class="line">      &quot;displayStatus&quot;: &quot;Provisioning succeeded&quot;,</span><br><span class="line">      &quot;level&quot;: &quot;Info&quot;,</span><br><span class="line">      &quot;message&quot;: &quot;Enable succeeded: \n[stdout]\n\n[stderr]\nnc: connect to mcr.microsoft.com port 443 (tcp) failed: Connection timed out\n&quot;,</span><br><span class="line">      &quot;time&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>この場合、何らかの要因によってノードから送信された通信がブロックされている可能性が考えられます。<br>NSG やファイアーウォールで通信制御をしている場合は、AKS クラスターに必要な FQDN への通信が許可されているかご確認ください。</p><blockquote><p>ご参考) AKS クラスターに必要な送信ネットワーク規則と FQDN<br><a href="https://learn.microsoft.com/ja-jp/azure/aks/outbound-rules-control-egress#required-outbound-network-rules-and-fqdns-for-aks-clusters">https://learn.microsoft.com/ja-jp/azure/aks/outbound-rules-control-egress#required-outbound-network-rules-and-fqdns-for-aks-clusters</a></p></blockquote><div class="alert is-success"><p class="alert-title">ヒント</p><p>Azure Firewall で通信制御をする場合には、AKS 用の FQDN タグ <code>AzureKubernetesService</code> が利用可能です。</p><p>この FQDN タグには、「<a href="https://learn.microsoft.com/ja-jp/azure/aks/outbound-rules-control-egress#required-outbound-network-rules-and-fqdns-for-aks-clusters">AKS クラスターに必要な送信ネットワーク規則と FQDN</a>」に記載されているすべての FQDN が含まれており、自動的に更新されます。</p><p>以前は各 FQDN を個別に許可いただく必要がありましたが、現在は FQDN タグを利用することで一括で通信許可できるようになっておりますので、ご活用ください。</p><p>　</p><p>ご参考) Azure Kubernetes Service (AKS) で Azure Firewall を使用してエグレス トラフィックを制御する</p><p><a href="https://learn.microsoft.com/ja-jp/azure/aks/limit-egress-traffic">https://learn.microsoft.com/ja-jp/azure/aks/limit-egress-traffic</a></p></div><h3 id="ExitCode-51"><a href="#ExitCode-51" class="headerlink" title="ExitCode: 51"></a>ExitCode: 51</h3><p>ExitCode: 51 のエラーは、AKS ノードがクラスターの API サーバーへ接続できない場合に発生します。</p><blockquote><p><strong>K8SAPIServerConnFailVMExtensionError エラー コードのトラブルシューティング - Azure / Microsoft Learn</strong><br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/azure-kubernetes/error-code-k8sapiserverconnfailvmextensionerror">https://learn.microsoft.com/ja-jp/troubleshoot/azure/azure-kubernetes/error-code-k8sapiserverconnfailvmextensionerror</a></p></blockquote><h4 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h4><p>ExitCode: 51 の発生状況は、上述した <a href="./#ExitCode-50">ExitCode: 50</a> と似ています。異なる点は通信先です。</p><p>ExitCode: 50 は、mcr.microsoft.com へのアクセスが成功しない場合に発生します。<br>一方 ExitCode: 51 は、AKS の API サーバーへのアクセスが成功しない場合に発生します。<br>NSG やファイアーウォールを使って通信制限をしている環境において、mcr.microsoft.com へのアクセスは許可されているものの、AKS API サーバーの FQDN や IP アドレスに対する通信が許可されていない場合に、発生が想定されます。</p><h4 id="トラブルシューティング-1"><a href="#トラブルシューティング-1" class="headerlink" title="トラブルシューティング"></a>トラブルシューティング</h4><p>AKS ノードから AKS API サーバーに対して、実際にアクセスできる状態であるかを確認します。</p><p>はじめに、対象の AKS クラスターで使用されている API サーバーの FQDN を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az aks show -g &lt;RESOURCE GROUP&gt; --name &lt;CLUSTER&gt; --query fqdn</span><br></pre></td></tr></table></figure><p><code>az vmss run-command</code> コマンドを利用して、VMSS インスタンス上でアクセス検証用のコマンドを実行します。<br>次のように、<code>nc</code> コマンドに API サーバーの FQDN を指定して実行します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">az vmss run-command invoke -g &lt;NODE RESOURCE GROUP&gt; -n &lt;VMSS NAME&gt; \</span><br><span class="line">    --command-id RunShellScript --instance-id &lt;INSTANCE_ID&gt; \</span><br><span class="line">    --scripts &quot;nc -vz &lt;API Server FQDN&gt; 443&quot;</span><br></pre></td></tr></table></figure><p><strong>成功の例</strong></p><p><code>Connection to &lt;API Server FQDN&gt; 443 port [tcp/https] succeeded!</code> とメッセージが表示されていれば、アクセスが成功しています。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az vmss run-command invoke -g MC_my-ResourceGroup_myAKSCluster_japaneast -n aks-nodepool1-27512147-vmss \</span></span><br><span class="line"><span class="bash">    --command-id RunShellScript --instance-id 2 \</span></span><br><span class="line"><span class="bash">    --scripts <span class="string">&quot;nc -vz myakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io 443&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;value&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: &quot;ProvisioningState/succeeded&quot;,</span><br><span class="line">      &quot;displayStatus&quot;: &quot;Provisioning succeeded&quot;,</span><br><span class="line">      &quot;level&quot;: &quot;Info&quot;,</span><br><span class="line">      &quot;message&quot;: &quot;Enable succeeded: \n[stdout]\n\n[stderr]\nConnection to myakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io 443 port [tcp/https] succeeded!\n&quot;,</span><br><span class="line">      &quot;time&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>失敗例</strong></p><p><code>nc: connect to &lt;API Server FQDN&gt; port 443 (tcp) failed</code> と表示された場合には、通信が失敗しています。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az vmss run-command invoke -g MC_my-ResourceGroup_myAKSCluster_japaneast -n aks-nodepool1-27512147-vmss \</span></span><br><span class="line"><span class="bash">    --command-id RunShellScript --instance-id 3 \</span></span><br><span class="line"><span class="bash">    --scripts <span class="string">&quot;nc -vz myakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io 443&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;value&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: &quot;ProvisioningState/succeeded&quot;,</span><br><span class="line">      &quot;displayStatus&quot;: &quot;Provisioning succeeded&quot;,</span><br><span class="line">      &quot;level&quot;: &quot;Info&quot;,</span><br><span class="line">      &quot;message&quot;: &quot;Enable succeeded: \n[stdout]\n\n[stderr]\nnc: connect to myakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io port 443 (tcp) failed: No route to host\n&quot;,</span><br><span class="line">      &quot;time&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>この場合、何らかの要因によってノードから送信された通信がブロックされている可能性が考えられます。<br>NSG やファイアーウォールで通信制御をしている場合は、AKS クラスターに必要な FQDN への通信が許可されているかご確認ください。</p><blockquote><p>ご参考) AKS クラスターに必要な送信ネットワーク規則と FQDN<br><a href="https://learn.microsoft.com/ja-jp/azure/aks/outbound-rules-control-egress#required-outbound-network-rules-and-fqdns-for-aks-clusters">https://learn.microsoft.com/ja-jp/azure/aks/outbound-rules-control-egress#required-outbound-network-rules-and-fqdns-for-aks-clusters</a></p></blockquote><p>プライベート AKS クラスターでは、API サーバーへのアクセスにプライベート エンドポイントを使用します。<br>VNet に独自のプライベート エンドポイント リソースを作成している場合は、対象の AKS クラスターのプライベート エンドポイントとして正しく構成されているかご確認ください。</p><blockquote><p>ご参考) プライベート エンドポイント接続を使用する<br><a href="https://learn.microsoft.com/ja-jp/azure/aks/private-clusters?tabs=azure-portal#use-a-private-endpoint-connection">https://learn.microsoft.com/ja-jp/azure/aks/private-clusters?tabs=azure-portal#use-a-private-endpoint-connection</a><br>特に、プライベート クラスターの停止・再起動をした場合には、このドキュメントの「警告」に記載の内容をご確認ください。</p></blockquote><h3 id="ExitCode-52"><a href="#ExitCode-52" class="headerlink" title="ExitCode: 52"></a>ExitCode: 52</h3><p>ExitCode: 52 のエラーは、DNS を使用して、AKS ノードが AKS API サーバーの完全修飾ドメイン名 (FQDN) を名前解決できない場合に発生します。</p><blockquote><p><strong>K8SAPIServerDNSLookupFailVMExtensionError エラー コードのトラブルシューティング (52) - Azure / Microsoft Learn</strong><br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/azure-kubernetes/error-code-k8sapiserverdnslookupfailvmextensionerror">https://learn.microsoft.com/ja-jp/troubleshoot/azure/azure-kubernetes/error-code-k8sapiserverdnslookupfailvmextensionerror</a></p></blockquote><h4 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h4><p>AKS ノードが動作するためには、AKS の API サーバーにアクセスする必要があります。</p><p>AKS ノードが AKS API サーバーに正常にアクセスできない場合には、ノードの初期化が成功しません。<br>アクセスできない要因が、DNS を利用して AKS API サーバーの FQDN を IP アドレスへ名前解決できないことである場合に ExitCode: 52 が発生します。</p><p>ExitCode: 52 が発生した場合は、DNS による名前解決が関連しているものと要因箇所を絞り込めます。</p><h4 id="トラブルシューティング-2"><a href="#トラブルシューティング-2" class="headerlink" title="トラブルシューティング"></a>トラブルシューティング</h4><p>はじめに、対象の AKS クラスターで使用されている API サーバーの FQDN を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az aks show -g &lt;RESOURCE GROUP&gt; --name &lt;CLUSTER&gt; --query fqdn</span><br></pre></td></tr></table></figure><p><code>az vmss run-command</code> コマンドを利用して、VMSS インスタンス上で名前解決の検証コマンドを実行します。<br>次のように、<code>nslookup</code> コマンドに API サーバーの FQDN を指定して実行します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">az vmss run-command invoke -g &lt;NODE RESOURCE GROUP&gt; -n &lt;VMSS NAME&gt; \</span><br><span class="line">    --command-id RunShellScript --instance-id &lt;INSTANCE_ID&gt; \</span><br><span class="line">    --scripts &quot;nslookup &lt;API Server FQDN&gt;&quot;</span><br></pre></td></tr></table></figure><p><strong>成功の例</strong></p><p><code>&quot;message&quot;</code> フィールドに <code>nslookup</code> コマンドの実行結果が出力されます。<br><code>Address: 10.240.0.5</code> のように、AKS API サーバーの IP アドレスが表示されていれば、名前解決は成功しています。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az vmss run-command invoke -g MC_my-ResourceGroup_myAKSCluster_japaneast -n aks-nodepool1-27512147-vmss \</span></span><br><span class="line"><span class="bash">    --command-id RunShellScript --instance-id 4 \</span></span><br><span class="line"><span class="bash">    --scripts <span class="string">&quot;nslookup myakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;value&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: &quot;ProvisioningState/succeeded&quot;,</span><br><span class="line">      &quot;displayStatus&quot;: &quot;Provisioning succeeded&quot;,</span><br><span class="line">      &quot;level&quot;: &quot;Info&quot;,</span><br><span class="line">      &quot;message&quot;: &quot;Enable succeeded: \n[stdout]\nServer:\t\t168.63.129.16\nAddress:\t168.63.129.16#53\n\nNon-authoritative answer:\nName:\tmyakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io\nAddress: 10.240.0.4\n\n\n[stderr]\n&quot;,</span><br><span class="line">      &quot;time&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上記の例では、プライベート AKS クラスターの名前解決のため、IP アドレスは VNet に割り当てられているプライベート IP アドレスとなっています。</p><p><strong>失敗の例</strong></p><p>IP アドレスが出力されておらず、<code>server can&#39;t find &lt;API Server FQDN&gt;</code> のようなエラーメッセージや <code>NXDOMAIN</code> が出力されている場合は、名前解決が成功していません。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az vmss run-command invoke -g MC_test-RG_myAKSCluster-test_japaneast -n aks-nodepool1-73583151-vmss \</span></span><br><span class="line"><span class="bash">    --command-id RunShellScript --instance-id 0 \</span></span><br><span class="line"><span class="bash">    --scripts <span class="string">&quot;nslookup myakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;value&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: &quot;ProvisioningState/succeeded&quot;,</span><br><span class="line">      &quot;displayStatus&quot;: &quot;Provisioning succeeded&quot;,</span><br><span class="line">      &quot;level&quot;: &quot;Info&quot;,</span><br><span class="line">      &quot;message&quot;: &quot;Enable succeeded: \n[stdout]\nServer:\t\t192.168.1.4\nAddress:\t192.168.1.4#53\n\n** server can&#x27;t find myakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io: NXDOMAIN\n\n\n[stderr]\n&quot;,</span><br><span class="line">      &quot;time&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上記の例では、DNS サーバー <code>192.168.1.4</code> が名前解決の結果を応答しています。この DNS サーバーは、Azure 既定で提供される DNS サービスではなく、VNet に設定した<a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/virtual-networks-name-resolution-for-vms-and-role-instances?tabs=redhat#name-resolution-that-uses-your-own-dns-server">カスタム DNS サーバー</a>です。</p><p>名前解決の結果が <code>NXDOMAIN</code> となっています。要求された FQDN に該当する DNS レコードがカスタム DNS サーバー内で見つからず、「そのドメイン名は存在しない」という結果を応答しています。<br>この場合、カスタム DNS サーバーの動作・設定を確認し、AKS API サーバーの IP アドレスに名前解決できる状態であるかを確認します。</p><p>カスタム DNS サーバー上に DNS レコードを作成している場合は、API サーバーの正しい IP アドレスで A レコードが作成されていることを確認します。<br>名前解決のリクエストを<a href="https://learn.microsoft.com/ja-jp/azure/aks/private-clusters?tabs=azure-portal#hub-and-spoke-with-custom-dns">上位の DNS サーバーに転送</a>している場合は、DNS フォワーダーが正しく設定・動作しているかを確認します。</p><h3 id="ExitCode-53"><a href="#ExitCode-53" class="headerlink" title="ExitCode: 53"></a>ExitCode: 53</h3><p>ExitCode: 53 のエラーは、<a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/virtual-networks-name-resolution-for-vms-and-role-instances">Azure 既定の DNS サービス</a>を使用して、AKS ノードが AKS API サーバーの完全修飾ドメイン名 (FQDN) を名前解決できない場合に発生します。</p><h4 id="原因-3"><a href="#原因-3" class="headerlink" title="原因"></a>原因</h4><p>AKS ノードが AKS API サーバーに正常にアクセスできない場合に発生します。<br>状況は ExitCode: 52 と似ていますが、異なる点は、名前解決の結果を応答した DNS サーバーです。</p><p>VNet にカスタム DNS サーバーが設定されていない場合は、Azure の DNS サービスによって名前解決が提供されます。<br>Azure 既定の DNS サービスである <code>168.63.129.16</code> で名前解決が成功しなかった場合に、ExitCode: 53 が発生します。</p><blockquote><p>ご参考) IP アドレス 168.63.129.16 とは<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/what-is-ip-address-168-63-129-16">https://learn.microsoft.com/ja-jp/azure/virtual-network/what-is-ip-address-168-63-129-16</a></p></blockquote><p>(プライベートではない) 通常の AKS クラスターと、プライベート AKS クラスターの一部の構成では、クラスター作成と同時に API サーバーの DNS レコードが作成されるため、API サーバーの名前解決の結果が <code>NXDOMAIN</code> にはならない想定です。<br>一方、プライベート AKS クラスターの作成時に、独自の Azure Private DNS Zone を使用するように指定した場合では注意が必要です。</p><p>Azure Private DNS Zone を使用した名前解決では、DNS のリクエストを Azure の DNS サービスに対して送信します。<br>Private DNS Zone 内に AKS API サーバーの DNS レコードが存在しないと、<code>168.63.129.16</code> から <code>NXDOMAIN</code> の応答が返され、ExitCode: 53 が発生します。</p><div class="alert is-success"><p class="alert-title">ヒント</p><p>プライベート AKS クラスターでは、クラスター作成時の<code>--private-dns-zone</code> オプションに応じて、API サーバーの DNS レコードの管理方法が変更可能です。</p><p>ご参考) プライベート DNS ゾーンを構成する</p><p><a href="https://learn.microsoft.com/ja-jp/azure/aks/private-clusters?tabs=azure-portal#configure-a-private-dns-zone">https://learn.microsoft.com/ja-jp/azure/aks/private-clusters?tabs=azure-portal#configure-a-private-dns-zone</a></p></div><h4 id="トラブルシューティング-3"><a href="#トラブルシューティング-3" class="headerlink" title="トラブルシューティング"></a>トラブルシューティング</h4><p>はじめに、対象の AKS クラスターで使用されている API サーバーの FQDN を確認します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az aks show -g &lt;RESOURCE GROUP&gt; --name &lt;CLUSTER&gt; --query fqdn</span><br></pre></td></tr></table></figure><p><code>az vmss run-command</code> コマンドを利用して、VMSS インスタンス上で名前解決の検証コマンドを実行します。<br>次のように、<code>nslookup</code> コマンドに API サーバーの FQDN を指定して実行します。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">az vmss run-command invoke -g &lt;NODE RESOURCE GROUP&gt; -n &lt;VMSS NAME&gt; \</span><br><span class="line">    --command-id RunShellScript --instance-id &lt;INSTANCE_ID&gt; \</span><br><span class="line">    --scripts &quot;nslookup &lt;API Server FQDN&gt;&quot;</span><br></pre></td></tr></table></figure><p><strong>成功の例</strong></p><p><code>&quot;message&quot;</code> フィールドに <code>nslookup</code> コマンドの実行結果が出力されます。<br><code>Address: 10.240.0.5</code> のように、AKS API サーバーの IP アドレスが表示されていれば、名前解決は成功しています。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az vmss run-command invoke -g MC_my-RG_myAKSCluster_japaneast -n aks-nodepool1-22506348-vmss \</span></span><br><span class="line"><span class="bash">    --command-id RunShellScript --instance-id 0 \</span></span><br><span class="line"><span class="bash">    --scripts <span class="string">&quot;nslookup myakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io&quot;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;value&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: &quot;ProvisioningState/succeeded&quot;,</span><br><span class="line">      &quot;displayStatus&quot;: &quot;Provisioning succeeded&quot;,</span><br><span class="line">      &quot;level&quot;: &quot;Info&quot;,</span><br><span class="line">      &quot;message&quot;: &quot;Enable succeeded: \n[stdout]\nServer:\t\t168.63.129.16\nAddress:\t168.63.129.16#53\n\nNon-authoritative answer:\nName:\tmyakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io\nAddress: 10.240.0.4\n\n\n[stderr]\n&quot;,</span><br><span class="line">      &quot;time&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>失敗の例</strong></p><p>IP アドレスが出力されておらず、<code>server can&#39;t find &lt;API Server FQDN&gt;</code> のようなエラーメッセージや <code>NXDOMAIN</code> が出力されている場合は、名前解決が成功していません。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> az vmss run-command invoke -g MC_my-RG_myAKSCluster_japaneast -n aks-nodepool1-22506348-vmss</span> </span><br><span class="line">    --command-id RunShellScript --instance-id 0 \</span><br><span class="line">    --scripts &quot;nslookup myakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io&quot;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;value&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;code&quot;: &quot;ProvisioningState/succeeded&quot;,</span><br><span class="line">      &quot;displayStatus&quot;: &quot;Provisioning succeeded&quot;,</span><br><span class="line">      &quot;level&quot;: &quot;Info&quot;,</span><br><span class="line">      &quot;message&quot;: &quot;Enable succeeded: \n[stdout]\nServer:\t\t168.63.129.16\nAddress:\t168.63.129.16#53\n\n** server can&#x27;t find myakscluster.xxxxxxxxxx.privatelink.japaneast.azmk8s.io: NXDOMAIN\n\n\n[stderr]\n&quot;,</span><br><span class="line">      &quot;time&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上記の例では、プライベート AKS クラスターの FQDN の名前解決を検証しています。<br>名前解決の結果を応答した DNS サーバーが、Azure の DNS サービスで使用される IP アドレス <code>168.63.129.16</code> となっていることが確認できます。<br><code>NXDOMAIN</code> が返されているため、API サーバーの FQDN に該当する DNS レコードが発見できなかった状態となります。</p><p>このような場合は、Private DNS Zone の構成と DNS レコードの作成状況を確認します。<br>AKS ノードが存在する VNet と、Private DNS Zone との間に仮想ネットワーク リンクが設定されていることを確認します。<br>また、AKS API サーバーの FQDN に該当する A レコードが作成されているかどうかを確認します。<br>仮想ネットワーク リンクの構成方法と DNS レコードの作成については、次のプライベート AKS クラスターのドキュメントをご参照ください。</p><blockquote><p>ご参考) プライベート エンドポイント接続を使用する<br><a href="https://learn.microsoft.com/ja-jp/azure/aks/private-clusters?tabs=azure-portal#use-a-private-endpoint-connection">https://learn.microsoft.com/ja-jp/azure/aks/private-clusters?tabs=azure-portal#use-a-private-endpoint-connection</a></p></blockquote><div class="alert is-warning"><p class="alert-title">警告</p><p>プライベート エンドポイントのリソースをお客様にて独自に作成されている場合は、クラスターの停止・起動において注意が必要です。</p><p>この場合、クラスターの停止と再起動をすると、プライベート リンク サービスが削除され、プライベート エンドポイントとプライベート AKS クラスターの間の接続が切断されます。</p><p>この問題を解決するには、プライベート エンドポイントの再作成ならびに DNS レコードの再登録が必要です。</p><p>下記リンクの「警告」のセクションをあわせてご確認ください。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/aks/private-clusters?tabs=azure-portal#link-the-private-dns-zone-to-the-virtual-network">https://learn.microsoft.com/ja-jp/azure/aks/private-clusters?tabs=azure-portal#link-the-private-dns-zone-to-the-virtual-network</a></p></div><h3 id="その他の-ExitCode"><a href="#その他の-ExitCode" class="headerlink" title="その他の ExitCode"></a>その他の ExitCode</h3><p>上記で紹介した 50 ～ 53 の ExitCode が、AKS において発生することのある代表的な ExitCode となります。</p><p>このほかにも、ExitCode の定義自体はいくつかの種類があり、ごく稀に本記事で紹介したものとは異なる ExitCode が発生する場合がございます。</p><blockquote><p>トラブルシューティング ページに記載のある ExitCode では、ExitCode 124 が挙げられます。<br>　<br>ご参考) ERR_VHD_FILE_NOT_FOUND エラー コードのトラブルシューティング - Azure / Microsoft Learn<br><a href="https://learn.microsoft.com/ja-jp/troubleshoot/azure/azure-kubernetes/error-code-vhdfilenotfound">https://learn.microsoft.com/ja-jp/troubleshoot/azure/azure-kubernetes/error-code-vhdfilenotfound</a></p></blockquote><p>ExitCode の一覧は、AKS ノードイメージの生成で使われるスクリプト内に定義がございます。<br>このスクリプトは GitHub のリポジトリに公開されていますので、ご興味のある方は下記 URL よりご確認ください。</p><blockquote><p>ご参考) vmssCSE exit codes<br><a href="https://github.com/Azure/AgentBaker/blob/master/parts/linux/cloud-init/artifacts/cse_helpers.sh">https://github.com/Azure/AgentBaker/blob/master/parts/linux/cloud-init/artifacts/cse_helpers.sh</a></p></blockquote><p>万が一、本記事や AKS トラブルシューティングのページに記載のない ExitCode が発生し、お客様にてトラブルシューティングが難しい場合には、お気兼ねなく Azure サポートまでご相談ください。</p><h2 id="vmssCSE-拡張機能が成功しなかったノードの復旧"><a href="#vmssCSE-拡張機能が成功しなかったノードの復旧" class="headerlink" title="vmssCSE 拡張機能が成功しなかったノードの復旧"></a>vmssCSE 拡張機能が成功しなかったノードの復旧</h2><p>VMSS インスタンスの拡張機能は、インスタンスを”再イメージ化”することで、あらためて実行可能です。</p><p>ノード初期化を妨げる要因を取り除いたあとは、VMSS インスタンスの再イメージ化を行い、クラスターにノードが追加されることをご確認ください。<br>再イメージ化の方法は、次の URL のドキュメントをご参照ください。</p><blockquote><p>ご参考) 既存の VM の “再イメージ化”<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-upgrade-policy#exceptions-to-upgrade-policies">https://learn.microsoft.com/ja-jp/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-upgrade-policy#exceptions-to-upgrade-policies</a></p></blockquote><p>すでに存在する VMSS インスタンスはそのままの状態で、新規ノードが作成可能であるかを確認したいという場合には、ノードプールのスケール操作によって、ノードの追加をすることをご検討ください。<br>ノードプールのスケール方法は、次の URL のドキュメントをご参照ください。</p><blockquote><p>ご参考) ノード プールの手動でのスケーリング<br><a href="https://learn.microsoft.com/ja-jp/azure/aks/manage-node-pools#scale-a-node-pool-manually">https://learn.microsoft.com/ja-jp/azure/aks/manage-node-pools#scale-a-node-pool-manually</a></p></blockquote><h2 id="さいごに"><a href="#さいごに" class="headerlink" title="さいごに"></a>さいごに</h2><p>今回紹介しました内容が、AKS をよりご活用いただくうえでのご参考になりましたら幸いです。<br>また、AKS のご利用において、お困りの点やご不明点がありました際は、いつでも Azure サポートまでお気兼ねなくご相談ください。</p><hr><p>本記事の執筆にあたっては、Azure テクニカル サポートチームの沈さんはじめ多くの方々にご支援をいただきました。<br>この場をお借りし、ご協力いただいた皆様に深く感謝申し上げます。ありがとうございました。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは。Azure テクニカル サポートチームの桐井です。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://learn.microsoft.com/ja-jp/azure/aks/intro-kubernetes&quot;&gt;Azure Kubernetes Service (AKS)&lt;/a&gt; クラスターで、ノードの新規作成が成功しない事象や、停止したクラスターの起動が成功しないといった事象が発生することがございます。&lt;/p&gt;
&lt;p&gt;このような事象は、ノードの初期化が成功していない場合に発生するもので、弊社サポート事例においても多くのお客様よりご相談をいただくことがございます。&lt;/p&gt;
&lt;p&gt;本記事では、AKS ノードの初期化を担う vmssCSE 拡張機能についての解説と、ノード初期化が成功しない代表的な要因とトラブルシューティング方法について紹介します。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Containers" scheme="https://jpaztech.github.io/blog/tags/Containers/"/>
    
    <category term="Azure Kubernetes Service (AKS)" scheme="https://jpaztech.github.io/blog/tags/Azure-Kubernetes-Service-AKS/"/>
    
  </entry>
  
  <entry>
    <title>ゾーン未指定時の VM 起動ゾーン、およびサブスクリプション毎のゾーン番号指す物理ゾーンについて</title>
    <link href="https://jpaztech.github.io/blog/vm/physical-zone/"/>
    <id>https://jpaztech.github.io/blog/vm/physical-zone/</id>
    <published>2023-12-04T04:00:00.000Z</published>
    <updated>2024-02-16T07:05:26.482Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの富田です。<br>今年も日本マイクロソフトの社員がお届けする、<a href="https://qiita.com/advent-calendar/2023/microsoft-azure-tech">Microsoft Azure Tech Advent Calendar 2023</a> の「シリーズ 2」、12 月 4 日分の記事として公開させていただきます。<br>Advent Calendar には他にも多くの Azure に関する有益な記事がございますので、是非ご参照いただけますと幸いです。</p><p>本記事ではお問い合わせ頂くことも多い、 Azure VM で可用性ゾーンを未指定の場合にはゾーン番号が何処になるかは分からない点と、サブスクリプション毎にゾーン番号が指し示す物理ゾーンが違う点について解説させていただきます。  </p><hr><h2 id="可用性ゾーンを未指定の場合のゾーンについて"><a href="#可用性ゾーンを未指定の場合のゾーンについて" class="headerlink" title="可用性ゾーンを未指定の場合のゾーンについて"></a>可用性ゾーンを未指定の場合のゾーンについて</h2><p>可用性ゾーンに対応するリージョンでは Azure VM の可用性ゾーンを指定することで、ご希望のゾーン上に VM をデプロイすることが可能です。<br>ゾーンは原則 1 ～ 3 番のゾーン番号で指定が可能でございます。  </p><blockquote><p>■ご参考：可用性ゾーン<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/availability#availability-zones">https://learn.microsoft.com/ja-jp/azure/virtual-machines/availability#availability-zones</a></p></blockquote><p>なお、可用性ゾーンを未指定の場合はゾーン 1 ～ 3 いずれかのゾーンで VM が起動されますが、どのゾーンで VM が起動されるかは把握することは叶いません。<br>VM 割り当て解除をして起動することでゾーンが変更となることもございます。<br>加えて現在どのゾーンで VM が起動しているかといったことも確認をすることが叶いません。<br>特定ゾーンでの稼働が必要な場合は、可用性ゾーンを指定して VM をデプロイいただくようにお願いいたします。  </p><hr><h2 id="サブスクリプション毎にゾーン番号が指し示す物理ゾーンが違う点について"><a href="#サブスクリプション毎にゾーン番号が指し示す物理ゾーンが違う点について" class="headerlink" title="サブスクリプション毎にゾーン番号が指し示す物理ゾーンが違う点について"></a>サブスクリプション毎にゾーン番号が指し示す物理ゾーンが違う点について</h2><p>Azure ポータル等で表示・指定できるゾーン番号は、サブスクリプション毎に指し示す物理ゾーンが異なります。<br>Azure ポータル等で表示・指定できるゾーン番号のことを「論理ゾーン」、実際の物理的なゾーンの場所のことを「物理ゾーン」と呼びます。<br>例えば東日本リージョンでは以下のように物理ゾーンが 3 つございます。  </p><ul><li>japaneast-az1 </li><li>japaneast-az2 </li><li>japaneast-az3</li></ul><p>この際にサブスクリプションによって、以下の例のように指し示すゾーンが違う場合がございます。  </p><p><strong>contoso サブスクリプションの場合</strong></p><table><thead><tr><th align="left">論理ゾーン番号</th><th align="left">実際の物理ゾーン</th></tr></thead><tbody><tr><td align="left">1 番</td><td align="left">japaneast-az1</td></tr><tr><td align="left">2 番</td><td align="left">japaneast-az2</td></tr><tr><td align="left">3 番</td><td align="left">japaneast-az3</td></tr></tbody></table><p><strong>hogehoge サブスクリプションの場合</strong></p><table><thead><tr><th align="left">論理ゾーン番号</th><th align="left">実際の物理ゾーン</th></tr></thead><tbody><tr><td align="left">1 番</td><td align="left">japaneast-az3</td></tr><tr><td align="left">2 番</td><td align="left">japaneast-az1</td></tr><tr><td align="left">3 番</td><td align="left">japaneast-az2</td></tr></tbody></table><p>そのため、「contoso サブスクリプション」と「hogehoge サブスクリプション」でどちらも Azure ポータルから論理ゾーン 1 番に VM を作成したとしても、実際の物理ゾーンは違う場所であるといったことが発生します。<br>これは特定のゾーンに需要が偏らないようにするために必要な措置でございます点、ご理解いただけますと幸いです。  </p><hr><h2 id="論理ゾーンと物理ゾーンのマッピングを-REST-API-で確認する"><a href="#論理ゾーンと物理ゾーンのマッピングを-REST-API-で確認する" class="headerlink" title="論理ゾーンと物理ゾーンのマッピングを REST API で確認する"></a>論理ゾーンと物理ゾーンのマッピングを REST API で確認する</h2><p>論理ゾーン番号と実際の物理ゾーンのマッピングについては以下の REST API を用いて確認する事が可能です。  </p><p>■ご参考：Subscriptions - List Locations<br><a href="https://learn.microsoft.com/ja-jp/rest/api/resources/subscriptions/list-locations">https://learn.microsoft.com/ja-jp/rest/api/resources/subscriptions/list-locations</a></p><p>上記ページの「使ってみる」を選択し、対象サブスクリプションでログインした後に表示された画面で「実行」をすると、各リージョンについて、そのサブスクリプションでの論理ゾーン番号と実際の物理ゾーンのマッピングが<br>確認出来ます。<br>以下は実行結果例の抜粋です。この結果はサブスクリプション毎に違うことがございます。  </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;/subscriptions/XXXX/locations/japaneast&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;japaneast&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;Region&quot;,</span><br><span class="line">～～～～～～～～～～中略～～～～～～～～～～</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;availabilityZoneMappings&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;logicalZone&quot;: &quot;1&quot;,</span><br><span class="line">          &quot;physicalZone&quot;: &quot;japaneast-az2&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;logicalZone&quot;: &quot;2&quot;,</span><br><span class="line">          &quot;physicalZone&quot;: &quot;japaneast-az3&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;logicalZone&quot;: &quot;3&quot;,</span><br><span class="line">          &quot;physicalZone&quot;: &quot;japaneast-az1&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>上記の例では、このサブスクリプションでは東日本リージョンで論理ゾーン 1 番を選ぶと、物理ゾーン japaneast-az2 にデプロイされるといったことが確認できます。  </p><hr><h2 id="サブスクリプション間の論理ゾーンのマッピングを-REST-API-で確認する"><a href="#サブスクリプション間の論理ゾーンのマッピングを-REST-API-で確認する" class="headerlink" title="サブスクリプション間の論理ゾーンのマッピングを REST API で確認する"></a>サブスクリプション間の論理ゾーンのマッピングを REST API で確認する</h2><p>別のサブスクリプションとの論理ゾーン同士のマッピングについても後述の通り REST API にて確認が可能です。<br>すなわち、「contoso 社サブスクリプション」の論理ゾーン 1 番は「hogehoge 社サブスクリプション」の論理ゾーン 2 番と同じである、との点について確認が可能です。  </p><p>■ご参考：Subscriptions - Check Zone Peers<br><a href="https://learn.microsoft.com/ja-jp/rest/api/resources/subscriptions/check-zone-peers">https://learn.microsoft.com/ja-jp/rest/api/resources/subscriptions/check-zone-peers</a></p><p>上記ページの「使ってみる」より、サブスクリプション間の論理ゾーンのマッピングを確認する方法を解説させていただきます。  </p><p>まずはこの比較用の Microsoft.Resources/AvailabilityZonePeering 機能が有効か確認します。<br>Azure Cloud Shell 等を用いて、比較元サブスクリプションにて以下の Azure CLI コマンドを実行します。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az feature show --namespace Microsoft.Resources --name AvailabilityZonePeering --subscription 比較元サブスクリプションID | jq .properties.state</span><br></pre></td></tr></table></figure><p>上記コマンドの結果として “Registered” と表示されていない場合は、以下の Azure CLI コマンドで機能を登録します。<br>なお、”Registered” の状態になるまでお時間がかかることがございます。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az feature register --namespace Microsoft.Resources --name AvailabilityZonePeering</span><br></pre></td></tr></table></figure><p>上記ページの「使ってみる」を選択して、比較元サブスクリプションでログインします。<br>その後表示された「REST API 使ってみる」のページにて、パラメーターの subscriptionId で比較元サブスクリプションを選択します。  </p><p>そして、「REST API 使ってみる」のページの本文のエリアに以下の例のように、比較対象のリージョンおよび比較先サブスクリプション ID を記載します。<br>以下の通り複数サブスクリプションを設定することも可能です。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;location&quot;: &quot;リージョン名（japaneast など）&quot;,</span><br><span class="line">  &quot;subscriptionIds&quot;: [</span><br><span class="line">    &quot;subscriptions/比較先サブスクリプションAのID&quot;,</span><br><span class="line">    &quot;subscriptions/比較先サブスクリプションBのID&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>その後、実行ボタンを選択すると以下の例のような結果が得られます。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;subscriptionId&quot;: &quot;比較元サブスクリプションID&quot;,</span><br><span class="line">  &quot;location&quot;: &quot;japaneast&quot;,</span><br><span class="line">  &quot;availabilityZonePeers&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;availabilityZone&quot;: &quot;1&quot;,</span><br><span class="line">      &quot;peers&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;subscriptionId&quot;: &quot;比較先サブスクリプションAのID&quot;,</span><br><span class="line">          &quot;availabilityZone&quot;: &quot;3&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;subscriptionId&quot;: &quot;比較先サブスクリプションBのID&quot;,</span><br><span class="line">          &quot;availabilityZone&quot;: &quot;2&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;availabilityZone&quot;: &quot;2&quot;,</span><br><span class="line">      &quot;peers&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;subscriptionId&quot;: &quot;比較先サブスクリプションAのID&quot;,</span><br><span class="line">          &quot;availabilityZone&quot;: &quot;2&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;subscriptionId&quot;: &quot;比較先サブスクリプションBのID&quot;,</span><br><span class="line">          &quot;availabilityZone&quot;: &quot;1&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;availabilityZone&quot;: &quot;3&quot;,</span><br><span class="line">      &quot;peers&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;subscriptionId&quot;: &quot;比較先サブスクリプションAのID&quot;,</span><br><span class="line">          &quot;availabilityZone&quot;: &quot;1&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;subscriptionId&quot;: &quot;比較先サブスクリプションBのID&quot;,</span><br><span class="line">          &quot;availabilityZone&quot;: &quot;3&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上記の結果より、比較元サブスクリプションの論理ゾーン 1 は、  </p><ul><li>比較先サブスクリプション A では、論理ゾーン 3</li><li>比較先サブスクリプション B では、論理ゾーン 2</li></ul><p>と同じ、物理ゾーンを指しているといったマッピングの確認ができました。  </p><p>上述の内容がお客様のお役に立てますと幸いでございます。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの富田です。&lt;br&gt;今年も日本マイクロソフトの社員がお届けする、&lt;a href=&quot;https://qiita.com/advent-calendar/2023/microsoft-azure-tech&quot;&gt;Microsoft</summary>
      
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
    <category term="Windows" scheme="https://jpaztech.github.io/blog/tags/Windows/"/>
    
    <category term="Linux" scheme="https://jpaztech.github.io/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>可用性セット・可用性ゾーン・近接配置グループの併用について</title>
    <link href="https://jpaztech.github.io/blog/vm/availability_options_with_ppg/"/>
    <id>https://jpaztech.github.io/blog/vm/availability_options_with_ppg/</id>
    <published>2023-12-04T03:00:00.000Z</published>
    <updated>2024-02-16T07:05:26.286Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームの富田です。<br>Azure VM における可用性セット・可用性ゾーン・近接配置グループの併用について解説させていただきます。<br>結論から記載すると以下の通り併用可能・不可能といった状況となっております。  </p><ul><li>「可用性セット」と「可用性ゾーン」：併用できません</li><li>「可用性セット」と「近接配置グループ」：併用可</li><li>「可用性ゾーン」と「近接配置グループ」：併用可</li></ul><p>以下に解説させていただきます。<br>まず、「可用性セット」と「可用性ゾーン」はどちらも VM の可用性を高めるためのオプションでございます。  </p><p>「可用性セット」と「可用性ゾーン」はいずれも仮想マシンの配置を分散することで障害やメンテナンスの影響を同時に受けることを回避するという同じ目的で利用されますため、併用することは叶いません。<br>ご利用の際はどちらか片方のみをご選択いただくこととなります。<br>なお、可用性セットについては単一ゾーン内で分散される一方で、可用性ゾーンについては配置するゾーン自体を分散するためゾーン単位の障害に対する耐性がございます。  </p><p>他方、「近接配置グループ」は特定の複数の VM を物理的に近い位置に配置し、VM 間のレイテンシーを可能な限り低減するといったオプションとなります。<br>「近接配置グループ」は「可用性セット」もしくは「可用性ゾーン」との併用が可能です。<br>各機能については公式ドキュメントもご参照いただけますと幸いです。  </p><p>■ご参考：Azure Virtual Machines の可用性オプション<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/availability">https://learn.microsoft.com/ja-jp/azure/virtual-machines/availability</a></p><p>■ご参考：近接配置グループ<br><a href="https://learn.microsoft.com/ja-jp/azure/virtual-machines/co-location">https://learn.microsoft.com/ja-jp/azure/virtual-machines/co-location</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームの富田です。&lt;br&gt;Azure VM における可用性セット・可用性ゾーン・近接配置グループの併用について解説させていただきます。&lt;br&gt;結論から記載すると以下の通り併用可能・不可能といった状況となっております。  &lt;/p&gt;</summary>
      
    
    
    
    
    <category term="VM" scheme="https://jpaztech.github.io/blog/tags/VM/"/>
    
  </entry>
  
  <entry>
    <title>東日本リージョンでの Azure Firewall のゾーン冗長に関するアナウンスの補足 (Tracking ID:7KYK-R8G)</title>
    <link href="https://jpaztech.github.io/blog/network/fw_notification_7kyk-r8g/"/>
    <id>https://jpaztech.github.io/blog/network/fw_notification_7kyk-r8g/</id>
    <published>2023-12-01T05:30:00.000Z</published>
    <updated>2024-02-16T07:05:26.202Z</updated>
    
    <content type="html"><![CDATA[<p>こんにちは、Azure テクニカル サポート チームです。<br>2023 年 11 月 29 日に Azure Firewall で東日本リージョンの物理ゾーン #2 の使用に関するアナウンスがされました(Tracking ID:7KYK-R8G)。<br>アナウンスされた内容は英語でのご案内であるため、この記事にて補足させていただきます。</p><span id="more"></span><h2 id="通知内容の日本語抄訳"><a href="#通知内容の日本語抄訳" class="headerlink" title="通知内容の日本語抄訳"></a>通知内容の日本語抄訳</h2><p>東日本リージョンの物理ゾーン #2 にデプロイされた Azure Firewall に関する問題について、詳細をご報告いたします。<br>現在、可用性ゾーンを指定して Azure Firewall を構成する際に、東日本リージョンの物理ゾーン #2 をご利用いただくことが出来ないという問題が発生しております。<br>この問題は全ての SKU (basic / standard / premium) に影響があり、また、新規の Azure Firewall リソースのデプロイだけでなく、既存の Azure Firewall の起動にも影響を及ぼす可能性がございます。<br>現在事象の解消に向けた作業を実施しており、現時点で本制限は 2024 年 12 月に解除される予定となっております。</p><h3 id="対応が必要な事項"><a href="#対応が必要な事項" class="headerlink" title="対応が必要な事項"></a>対応が必要な事項</h3><p><strong>本記事では通知内容をよりわかりやすく整理しております。</strong></p><h4 id="1-東日本リージョンで新規に可用性ゾーンを持つ-Azure-Firewall-をデプロイしたい場合："><a href="#1-東日本リージョンで新規に可用性ゾーンを持つ-Azure-Firewall-をデプロイしたい場合：" class="headerlink" title="1 東日本リージョンで新規に可用性ゾーンを持つ Azure Firewall をデプロイしたい場合："></a>1 東日本リージョンで新規に可用性ゾーンを持つ Azure Firewall をデプロイしたい場合：</h4><p>1-1 お客様のサブスクリプション内で、東日本リージョンの物理ゾーン #2 にマッピングされている論理ゾーンの番号を確認してください。次項の<a href="#%E7%89%A9%E7%90%86%E3%82%BE%E3%83%BC%E3%83%B3-2-%E3%81%AB%E3%83%9E%E3%83%83%E3%83%94%E3%83%B3%E3%82%B0%E3%81%95%E3%82%8C%E3%81%9F%E8%AB%96%E7%90%86%E3%82%BE%E3%83%BC%E3%83%B3%E3%81%AE%E7%A2%BA%E8%AA%8D%E6%96%B9%E6%B3%95">物理ゾーン #2 にマッピングされた論理ゾーンの確認方法</a>をご覧ください。</p><p>1-2 物理ゾーン #2 にマッピングされている論理ゾーンの使用を避けてください。この地域の他のゾーンに  Azure Firewall をデプロイするか、別のリージョン（例：オーストラリア東部）にデプロイしてください。</p><h4 id="2-東日本リージョンで可用性ゾーンを指定せずに-Azure-Firewall-をデプロイしている場合："><a href="#2-東日本リージョンで可用性ゾーンを指定せずに-Azure-Firewall-をデプロイしている場合：" class="headerlink" title="2 東日本リージョンで可用性ゾーンを指定せずに Azure Firewall をデプロイしている場合："></a>2 東日本リージョンで可用性ゾーンを指定せずに Azure Firewall をデプロイしている場合：</h4><p>2-1 必要な対応はございません。</p><h4 id="3-東日本リージョンで単一の可用性ゾーンを指定して-Azure-Firewall-をデプロイしている場合："><a href="#3-東日本リージョンで単一の可用性ゾーンを指定して-Azure-Firewall-をデプロイしている場合：" class="headerlink" title="3 東日本リージョンで単一の可用性ゾーンを指定して Azure Firewall をデプロイしている場合："></a>3 東日本リージョンで単一の可用性ゾーンを指定して Azure Firewall をデプロイしている場合：</h4><p>3-1 お客様のサブスクリプション内で、東日本リージョンの物理ゾーン #2にマッピングされている論理ゾーンの番号を確認してください。次項の<a href="#%E7%89%A9%E7%90%86%E3%82%BE%E3%83%BC%E3%83%B3-2-%E3%81%AB%E3%83%9E%E3%83%83%E3%83%94%E3%83%B3%E3%82%B0%E3%81%95%E3%82%8C%E3%81%9F%E8%AB%96%E7%90%86%E3%82%BE%E3%83%BC%E3%83%B3%E3%81%AE%E7%A2%BA%E8%AA%8D%E6%96%B9%E6%B3%95">物理ゾーン #2 にマッピングされた論理ゾーンの確認方法</a>をご覧ください。</p><p>3-2 お客様の Azure Firewall が物理ゾーン #2 にマッピングされているゾーンでデプロイされている場合、<a href="https://learn.microsoft.com/ja-jp/azure/firewall/firewall-faq#-----------------------------:~:text=%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4%E5%BE%8C%E3%81%AB%E5%8F%AF%E7%94%A8%E6%80%A7%E3%82%BE%E3%83%BC%E3%83%B3%E3%82%92%E6%A7%8B%E6%88%90%E3%81%99%E3%82%8B%E3%81%AB%E3%81%AF%E3%81%A9%E3%81%86%E3%81%99%E3%82%8C%E3%81%B0%E3%82%88%E3%81%84%E3%81%A7%E3%81%99%E3%81%8B%3F">stop / startを使用して可用性ゾーンの設定を更新</a>し、他の可用性ゾーンを使用することが推奨されます。</p><h4 id="4-東日本リージョンで複数の可用性ゾーンにわたって-Azure-Firewall-をデプロイしている場合："><a href="#4-東日本リージョンで複数の可用性ゾーンにわたって-Azure-Firewall-をデプロイしている場合：" class="headerlink" title="4 東日本リージョンで複数の可用性ゾーンにわたって Azure Firewall をデプロイしている場合："></a>4 東日本リージョンで複数の可用性ゾーンにわたって Azure Firewall をデプロイしている場合：</h4><p>4-1 お客様のサブスクリプション内で、東日本リージョンの物理ゾーン #2にマッピングされている論理ゾーンの番号を確認してください。次項の<a href="#%E7%89%A9%E7%90%86%E3%82%BE%E3%83%BC%E3%83%B3-2-%E3%81%AB%E3%83%9E%E3%83%83%E3%83%94%E3%83%B3%E3%82%B0%E3%81%95%E3%82%8C%E3%81%9F%E8%AB%96%E7%90%86%E3%82%BE%E3%83%BC%E3%83%B3%E3%81%AE%E7%A2%BA%E8%AA%8D%E6%96%B9%E6%B3%95">物理ゾーン #2 にマッピングされた論理ゾーンの確認方法</a>をご覧ください。</p><p>4-2 お客様の Azure Firewall が物理ゾーン #2 にマッピングされているゾーンを含んでデプロイされている場合でもそのままご利用いただけますが、何らかの理由でこのファイアウォールを<a href="https://learn.microsoft.com/ja-jp/azure/firewall/firewall-faq#azure-firewall-----------------:~:text=Azure%20Firewall%20%E3%81%AE%E5%81%9C%E6%AD%A2%E3%81%A8%E8%B5%B7%E5%8B%95%E3%81%AE%E6%96%B9%E6%B3%95%E3%82%92%E6%95%99%E3%81%88%E3%81%A6%E3%81%8F%E3%81%A0%E3%81%95%E3%81%84">停止</a>した場合、物理ゾーン #2 を除いた<a href="https://learn.microsoft.com/ja-jp/azure/firewall/firewall-faq#-----------------------------:~:text=%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4%E5%BE%8C%E3%81%AB%E5%8F%AF%E7%94%A8%E6%80%A7%E3%82%BE%E3%83%BC%E3%83%B3%E3%82%92%E6%A7%8B%E6%88%90%E3%81%99%E3%82%8B%E3%81%AB%E3%81%AF%E3%81%A9%E3%81%86%E3%81%99%E3%82%8C%E3%81%B0%E3%82%88%E3%81%84%E3%81%A7%E3%81%99%E3%81%8B%3F">異なる Availability Zones の設定で再起動</a>する必要があります。</p><p>以上の条件と必要な対応をまとめたフローチャートは以下の通りになります。<br><img src="./flow_chart.png"></p><h3 id="物理ゾーン-2-にマッピングされた論理ゾーンの確認方法"><a href="#物理ゾーン-2-にマッピングされた論理ゾーンの確認方法" class="headerlink" title="物理ゾーン #2 にマッピングされた論理ゾーンの確認方法"></a>物理ゾーン #2 にマッピングされた論理ゾーンの確認方法</h3><p>物理ゾーンは、Azure サブスクリプションや地域ごとに異なる論理ゾーンにマッピングされています。お客様のAzureサブスクリプションでこの物理ゾーンにマッピングされた論理ゾーンを確認するには、<a href="https://learn.microsoft.com/en-us/azure/reliability/availability-zones-overview?tabs=azure-cli#physical-and-logical-availability-zones">本ドキュメントの手順</a>をご実施ください。（現在、ドキュメントは英語のみとなります。本ブログ記事の<a href="#%E7%89%A9%E7%90%86%E3%82%BE%E3%83%BC%E3%83%B3%E3%81%A8%E8%AB%96%E7%90%86%E3%82%BE%E3%83%BC%E3%83%B3%E3%81%AE%E3%83%9E%E3%83%83%E3%83%94%E3%83%B3%E3%82%B0%E3%81%AE%E7%A2%BA%E8%AA%8D%E6%96%B9%E6%B3%95">物理ゾーンと論理ゾーンのマッピングの確認方法</a>にも手順を記載しております。）</p><p>本問題に関して、情報のアップデートが行われた際には、速やかに最新の情報をご案内いたします。<br>この度は、お客様にご不便をおかけし、大変申し訳ありません。</p><h2 id="物理ゾーンと論理ゾーンのマッピングの確認方法"><a href="#物理ゾーンと論理ゾーンのマッピングの確認方法" class="headerlink" title="物理ゾーンと論理ゾーンのマッピングの確認方法"></a>物理ゾーンと論理ゾーンのマッピングの確認方法</h2><p>物理ゾーンと論理ゾーンのマッピングは以下のコマンドで確認が可能です。</p><p>Azure CLI の場合</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">az rest --method get --uri <span class="string">&#x27;/subscriptions/&#123;サブスクリプション ID&#125;/locations?api-version=2022-12-01&#x27;</span> --query <span class="string">&#x27;value&#x27;</span></span><br></pre></td></tr></table></figure><p>Azure PowerShell の場合</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$subscriptionId</span> = (<span class="built_in">Get-AzContext</span>).Subscription.ID</span><br><span class="line"><span class="variable">$response</span> = <span class="built_in">Invoke-AzRestMethod</span> <span class="literal">-Method</span> GET <span class="literal">-Path</span> <span class="string">&quot;/subscriptions/<span class="variable">$subscriptionId</span>/locations?api-version=2022-12-01&quot;</span></span><br><span class="line"><span class="variable">$locations</span> = (<span class="variable">$response</span>.Content | <span class="built_in">ConvertFrom-Json</span>).value | <span class="built_in">where</span> &#123; <span class="variable">$_</span>.Name <span class="operator">-eq</span> <span class="string">&quot;japaneast&quot;</span> &#125;; <span class="variable">$locations</span></span><br></pre></td></tr></table></figure><p>コマンドを実行すると、各リージョンの物理ゾーンと論理ゾーンのマッピング情報が取得できます。このマッピングはサブスクリプションごとに異なります。<br>以下は各コマンドごとの取得したマッピング情報の抜粋となります。</p><p>Azure CLI の場合</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;availabilityZoneMappings&quot;</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;logicalZone&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;physicalZone&quot;</span>: <span class="string">&quot;japaneast-az2&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;logicalZone&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;physicalZone&quot;</span>: <span class="string">&quot;japaneast-az3&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;logicalZone&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;physicalZone&quot;</span>: <span class="string">&quot;japaneast-az1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>Azure PowerShell の場合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">id                       : /subscriptions/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/locations/japaneast</span><br><span class="line">name                     : japaneast</span><br><span class="line">type                     : Region</span><br><span class="line">displayName              : Japan East</span><br><span class="line">regionalDisplayName      : (Asia Pacific) Japan East</span><br><span class="line">metadata                 : @&#123;regionType=Physical; regionCategory=Recommended; geography=Japan; geographyGroup=Asia Paci</span><br><span class="line">                           fic; longitude=139.77; latitude=35.68; physicalLocation=Tokyo, Saitama; pairedRegion=System.</span><br><span class="line">                           Object[]&#125;</span><br><span class="line">availabilityZoneMappings : &#123;@&#123;logicalZone=1; physicalZone=japaneast-az2&#125;, @&#123;logicalZone=2; physicalZone=japaneast-az3&#125;,</span><br><span class="line">                            @&#123;logicalZone=3; physicalZone=japaneast-az1&#125;&#125;</span><br></pre></td></tr></table></figure><p>logicalZone が論理ゾーンとなり、通常、ポータルやコマンドで見えているゾーンの番号となります。<br>physicalZone が物理ゾーンとなります。<br>今回は japaneast-az2 と紐づいている logicalZone の番号を Azure Firewall のデプロイ時に指定しないように対応が必要となります。</p><h2 id="Azure-Firewall-の可用性ゾーンの確認方法"><a href="#Azure-Firewall-の可用性ゾーンの確認方法" class="headerlink" title="Azure Firewall の可用性ゾーンの確認方法"></a>Azure Firewall の可用性ゾーンの確認方法</h2><p>Azure Firewall の可用性ゾーンは Azure ポータル &gt; Azure Firewall リソース &gt; プロパティ ブレード &gt; 可用性ゾーンの項目から確認できます。<br><br>以下の画像は可用性ゾーンの指定がない Azure Firewall の画面です。<br><img src="./azfw_az.png"></p><h2 id="Azure-Firewall-の停止および可用性ゾーンを指定する開始方法"><a href="#Azure-Firewall-の停止および可用性ゾーンを指定する開始方法" class="headerlink" title="Azure Firewall の停止および可用性ゾーンを指定する開始方法"></a>Azure Firewall の停止および可用性ゾーンを指定する開始方法</h2><p>Azure Firewall の Azure PowerShell での停止方法は以下のコマンドになります。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$azfw</span> = <span class="built_in">Get-AzFirewall</span> <span class="literal">-Name</span> <span class="string">&quot;ファイアウォール名&quot;</span> <span class="literal">-ResourceGroupName</span> <span class="string">&quot;リソースグループ名&quot;</span></span><br><span class="line"><span class="variable">$azfw</span>.Deallocate()</span><br><span class="line"><span class="built_in">Set-AzFirewall</span> <span class="literal">-AzureFirewall</span> <span class="variable">$azfw</span></span><br></pre></td></tr></table></figure><div class="alert is-warning"><p class="alert-title">警告</p><p>単一の可用性ゾーンを指定して Azure Firewall と同時に作成された パブリック IP は他の可用性ゾーンでは使用できません。新たに Standard のパブリック IP アドレス リソースを他の可用性ゾーンに対応する形で作成しておく必要があります。</p></div><p>パブリック IP アドレスの作成についての詳細は以下のドキュメントをご参考ください。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/virtual-network/ip-services/virtual-network-public-ip-address">Azure パブリック IP アドレスを作成、変更、または削除する - Azure Virtual Network | Microsoft Learn</a></p><p> Azure PowerShell で全ての可用性ゾーンに対応した パブリック IP アドレスを作成するには以下のコマンドで行えます。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ip</span> = <span class="selector-tag">@</span>&#123;</span><br><span class="line">    Name = <span class="string">&#x27;新しい Public IP 名&#x27;</span></span><br><span class="line">    ResourceGroupName = <span class="string">&#x27;リソースグループ名&#x27;</span></span><br><span class="line">    Location = <span class="string">&#x27;japaneast&#x27;</span></span><br><span class="line">    Sku = <span class="string">&#x27;Standard&#x27;</span></span><br><span class="line">    AllocationMethod = <span class="string">&#x27;Static&#x27;</span></span><br><span class="line">    IpAddressVersion = <span class="string">&#x27;IPv4&#x27;</span></span><br><span class="line">    Zone = <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">New-AzPublicIpAddress</span> @ip</span><br></pre></td></tr></table></figure><p>例として、論理ゾーン 1 が物理ゾーン 2 の場合において、論理ゾーン 2, 3（物理ゾーン 1, 3）を指定して Azure Firewall を Azure PowerShell で開始する方法は以下のコマンドになります。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$azfw</span> = <span class="built_in">Get-AzFirewall</span> <span class="literal">-Name</span> <span class="string">&quot;ファイアウォール名&quot;</span> <span class="literal">-ResourceGroupName</span> <span class="string">&quot;リソースグループ名&quot;</span></span><br><span class="line"><span class="variable">$vnet</span> = <span class="built_in">Get-AzVirtualNetwork</span> <span class="literal">-ResourceGroupName</span> <span class="string">&quot;リソースグループ名&quot;</span> <span class="literal">-Name</span> <span class="string">&quot;VNet 名&quot;</span></span><br><span class="line"><span class="variable">$pip</span>= <span class="built_in">Get-AzPublicIpAddress</span> <span class="literal">-ResourceGroupName</span> <span class="string">&quot;リソースグループ名&quot;</span> <span class="literal">-Name</span> <span class="string">&quot;Public IP 名&quot;</span></span><br><span class="line"><span class="variable">$azfw</span>.Allocate(<span class="variable">$vnet</span>, <span class="variable">$pip</span>)</span><br><span class="line"><span class="variable">$azFw</span>.Zones=<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="variable">$azfw</span> | <span class="built_in">Set-AzFirewall</span></span><br></pre></td></tr></table></figure><p>例として、2 つの Public IP が関連付けられており、マネージメント サブネットの Public IP がある Azure Firewall を論理ゾーン 2, 3（物理ゾーン 1, 3）を指定して Azure PowerShell で開始する方法は以下のコマンドになります。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$azfw</span> = <span class="built_in">Get-AzFirewall</span> <span class="literal">-Name</span> <span class="string">&quot;ファイアウォール名&quot;</span> <span class="literal">-ResourceGroupName</span> <span class="string">&quot;リソースグループ名&quot;</span></span><br><span class="line"><span class="variable">$vnet</span> = <span class="built_in">Get-AzVirtualNetwork</span> <span class="literal">-ResourceGroupName</span> <span class="string">&quot;リソースグループ名&quot;</span> <span class="literal">-Name</span> <span class="string">&quot;VNet 名&quot;</span></span><br><span class="line"><span class="variable">$pip1</span>= <span class="built_in">Get-AzPublicIpAddress</span> <span class="literal">-ResourceGroupName</span> <span class="string">&quot;リソースグループ名&quot;</span> <span class="literal">-Name</span> <span class="string">&quot;Public IP 名&quot;</span></span><br><span class="line"><span class="variable">$pip2</span>= <span class="built_in">Get-AzPublicIpAddress</span> <span class="literal">-ResourceGroupName</span> <span class="string">&quot;リソースグループ名&quot;</span> <span class="literal">-Name</span> <span class="string">&quot;Public IP2 名&quot;</span></span><br><span class="line"><span class="variable">$mgmtPip</span> = <span class="built_in">Get-AzPublicIpAddress</span> <span class="literal">-ResourceGroupName</span> <span class="string">&quot;リソースグループ名&quot;</span> <span class="literal">-Name</span> <span class="string">&quot;マネージメント サブネットの Public IP 名&quot;</span></span><br><span class="line"><span class="variable">$azfw</span>.Allocate(<span class="variable">$vnet</span>, <span class="selector-tag">@</span>(<span class="variable">$pip1</span>,<span class="variable">$pip2</span>), <span class="variable">$mgmtPip</span>)</span><br><span class="line"><span class="variable">$azFw</span>.Zones=<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="variable">$azfw</span> | <span class="built_in">Set-AzFirewall</span></span><br></pre></td></tr></table></figure><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="Azure-Firewall-を物理ゾーン-2-のみにデプロイしている場合の影響は何ですか"><a href="#Azure-Firewall-を物理ゾーン-2-のみにデプロイしている場合の影響は何ですか" class="headerlink" title="Azure Firewall を物理ゾーン #2 のみにデプロイしている場合の影響は何ですか"></a>Azure Firewall を物理ゾーン #2 のみにデプロイしている場合の影響は何ですか</h3><p>Azure Firewall が処理するトラフィック量が増加した際のスケールアウトが失敗する可能性があります。</p><h3 id="SLA-に影響ありますか"><a href="#SLA-に影響ありますか" class="headerlink" title="SLA に影響ありますか"></a>SLA に影響ありますか</h3><p>今回の通知内容の事象が SLA に影響することはございません。<br>SLA については以下のドキュメントの「可用性ゾーン」の項目に記載がございます。</p><p><a href="https://learn.microsoft.com/ja-jp/azure/firewall/features#availability-zones">Azure Firewall Standard の機能</a></p><h3 id="費用の差異はありますか"><a href="#費用の差異はありますか" class="headerlink" title="費用の差異はありますか"></a>費用の差異はありますか</h3><p>今回の事象の発生期間と発生していない期間では、Azure Firewall の費用に対しての違いはございません。</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;こんにちは、Azure テクニカル サポート チームです。&lt;br&gt;2023 年 11 月 29 日に Azure Firewall で東日本リージョンの物理ゾーン #2 の使用に関するアナウンスがされました(Tracking ID:7KYK-R8G)。&lt;br&gt;アナウンスされた内容は英語でのご案内であるため、この記事にて補足させていただきます。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Network" scheme="https://jpaztech.github.io/blog/tags/Network/"/>
    
    <category term="Azure Firewall" scheme="https://jpaztech.github.io/blog/tags/Azure-Firewall/"/>
    
  </entry>
  
</feed>
